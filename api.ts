/* tslint:disable */
/* eslint-disable */
/**
 * Finverse Public
 * Documentation of the early finverse services
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: devs@finverse.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface AccessTokenResponse
 */
export interface AccessTokenResponse {
  /**
   *
   * @type {string}
   * @memberof AccessTokenResponse
   */
  access_token: string;
  /**
   *
   * @type {string}
   * @memberof AccessTokenResponse
   */
  login_identity_id: string;
  /**
   *
   * @type {string}
   * @memberof AccessTokenResponse
   */
  token_type: string;
  /**
   * seconds
   * @type {number}
   * @memberof AccessTokenResponse
   */
  expires_in: number;
  /**
   *
   * @type {string}
   * @memberof AccessTokenResponse
   */
  refresh_token: string;
}
/**
 *
 * @export
 * @interface Account
 */
export interface Account {
  /**
   *
   * @type {string}
   * @memberof Account
   */
  account_id: string;
  /**
   * The SHA3-256 hash of the account number, salted with the loginIdentityId
   * @type {string}
   * @memberof Account
   */
  group_id: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  account_holder_name?: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  account_name: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  account_nickname?: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  account_type?: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  account_sub_type?: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  country?: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  updated_at?: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  account_currency?: string;
  /**
   *
   * @type {CurrencyAmount}
   * @memberof Account
   */
  balance?: CurrencyAmount;
  /**
   *
   * @type {CurrencyAmount}
   * @memberof Account
   */
  statement_balance?: CurrencyAmount;
  /**
   *
   * @type {boolean}
   * @memberof Account
   */
  is_parent: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Account
   */
  is_closed: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Account
   */
  is_excluded: boolean;
}
/**
 *
 * @export
 * @interface AccountNumber
 */
export interface AccountNumber {
  /**
   *
   * @type {string}
   * @memberof AccountNumber
   */
  account_id: string;
  /**
   *
   * @type {string}
   * @memberof AccountNumber
   */
  number?: string;
  /**
   *
   * @type {string}
   * @memberof AccountNumber
   */
  raw: string;
}
/**
 *
 * @export
 * @interface AllProductStatus
 */
export interface AllProductStatus {
  /**
   *
   * @type {ProductStatus}
   * @memberof AllProductStatus
   */
  accounts?: ProductStatus;
  /**
   *
   * @type {ProductStatus}
   * @memberof AllProductStatus
   */
  online_transactions?: ProductStatus;
  /**
   *
   * @type {ProductStatus}
   * @memberof AllProductStatus
   */
  statements?: ProductStatus;
  /**
   *
   * @type {ProductStatus}
   * @memberof AllProductStatus
   */
  historical_transactions?: ProductStatus;
  /**
   *
   * @type {ProductStatus}
   * @memberof AllProductStatus
   */
  account_numbers?: ProductStatus;
  /**
   *
   * @type {ProductStatus}
   * @memberof AllProductStatus
   */
  identity?: ProductStatus;
  /**
   *
   * @type {ProductStatus}
   * @memberof AllProductStatus
   */
  balance_history?: ProductStatus;
  /**
   *
   * @type {ProductStatus}
   * @memberof AllProductStatus
   */
  payments?: ProductStatus;
  /**
   *
   * @type {ProductStatus}
   * @memberof AllProductStatus
   */
  income_estimation?: ProductStatus;
}
/**
 *
 * @export
 * @interface BadRequestModel
 */
export interface BadRequestModel {
  /**
   *
   * @type {BadRequestModelError}
   * @memberof BadRequestModel
   */
  error?: BadRequestModelError;
}
/**
 *
 * @export
 * @interface BadRequestModelError
 */
export interface BadRequestModelError {
  /**
   *
   * @type {number}
   * @memberof BadRequestModelError
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof BadRequestModelError
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof BadRequestModelError
   */
  message?: string;
  /**
   * A link to visit for further action
   * @type {string}
   * @memberof BadRequestModelError
   */
  link?: string;
}
/**
 *
 * @export
 * @interface BalanceHistory
 */
export interface BalanceHistory {
  /**
   * The date the balance was recorded
   * @type {string}
   * @memberof BalanceHistory
   */
  date: string;
  /**
   * The end of day balance for this account on this specific date
   * @type {number}
   * @memberof BalanceHistory
   */
  amount: number;
  /**
   * The currency the balance
   * @type {string}
   * @memberof BalanceHistory
   */
  currency: string;
}
/**
 *
 * @export
 * @interface CompositeStatementLink
 */
export interface CompositeStatementLink {
  /**
   * signedURL to download statement
   * @type {string}
   * @memberof CompositeStatementLink
   */
  url: string;
  /**
   * expiry of the signedURL
   * @type {string}
   * @memberof CompositeStatementLink
   */
  expiry: string;
}
/**
 *
 * @export
 * @interface CreateCustomerRequest
 */
export interface CreateCustomerRequest {
  /**
   * The email of the customer. This has to be unique.
   * @type {string}
   * @memberof CreateCustomerRequest
   */
  name: string;
  /**
   * The email of the customer. This has to be unique.
   * @type {string}
   * @memberof CreateCustomerRequest
   */
  email: string;
  /**
   * Primary key to identity the customer
   * @type {string}
   * @memberof CreateCustomerRequest
   */
  customer_app_id: string;
  /**
   * The redirect callback
   * @type {Array<string>}
   * @memberof CreateCustomerRequest
   */
  redirect_uris: Array<string>;
  /**
   * The webhook uris
   * @type {Array<string>}
   * @memberof CreateCustomerRequest
   */
  webhook_uris?: Array<string>;
}
/**
 *
 * @export
 * @interface CreateCustomerResponse
 */
export interface CreateCustomerResponse {
  /**
   * The email of the customer. This has to be unique.
   * @type {string}
   * @memberof CreateCustomerResponse
   */
  name: string;
  /**
   * The email of the customer. This has to be unique.
   * @type {string}
   * @memberof CreateCustomerResponse
   */
  email: string;
  /**
   * Primary key to identity the customer
   * @type {string}
   * @memberof CreateCustomerResponse
   */
  customer_app_id: string;
  /**
   * The redirect callback
   * @type {Array<string>}
   * @memberof CreateCustomerResponse
   */
  redirect_uris: Array<string>;
  /**
   *
   * @type {string}
   * @memberof CreateCustomerResponse
   */
  client_id: string;
  /**
   *
   * @type {string}
   * @memberof CreateCustomerResponse
   */
  client_secret: string;
  /**
   * The webhook uris
   * @type {Array<string>}
   * @memberof CreateCustomerResponse
   */
  webhook_uris?: Array<string>;
}
/**
 *
 * @export
 * @interface CreatePaymentInstructionResponse
 */
export interface CreatePaymentInstructionResponse {
  /**
   *
   * @type {string}
   * @memberof CreatePaymentInstructionResponse
   */
  payment_instruction_id?: string;
}
/**
 *
 * @export
 * @interface CreatePaymentRequest
 */
export interface CreatePaymentRequest {
  /**
   * Amount to be paid, in currency’s smallest unit or “minor unit”, as defined in ISO 4217. For example, HKD 100.01 is represented as amount = 10001 (minor unit = cents). For currencies without minor units (e.g. VND, JPY), the amount is represented as is, without modification. For example, VND 15101 is represented as amount = 15101.
   * @type {number}
   * @memberof CreatePaymentRequest
   */
  amount: number;
  /**
   * Indicates whether this is a mandate-based payment or one-off direct payment to an account. Possible values - MANDATE, SINGLE
   * @type {string}
   * @memberof CreatePaymentRequest
   */
  type: CreatePaymentRequestTypeEnum;
  /**
   *
   * @type {PaymentDetails2}
   * @memberof CreatePaymentRequest
   */
  payment_details: PaymentDetails2;
}

export const CreatePaymentRequestTypeEnum = {
  Mandate: 'MANDATE',
  Single: 'SINGLE',
} as const;

export type CreatePaymentRequestTypeEnum =
  typeof CreatePaymentRequestTypeEnum[keyof typeof CreatePaymentRequestTypeEnum];

/**
 *
 * @export
 * @interface CreatePaymentResponse
 */
export interface CreatePaymentResponse {
  /**
   * Finverse Payment ID
   * @type {string}
   * @memberof CreatePaymentResponse
   */
  payment_id?: string;
}
/**
 *
 * @export
 * @interface CurrencyAmount
 */
export interface CurrencyAmount {
  /**
   *
   * @type {string}
   * @memberof CurrencyAmount
   */
  currency?: string;
  /**
   *
   * @type {number}
   * @memberof CurrencyAmount
   */
  value: number;
  /**
   *
   * @type {string}
   * @memberof CurrencyAmount
   */
  raw?: string;
}
/**
 *
 * @export
 * @interface CustomerPaymentInstruction
 */
export interface CustomerPaymentInstruction {
  /**
   * A id of the user of this payment, need to equal to userId when creating link
   * @type {string}
   * @memberof CustomerPaymentInstruction
   */
  user_id: string;
  /**
   * Type of payment is being created, please check Documentation on which payment type is supported in each institution
   * @type {string}
   * @memberof CustomerPaymentInstruction
   */
  type: CustomerPaymentInstructionTypeEnum;
  /**
   * The recipient name
   * @type {string}
   * @memberof CustomerPaymentInstruction
   */
  recipient_name?: string;
  /**
   * The recipient account Id
   * @type {string}
   * @memberof CustomerPaymentInstruction
   */
  recipient_account_id?: string;
  /**
   * The sender name
   * @type {string}
   * @memberof CustomerPaymentInstruction
   */
  sender_name?: string;
  /**
   * The sender account Id
   * @type {string}
   * @memberof CustomerPaymentInstruction
   */
  sender_account_id?: string;
  /**
   * When the payment should start
   * @type {string}
   * @memberof CustomerPaymentInstruction
   */
  start_date?: string | null;
  /**
   * When the payment should stop
   * @type {string}
   * @memberof CustomerPaymentInstruction
   */
  end_date?: string | null;
  /**
   * The currency for the payment
   * @type {string}
   * @memberof CustomerPaymentInstruction
   */
  currency?: string;
  /**
   * The payment amount
   * @type {number}
   * @memberof CustomerPaymentInstruction
   */
  amount?: number;
  /**
   * How often the payment should be executed
   * @type {string}
   * @memberof CustomerPaymentInstruction
   */
  frequency?: string;
  /**
   * Related remarks about this instruction
   * @type {string}
   * @memberof CustomerPaymentInstruction
   */
  remarks?: string;
}

export const CustomerPaymentInstructionTypeEnum = {
  DebitAuthorization: 'DEBIT_AUTHORIZATION',
} as const;

export type CustomerPaymentInstructionTypeEnum =
  typeof CustomerPaymentInstructionTypeEnum[keyof typeof CustomerPaymentInstructionTypeEnum];

/**
 *
 * @export
 * @interface CustomizationDetails
 */
export interface CustomizationDetails {
  /**
   *
   * @type {string}
   * @memberof CustomizationDetails
   */
  logo_id?: string;
  /**
   *
   * @type {string}
   * @memberof CustomizationDetails
   */
  display_name?: string;
}
/**
 *
 * @export
 * @interface DeleteInstitutionResponse
 */
export interface DeleteInstitutionResponse {
  /**
   *
   * @type {boolean}
   * @memberof DeleteInstitutionResponse
   */
  success?: boolean;
}
/**
 *
 * @export
 * @interface DeleteLoginIdentityResponse
 */
export interface DeleteLoginIdentityResponse {
  /**
   *
   * @type {boolean}
   * @memberof DeleteLoginIdentityResponse
   */
  success?: boolean;
}
/**
 *
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
  /**
   *
   * @type {string}
   * @memberof ErrorResponse
   */
  err?: string;
  /**
   *
   * @type {number}
   * @memberof ErrorResponse
   */
  http_status_code?: number;
  /**
   *
   * @type {string}
   * @memberof ErrorResponse
   */
  status_text?: string;
  /**
   *
   * @type {number}
   * @memberof ErrorResponse
   */
  app_code?: number;
  /**
   *
   * @type {string}
   * @memberof ErrorResponse
   */
  error_category?: string;
  /**
   *
   * @type {string}
   * @memberof ErrorResponse
   */
  error_text?: string;
  /**
   *
   * @type {string}
   * @memberof ErrorResponse
   */
  request_id?: string;
}
/**
 *
 * @export
 * @interface GetAccountNumberResponse
 */
export interface GetAccountNumberResponse {
  /**
   *
   * @type {AccountNumber}
   * @memberof GetAccountNumberResponse
   */
  account_number?: AccountNumber;
  /**
   *
   * @type {Account}
   * @memberof GetAccountNumberResponse
   */
  account?: Account;
  /**
   *
   * @type {LoginIdentityShort}
   * @memberof GetAccountNumberResponse
   */
  login_identity?: LoginIdentityShort;
  /**
   *
   * @type {InstitutionShort}
   * @memberof GetAccountNumberResponse
   */
  institution?: InstitutionShort;
  /**
   *
   * @type {Array<PaymentDetails>}
   * @memberof GetAccountNumberResponse
   */
  payment_details?: Array<PaymentDetails>;
}
/**
 *
 * @export
 * @interface GetAccountResponse
 */
export interface GetAccountResponse {
  /**
   *
   * @type {Account}
   * @memberof GetAccountResponse
   */
  account?: Account;
  /**
   *
   * @type {LoginIdentityShort}
   * @memberof GetAccountResponse
   */
  login_identity?: LoginIdentityShort;
  /**
   *
   * @type {InstitutionShort}
   * @memberof GetAccountResponse
   */
  institution?: InstitutionShort;
}
/**
 *
 * @export
 * @interface GetBalanceHistoryResponse
 */
export interface GetBalanceHistoryResponse {
  /**
   *
   * @type {Account}
   * @memberof GetBalanceHistoryResponse
   */
  account?: Account;
  /**
   *
   * @type {LoginIdentityShort}
   * @memberof GetBalanceHistoryResponse
   */
  login_identity?: LoginIdentityShort;
  /**
   *
   * @type {InstitutionShort}
   * @memberof GetBalanceHistoryResponse
   */
  institution?: InstitutionShort;
  /**
   *
   * @type {Array<BalanceHistory>}
   * @memberof GetBalanceHistoryResponse
   */
  balance_history?: Array<BalanceHistory>;
}
/**
 *
 * @export
 * @interface GetIdentityResponse
 */
export interface GetIdentityResponse {
  /**
   *
   * @type {Identity}
   * @memberof GetIdentityResponse
   */
  identity?: Identity;
  /**
   *
   * @type {LoginIdentityShort}
   * @memberof GetIdentityResponse
   */
  login_identity?: LoginIdentityShort;
  /**
   *
   * @type {InstitutionShort}
   * @memberof GetIdentityResponse
   */
  institution?: InstitutionShort;
}
/**
 *
 * @export
 * @interface GetLoginIdentityByIdResponse
 */
export interface GetLoginIdentityByIdResponse {
  /**
   *
   * @type {LoginIdentity}
   * @memberof GetLoginIdentityByIdResponse
   */
  login_identity?: LoginIdentity;
  /**
   *
   * @type {InstitutionShort}
   * @memberof GetLoginIdentityByIdResponse
   */
  institution?: InstitutionShort;
}
/**
 *
 * @export
 * @interface GetLoginIdentityHistoryResponse
 */
export interface GetLoginIdentityHistoryResponse {
  /**
   *
   * @type {LoginIdentity}
   * @memberof GetLoginIdentityHistoryResponse
   */
  login_identity?: LoginIdentity;
  /**
   *
   * @type {Array<LoginIdentityStatusDetails>}
   * @memberof GetLoginIdentityHistoryResponse
   */
  status_history?: Array<LoginIdentityStatusDetails>;
}
/**
 *
 * @export
 * @interface GetMandateSender
 */
export interface GetMandateSender {
  /**
   *
   * @type {string}
   * @memberof GetMandateSender
   */
  name?: string;
  /**
   * Customer App\'s user ID, representing the end-user making the payment.
   * @type {string}
   * @memberof GetMandateSender
   */
  user_id: string;
  /**
   * Customer App\'s reference ID, representing the sender\'s account or billing reference number.
   * @type {string}
   * @memberof GetMandateSender
   */
  sender_reference_id?: string;
  /**
   *
   * @type {PaymentAccount}
   * @memberof GetMandateSender
   */
  sender_account: PaymentAccount;
}
/**
 *
 * @export
 * @interface GetMandatesResponse
 */
export interface GetMandatesResponse {
  /**
   * Timestamp in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
   * @type {string}
   * @memberof GetMandatesResponse
   */
  last_update: string;
  /**
   * Finverse Mandate ID (ULID)
   * @type {string}
   * @memberof GetMandatesResponse
   */
  mandate_id: string;
  /**
   * Mandate status
   * @type {string}
   * @memberof GetMandatesResponse
   */
  mandate_status: GetMandatesResponseMandateStatusEnum;
  /**
   *
   * @type {MandateRecipient}
   * @memberof GetMandatesResponse
   */
  recipient: MandateRecipient;
  /**
   *
   * @type {GetMandateSender}
   * @memberof GetMandatesResponse
   */
  sender: GetMandateSender;
  /**
   *
   * @type {MandateDetails}
   * @memberof GetMandatesResponse
   */
  mandate_details: MandateDetails;
}

export const GetMandatesResponseMandateStatusEnum = {
  Created: 'CREATED',
  Used: 'USED',
  Submitted: 'SUBMITTED',
  Error: 'ERROR',
} as const;

export type GetMandatesResponseMandateStatusEnum =
  typeof GetMandatesResponseMandateStatusEnum[keyof typeof GetMandatesResponseMandateStatusEnum];

/**
 *
 * @export
 * @interface GetPaymentInstructionsResponse
 */
export interface GetPaymentInstructionsResponse {
  /**
   *
   * @type {PaymentInstruction}
   * @memberof GetPaymentInstructionsResponse
   */
  payment_instruction?: PaymentInstruction;
}
/**
 *
 * @export
 * @interface GetPaymentResponse
 */
export interface GetPaymentResponse {
  /**
   * Finverse Payment ID
   * @type {string}
   * @memberof GetPaymentResponse
   */
  payment_id?: string;
  /**
   * Amount to be paid, in currency’s smallest unit or “minor unit”, as defined in ISO 4217. For example, HKD 100.01 is represented as amount = 10001 (minor unit = cents). For currencies without minor units (e.g. VND, JPY), the amount is represented as is, without modification. For example, VND 15101 is represented as amount = 15101.
   * @type {number}
   * @memberof GetPaymentResponse
   */
  amount?: number;
  /**
   * Indicates whether this is a mandate-based payment or one-off direct payment to an account. Possible values - MANDATE, SINGLE
   * @type {string}
   * @memberof GetPaymentResponse
   */
  type?: GetPaymentResponseTypeEnum;
  /**
   * Possible values - CREATED, AUTHORIZED, SUBMITTED, EXECUTED, FAILED, REJECTED, CANCELLED.
   * @type {string}
   * @memberof GetPaymentResponse
   */
  status?: GetPaymentResponseStatusEnum;
  /**
   *
   * @type {PaymentDetails2}
   * @memberof GetPaymentResponse
   */
  payment_details?: PaymentDetails2;
}

export const GetPaymentResponseTypeEnum = {
  Mandate: 'MANDATE',
  Single: 'SINGLE',
} as const;

export type GetPaymentResponseTypeEnum = typeof GetPaymentResponseTypeEnum[keyof typeof GetPaymentResponseTypeEnum];
export const GetPaymentResponseStatusEnum = {
  Created: 'CREATED',
  Authorized: 'AUTHORIZED',
  Submitted: 'SUBMITTED',
  Executed: 'EXECUTED',
  Failed: 'FAILED',
  Rejected: 'REJECTED',
  Cancelled: 'CANCELLED',
} as const;

export type GetPaymentResponseStatusEnum =
  typeof GetPaymentResponseStatusEnum[keyof typeof GetPaymentResponseStatusEnum];

/**
 *
 * @export
 * @interface GetStatementLinkResponse
 */
export interface GetStatementLinkResponse {
  /**
   *
   * @type {Array<StatementLink>}
   * @memberof GetStatementLinkResponse
   */
  statement_links?: Array<StatementLink>;
}
/**
 *
 * @export
 * @interface GetStatementsResponse
 */
export interface GetStatementsResponse {
  /**
   *
   * @type {Array<Statement>}
   * @memberof GetStatementsResponse
   */
  statements?: Array<Statement>;
  /**
   *
   * @type {LoginIdentityShort}
   * @memberof GetStatementsResponse
   */
  login_identity?: LoginIdentityShort;
  /**
   *
   * @type {InstitutionShort}
   * @memberof GetStatementsResponse
   */
  institution?: InstitutionShort;
}
/**
 *
 * @export
 * @interface Identity
 */
export interface Identity {
  /**
   *
   * @type {Array<IdentityName>}
   * @memberof Identity
   */
  names?: Array<IdentityName>;
  /**
   *
   * @type {Array<IdentityAddress>}
   * @memberof Identity
   */
  addresses?: Array<IdentityAddress>;
  /**
   *
   * @type {Array<IdentityEmail>}
   * @memberof Identity
   */
  emails?: Array<IdentityEmail>;
  /**
   *
   * @type {Array<IdentityPhoneNumber>}
   * @memberof Identity
   */
  phone_numbers?: Array<IdentityPhoneNumber>;
  /**
   *
   * @type {Array<IdentityDateOfBirth>}
   * @memberof Identity
   */
  date_of_births?: Array<IdentityDateOfBirth>;
}
/**
 *
 * @export
 * @interface IdentityAddress
 */
export interface IdentityAddress {
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  raw?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  full_address?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  unit_number?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  floor_number?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  building_name?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  street_number?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  street_name?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  city?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  district?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  ward?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  street_address?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  province?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  country?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  postal_code?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  source?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof IdentityAddress
   */
  source_ids?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof IdentityAddress
   */
  account_ids?: Array<string>;
}
/**
 *
 * @export
 * @interface IdentityDateOfBirth
 */
export interface IdentityDateOfBirth {
  /**
   *
   * @type {string}
   * @memberof IdentityDateOfBirth
   */
  raw?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityDateOfBirth
   */
  date_of_birth?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityDateOfBirth
   */
  source?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof IdentityDateOfBirth
   */
  source_ids?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof IdentityDateOfBirth
   */
  account_ids?: Array<string>;
}
/**
 *
 * @export
 * @interface IdentityEmail
 */
export interface IdentityEmail {
  /**
   *
   * @type {string}
   * @memberof IdentityEmail
   */
  raw?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityEmail
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityEmail
   */
  masked_email?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityEmail
   */
  source?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof IdentityEmail
   */
  source_ids?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof IdentityEmail
   */
  account_ids?: Array<string>;
}
/**
 *
 * @export
 * @interface IdentityName
 */
export interface IdentityName {
  /**
   *
   * @type {string}
   * @memberof IdentityName
   */
  raw?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityName
   */
  full_name?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityName
   */
  first_name?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityName
   */
  last_name?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityName
   */
  other_name?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityName
   */
  source?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof IdentityName
   */
  source_ids?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof IdentityName
   */
  account_ids?: Array<string>;
}
/**
 *
 * @export
 * @interface IdentityPhoneNumber
 */
export interface IdentityPhoneNumber {
  /**
   *
   * @type {string}
   * @memberof IdentityPhoneNumber
   */
  raw?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityPhoneNumber
   */
  mobile_phone?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityPhoneNumber
   */
  other_phone?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityPhoneNumber
   */
  masked_phone?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityPhoneNumber
   */
  source?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof IdentityPhoneNumber
   */
  source_ids?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof IdentityPhoneNumber
   */
  account_ids?: Array<string>;
}
/**
 *
 * @export
 * @interface IncomeEstimate
 */
export interface IncomeEstimate {
  /**
   * Income amount
   * @type {number}
   * @memberof IncomeEstimate
   */
  amount: number;
  /**
   * Currency
   * @type {string}
   * @memberof IncomeEstimate
   */
  currency: string;
}
/**
 *
 * @export
 * @interface IncomeResponse
 */
export interface IncomeResponse {
  /**
   *
   * @type {Array<SingleSourceIncome>}
   * @memberof IncomeResponse
   */
  income: Array<SingleSourceIncome>;
  /**
   *
   * @type {LoginIdentityShort}
   * @memberof IncomeResponse
   */
  login_identity: LoginIdentityShort;
  /**
   *
   * @type {InstitutionShort}
   * @memberof IncomeResponse
   */
  institution: InstitutionShort;
}
/**
 *
 * @export
 * @interface IncomeStream
 */
export interface IncomeStream {
  /**
   * Account this income estimate is associated with
   * @type {string}
   * @memberof IncomeStream
   */
  account_id: string;
  /**
   *
   * @type {IncomeEstimate}
   * @memberof IncomeStream
   */
  estimated_monthly_income?: IncomeEstimate;
  /**
   * Number of transactions counted towards income
   * @type {number}
   * @memberof IncomeStream
   */
  transaction_count: number;
  /**
   *
   * @type {Array<MonthlyIncomeEstimate>}
   * @memberof IncomeStream
   */
  monthly_history: Array<MonthlyIncomeEstimate>;
}
/**
 *
 * @export
 * @interface IncomeTotal
 */
export interface IncomeTotal {
  /**
   *
   * @type {IncomeEstimate}
   * @memberof IncomeTotal
   */
  estimated_monthly_income?: IncomeEstimate;
  /**
   * Number of transactions counted towards income
   * @type {number}
   * @memberof IncomeTotal
   */
  transaction_count: number;
  /**
   *
   * @type {Array<MonthlyIncomeEstimate>}
   * @memberof IncomeTotal
   */
  monthly_history: Array<MonthlyIncomeEstimate>;
}
/**
 *
 * @export
 * @interface Institution
 */
export interface Institution {
  /**
   *
   * @type {string}
   * @memberof Institution
   */
  institution_id: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Institution
   */
  countries: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof Institution
   */
  tags?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof Institution
   */
  institution_type: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Institution
   */
  products_supported: Array<string>;
  /**
   *
   * @type {string}
   * @memberof Institution
   */
  parent_institution_name?: string;
  /**
   *
   * @type {string}
   * @memberof Institution
   */
  institution_name: string;
  /**
   *
   * @type {string}
   * @memberof Institution
   */
  portal_name?: string;
  /**
   *
   * @type {string}
   * @memberof Institution
   */
  user_type: string;
  /**
   *
   * @type {string}
   * @memberof Institution
   */
  status: string;
  /**
   *
   * @type {object}
   * @memberof Institution
   */
  status_details?: object;
  /**
   *
   * @type {string}
   * @memberof Institution
   */
  login_url?: string;
  /**
   *
   * @type {object}
   * @memberof Institution
   */
  login_details?: object;
  /**
   *
   * @type {Array<LoginMethod>}
   * @memberof Institution
   */
  login_methods?: Array<LoginMethod>;
  /**
   *
   * @type {string}
   * @memberof Institution
   */
  color?: string;
  /**
   *
   * @type {string}
   * @memberof Institution
   */
  updated_at?: string;
}
/**
 *
 * @export
 * @interface InstitutionShort
 */
export interface InstitutionShort {
  /**
   *
   * @type {string}
   * @memberof InstitutionShort
   */
  institution_id?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof InstitutionShort
   */
  countries?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof InstitutionShort
   */
  institution_name?: string;
  /**
   *
   * @type {string}
   * @memberof InstitutionShort
   */
  portal_name?: string;
}
/**
 *
 * @export
 * @interface LinkRequest
 */
export interface LinkRequest {
  /**
   *
   * @type {string}
   * @memberof LinkRequest
   */
  institution_id: string;
  /**
   *
   * @type {boolean}
   * @memberof LinkRequest
   */
  store_credential: boolean;
  /**
   * this is a mandatory field
   * @type {boolean}
   * @memberof LinkRequest
   */
  consent?: boolean | null;
  /**
   * products that is requested
   * @type {Array<string>}
   * @memberof LinkRequest
   */
  products_requested?: Array<string>;
  /**
   * The identifier returned after creating payment instruction
   * @type {string}
   * @memberof LinkRequest
   */
  payment_instruction_id?: string;
}
/**
 *
 * @export
 * @interface LinkResponse
 */
export interface LinkResponse {
  /**
   *
   * @type {string}
   * @memberof LinkResponse
   */
  auth_url?: string;
}
/**
 *
 * @export
 * @interface LinkTokenRequest
 */
export interface LinkTokenRequest {
  /**
   * support only client_credentials
   * @type {string}
   * @memberof LinkTokenRequest
   */
  grant_type: string;
  /**
   *
   * @type {string}
   * @memberof LinkTokenRequest
   */
  response_type: string;
  /**
   *
   * @type {string}
   * @memberof LinkTokenRequest
   */
  response_mode: string;
  /**
   * required when creating new Link, ignored when updating existing Link
   * @type {string}
   * @memberof LinkTokenRequest
   */
  user_id?: string;
  /**
   *
   * @type {string}
   * @memberof LinkTokenRequest
   */
  client_id: string;
  /**
   *
   * @type {string}
   * @memberof LinkTokenRequest
   */
  redirect_uri: string;
  /**
   *
   * @type {string}
   * @memberof LinkTokenRequest
   */
  state?: string;
  /**
   *
   * @type {string}
   * @memberof LinkTokenRequest
   */
  scope?: string;
  /**
   * Space separated list of the tags of the institutions to view.
   * @type {string}
   * @memberof LinkTokenRequest
   */
  link_mode?: string;
  /**
   * The UI mode link is intended to be used in - \"iframe\" (default), \"auto_redirect\" or \"redirect\" or \"standalone\"
   * @type {string}
   * @memberof LinkTokenRequest
   */
  ui_mode?: LinkTokenRequestUiModeEnum;
  /**
   * ISO639-1 language code. Language to display when user open the link, default to English (en) if not specified
   * @type {string}
   * @memberof LinkTokenRequest
   */
  language?: string;
  /**
   *
   * @type {string}
   * @memberof LinkTokenRequest
   */
  code_challenge?: string;
  /**
   *
   * @type {string}
   * @memberof LinkTokenRequest
   */
  code_challenge_method?: string;
  /**
   * use this to update a specific login identity
   * @type {string}
   * @memberof LinkTokenRequest
   */
  login_identity_id?: string;
  /**
   * The customization id if the customer wishes to embed it into link token for spawning link with their choice of stuffs
   * @type {string}
   * @memberof LinkTokenRequest
   */
  customization_id?: string;
  /**
   * Institution to preselect
   * @type {string}
   * @memberof LinkTokenRequest
   */
  institution_id?: string;
  /**
   * institution\'s country filter
   * @type {Array<string>}
   * @memberof LinkTokenRequest
   */
  countries?: Array<string>;
  /**
   * institution\'s supported user_type filter
   * @type {Array<string>}
   * @memberof LinkTokenRequest
   */
  user_type?: Array<string>;
  /**
   * institution\'s supported product filter
   * @type {Array<string>}
   * @memberof LinkTokenRequest
   */
  products_supported?: Array<string>;
  /**
   * products that is requested
   * @type {Array<string>}
   * @memberof LinkTokenRequest
   */
  products_requested?: Array<string>;
  /**
   * The identifier returned after creating payment instruction
   * @type {string}
   * @memberof LinkTokenRequest
   */
  payment_instruction_id?: string;
  /**
   * Controls the behavior of the automatic data refresh checkbox
   * @type {string}
   * @memberof LinkTokenRequest
   */
  automatic_data_refresh?: LinkTokenRequestAutomaticDataRefreshEnum;
  /**
   * institution\'s status filter
   * @type {string}
   * @memberof LinkTokenRequest
   */
  institution_status?: string;
}

export const LinkTokenRequestUiModeEnum = {
  Iframe: 'iframe',
  Redirect: 'redirect',
  AutoRedirect: 'auto_redirect',
  Standalone: 'standalone',
} as const;

export type LinkTokenRequestUiModeEnum = typeof LinkTokenRequestUiModeEnum[keyof typeof LinkTokenRequestUiModeEnum];
export const LinkTokenRequestAutomaticDataRefreshEnum = {
  On: 'ON',
  Off: 'OFF',
  ForcedOn: 'FORCED_ON',
} as const;

export type LinkTokenRequestAutomaticDataRefreshEnum =
  typeof LinkTokenRequestAutomaticDataRefreshEnum[keyof typeof LinkTokenRequestAutomaticDataRefreshEnum];

/**
 *
 * @export
 * @interface LinkTokenResponse
 */
export interface LinkTokenResponse {
  /**
   *
   * @type {string}
   * @memberof LinkTokenResponse
   */
  access_token: string;
  /**
   *
   * @type {string}
   * @memberof LinkTokenResponse
   */
  token_type: string;
  /**
   * seconds
   * @type {number}
   * @memberof LinkTokenResponse
   */
  expires_in: number;
  /**
   *
   * @type {string}
   * @memberof LinkTokenResponse
   */
  link_url: string;
}
/**
 *
 * @export
 * @interface ListAccountsResponse
 */
export interface ListAccountsResponse {
  /**
   *
   * @type {Array<Account>}
   * @memberof ListAccountsResponse
   */
  accounts?: Array<Account>;
  /**
   *
   * @type {LoginIdentityShort}
   * @memberof ListAccountsResponse
   */
  login_identity?: LoginIdentityShort;
  /**
   *
   * @type {InstitutionShort}
   * @memberof ListAccountsResponse
   */
  institution?: InstitutionShort;
}
/**
 *
 * @export
 * @interface ListTransactionsResponse
 */
export interface ListTransactionsResponse {
  /**
   *
   * @type {Array<Account>}
   * @memberof ListTransactionsResponse
   */
  accounts?: Array<Account>;
  /**
   *
   * @type {Array<Transaction>}
   * @memberof ListTransactionsResponse
   */
  transactions?: Array<Transaction>;
  /**
   *
   * @type {LoginIdentityShort}
   * @memberof ListTransactionsResponse
   */
  login_identity?: LoginIdentityShort;
  /**
   *
   * @type {InstitutionShort}
   * @memberof ListTransactionsResponse
   */
  institution?: InstitutionShort;
  /**
   *
   * @type {number}
   * @memberof ListTransactionsResponse
   */
  total_transactions: number;
}
/**
 *
 * @export
 * @interface LoginField
 */
export interface LoginField {
  /**
   *
   * @type {string}
   * @memberof LoginField
   */
  key?: string;
  /**
   *
   * @type {string}
   * @memberof LoginField
   */
  name?: string;
  /**
   * could be password, text, number
   * @type {string}
   * @memberof LoginField
   */
  type?: string;
}
/**
 *
 * @export
 * @interface LoginIdentity
 */
export interface LoginIdentity {
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  login_identity_id?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  customer_app_id: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  user_id: string;
  /**
   *
   * @type {LoginIdentityLoginMethodsAvailable}
   * @memberof LoginIdentity
   */
  login_methods_available?: LoginIdentityLoginMethodsAvailable;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  permissions_grant_date?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  permissions_expiry_date?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof LoginIdentity
   */
  permissions?: Array<string>;
  /**
   *
   * @type {LoginIdentityBillingDetails}
   * @memberof LoginIdentity
   */
  billing_details?: LoginIdentityBillingDetails;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  status?: string;
  /**
   *
   * @type {LoginIdentityStatusDetails}
   * @memberof LoginIdentity
   */
  status_details?: LoginIdentityStatusDetails;
  /**
   *
   * @type {AllProductStatus}
   * @memberof LoginIdentity
   */
  product_status?: AllProductStatus;
  /**
   *
   * @type {ProductStatus}
   * @memberof LoginIdentity
   */
  authentication_status?: ProductStatus;
  /**
   *
   * @type {LoginIdentityError}
   * @memberof LoginIdentity
   */
  error?: LoginIdentityError;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  last_success?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  first_success?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  webhook?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  session_status?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  institution_id: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  updated_at?: string;
  /**
   * a login attempt id which is unique per login_identity
   * @type {string}
   * @memberof LoginIdentity
   */
  linking_attempt_id?: string;
  /**
   * a successful login attempt id which is unique per login_identity
   * @type {string}
   * @memberof LoginIdentity
   */
  authentication_id?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  last_session_id?: string;
  /**
   *
   * @type {RefreshData}
   * @memberof LoginIdentity
   */
  refresh?: RefreshData;
}
/**
 *
 * @export
 * @interface LoginIdentityBillingDetails
 */
export interface LoginIdentityBillingDetails {
  /**
   *
   * @type {Array<string>}
   * @memberof LoginIdentityBillingDetails
   */
  billed_products?: Array<string>;
}
/**
 *
 * @export
 * @interface LoginIdentityError
 */
export interface LoginIdentityError {
  /**
   *
   * @type {number}
   * @memberof LoginIdentityError
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof LoginIdentityError
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentityError
   */
  message?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentityError
   */
  details?: string;
}
/**
 *
 * @export
 * @interface LoginIdentityLoginMethodsAvailable
 */
export interface LoginIdentityLoginMethodsAvailable {
  /**
   *
   * @type {boolean}
   * @memberof LoginIdentityLoginMethodsAvailable
   */
  havePassword?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof LoginIdentityLoginMethodsAvailable
   */
  haveSecret?: boolean;
}
/**
 *
 * @export
 * @interface LoginIdentityShort
 */
export interface LoginIdentityShort {
  /**
   *
   * @type {string}
   * @memberof LoginIdentityShort
   */
  login_identity_id?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentityShort
   */
  status?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentityShort
   */
  last_session_id?: string;
}
/**
 *
 * @export
 * @interface LoginIdentityStatusDetails
 */
export interface LoginIdentityStatusDetails {
  /**
   *
   * @type {string}
   * @memberof LoginIdentityStatusDetails
   */
  event_date?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentityStatusDetails
   */
  event_name?: string;
}
/**
 *
 * @export
 * @interface LoginMethod
 */
export interface LoginMethod {
  /**
   *
   * @type {string}
   * @memberof LoginMethod
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof LoginMethod
   */
  name?: string;
  /**
   *
   * @type {Array<LoginField>}
   * @memberof LoginMethod
   */
  login_fields?: Array<LoginField>;
}
/**
 *
 * @export
 * @interface MandateDetails
 */
export interface MandateDetails {
  /**
   * ISO currency code
   * @type {string}
   * @memberof MandateDetails
   */
  currency: string;
  /**
   * YYYY-MM-DD, must be later than or the same as the date of creation. If unspecified, default to the date of creation.
   * @type {string}
   * @memberof MandateDetails
   */
  start_date?: string;
  /**
   * YYYY-MM-DD, must be later than the date of creation.
   * @type {string}
   * @memberof MandateDetails
   */
  end_date?: string;
  /**
   *
   * @type {PaymentSchedule}
   * @memberof MandateDetails
   */
  payment_schedule?: PaymentSchedule;
  /**
   *
   * @type {TransactionLimits}
   * @memberof MandateDetails
   */
  transaction_limits?: TransactionLimits;
  /**
   * End-user facing description of the mandate (used in notifications, and in payments if no description is provided)
   * @type {string}
   * @memberof MandateDetails
   */
  description?: string;
}
/**
 *
 * @export
 * @interface MandateRecipient
 */
export interface MandateRecipient {
  /**
   * Merchant account ID assigned by Finverse
   * @type {string}
   * @memberof MandateRecipient
   */
  recipient_account_id: string;
}
/**
 *
 * @export
 * @interface MonthlyIncomeEstimate
 */
export interface MonthlyIncomeEstimate {
  /**
   *
   * @type {IncomeEstimate}
   * @memberof MonthlyIncomeEstimate
   */
  estimated_income: IncomeEstimate;
  /**
   * The numeric month
   * @type {number}
   * @memberof MonthlyIncomeEstimate
   */
  month: number;
  /**
   * The year
   * @type {number}
   * @memberof MonthlyIncomeEstimate
   */
  year: number;
}
/**
 *
 * @export
 * @interface OtherInfo
 */
export interface OtherInfo {
  /**
   *
   * @type {string}
   * @memberof OtherInfo
   */
  bank_code?: string;
}
/**
 *
 * @export
 * @interface PaymentAccount
 */
export interface PaymentAccount {
  /**
   * The raw value for the account the user selected when making payment request
   * @type {string}
   * @memberof PaymentAccount
   */
  raw?: string;
}
/**
 *
 * @export
 * @interface PaymentDetails
 */
export interface PaymentDetails {
  /**
   *
   * @type {string}
   * @memberof PaymentDetails
   */
  format?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentDetails
   */
  bic?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentDetails
   */
  bank_fullname?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentDetails
   */
  bank_shortname?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentDetails
   */
  bank_address?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentDetails
   */
  bank_country?: string;
  /**
   *
   * @type {OtherInfo}
   * @memberof PaymentDetails
   */
  other_info?: OtherInfo;
}
/**
 *
 * @export
 * @interface PaymentDetails2
 */
export interface PaymentDetails2 {
  /**
   * The transaction description provided to banks, which banks will show to their customers.
   * @type {string}
   * @memberof PaymentDetails2
   */
  description?: string;
  /**
   * ID of the mandate this pament is referring to.
   * @type {string}
   * @memberof PaymentDetails2
   */
  mandate_id: string;
  /**
   * Customer\'s ID for this transaction
   * @type {string}
   * @memberof PaymentDetails2
   */
  transaction_reference_id?: string;
}
/**
 *
 * @export
 * @interface PaymentInstruction
 */
export interface PaymentInstruction {
  /**
   * An id of the this payment
   * @type {string}
   * @memberof PaymentInstruction
   */
  payment_instruction_id?: string;
  /**
   * An id of the user of this payment, need to equal to userId when creating link
   * @type {string}
   * @memberof PaymentInstruction
   */
  user_id?: string;
  /**
   * An id that links this payment to a specific Login Identity
   * @type {string}
   * @memberof PaymentInstruction
   */
  login_identity_id?: string;
  /**
   * Type of payment that was created, please check Documentation on which payment type is supported in each institution
   * @type {string}
   * @memberof PaymentInstruction
   */
  type?: PaymentInstructionTypeEnum;
  /**
   * The recipient name
   * @type {string}
   * @memberof PaymentInstruction
   */
  recipient_name?: string;
  /**
   * The recipient account Id
   * @type {string}
   * @memberof PaymentInstruction
   */
  recipient_account_id?: string;
  /**
   * The sender name
   * @type {string}
   * @memberof PaymentInstruction
   */
  sender_name?: string;
  /**
   *
   * @type {PaymentAccount}
   * @memberof PaymentInstruction
   */
  sender_account?: PaymentAccount;
  /**
   * The sender account Id
   * @type {string}
   * @memberof PaymentInstruction
   */
  sender_account_id?: string;
  /**
   * When the payment should start
   * @type {string}
   * @memberof PaymentInstruction
   */
  start_date?: string | null;
  /**
   * When the payment should stop
   * @type {string}
   * @memberof PaymentInstruction
   */
  end_date?: string | null;
  /**
   * The currency for the payment
   * @type {string}
   * @memberof PaymentInstruction
   */
  currency?: string;
  /**
   * The payment amount
   * @type {number}
   * @memberof PaymentInstruction
   */
  amount?: number;
  /**
   * How often the payment should be executed
   * @type {string}
   * @memberof PaymentInstruction
   */
  frequency?: string;
  /**
   * Related remarks about this instruction
   * @type {string}
   * @memberof PaymentInstruction
   */
  remarks?: string;
  /**
   * Status of the payment
   * @type {string}
   * @memberof PaymentInstruction
   */
  status?: string;
  /**
   * Reference identification returned by institution
   * @type {string}
   * @memberof PaymentInstruction
   */
  reference_id?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentInstruction
   */
  last_update?: string;
  /**
   * Extra information collected for this payment instruction
   * @type {object}
   * @memberof PaymentInstruction
   */
  info?: object;
}

export const PaymentInstructionTypeEnum = {
  DebitAuthorization: 'DEBIT_AUTHORIZATION',
} as const;

export type PaymentInstructionTypeEnum = typeof PaymentInstructionTypeEnum[keyof typeof PaymentInstructionTypeEnum];

/**
 *
 * @export
 * @interface PaymentSchedule
 */
export interface PaymentSchedule {
  /**
   * Amount to be paid, in currency’s smallest unit or “minor unit”, as defined in ISO 4217. For example, HKD 100.01 is represented as amount = 10001 (minor unit = cents). For currencies without minor units (e.g. VND, JPY), the amount is represented as is, without modification. For example, VND 15101 is represented as amount = 15101.
   * @type {number}
   * @memberof PaymentSchedule
   */
  amount: number;
  /**
   * Frequency of the payment. Possible values (DAILY, WEEKLY, MONTHLY, QUARTERLY, YEARLY)
   * @type {string}
   * @memberof PaymentSchedule
   */
  frequency: PaymentScheduleFrequencyEnum;
}

export const PaymentScheduleFrequencyEnum = {
  Daily: 'DAILY',
  Weekly: 'WEEKLY',
  Monthly: 'MONTHLY',
  Quarterly: 'QUARTERLY',
  Yearly: 'YEARLY',
} as const;

export type PaymentScheduleFrequencyEnum =
  typeof PaymentScheduleFrequencyEnum[keyof typeof PaymentScheduleFrequencyEnum];

/**
 *
 * @export
 * @interface PostMandateSender
 */
export interface PostMandateSender {
  /**
   *
   * @type {string}
   * @memberof PostMandateSender
   */
  name?: string;
  /**
   * Customer App\'s user ID, representing the end-user making the payment.
   * @type {string}
   * @memberof PostMandateSender
   */
  user_id: string;
  /**
   * Customer App\'s reference ID, representing the sender\'s account or billing reference number.
   * @type {string}
   * @memberof PostMandateSender
   */
  sender_reference_id?: string;
}
/**
 *
 * @export
 * @interface PostMandatesRequest
 */
export interface PostMandatesRequest {
  /**
   *
   * @type {MandateRecipient}
   * @memberof PostMandatesRequest
   */
  recipient: MandateRecipient;
  /**
   *
   * @type {PostMandateSender}
   * @memberof PostMandatesRequest
   */
  sender: PostMandateSender;
  /**
   *
   * @type {MandateDetails}
   * @memberof PostMandatesRequest
   */
  mandate_details: MandateDetails;
}
/**
 *
 * @export
 * @interface PostMandatesResponse
 */
export interface PostMandatesResponse {
  /**
   * Finverse Mandate ID
   * @type {string}
   * @memberof PostMandatesResponse
   */
  mandate_id?: string;
}
/**
 *
 * @export
 * @interface Principal
 */
export interface Principal {
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  subject: string;
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  token?: string;
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  client_id: string;
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  customer_app_id: string;
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  login_identity_id: string;
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  customization_id?: string;
  /**
   *
   * @type {number}
   * @memberof Principal
   */
  expires_in?: number;
  /**
   *
   * @type {Array<string>}
   * @memberof Principal
   */
  scopes?: Array<string>;
  /**
   *
   * @type {LinkTokenRequest}
   * @memberof Principal
   */
  link_token_request?: LinkTokenRequest;
}
/**
 *
 * @export
 * @interface ProductStatus
 */
export interface ProductStatus {
  /**
   * The current health of this product
   * @type {string}
   * @memberof ProductStatus
   */
  status?: string;
  /**
   * The detailed event name
   * @type {string}
   * @memberof ProductStatus
   */
  status_details?: string;
  /**
   *
   * @type {string}
   * @memberof ProductStatus
   */
  last_update?: string | null;
  /**
   *
   * @type {string}
   * @memberof ProductStatus
   */
  last_successful_update?: string | null;
}
/**
 *
 * @export
 * @interface RedirectUriResponse
 */
export interface RedirectUriResponse {
  /**
   *
   * @type {string}
   * @memberof RedirectUriResponse
   */
  redirect_uri?: string;
}
/**
 *
 * @export
 * @interface RefreshData
 */
export interface RefreshData {
  /**
   *
   * @type {boolean}
   * @memberof RefreshData
   */
  credentials_stored: boolean;
  /**
   *
   * @type {boolean}
   * @memberof RefreshData
   */
  refresh_allowed: boolean;
}
/**
 *
 * @export
 * @interface RefreshRequest
 */
export interface RefreshRequest {
  /**
   *
   * @type {string}
   * @memberof RefreshRequest
   */
  refresh_token: string;
}
/**
 *
 * @export
 * @interface RelinkRequest
 */
export interface RelinkRequest {
  /**
   *
   * @type {boolean}
   * @memberof RelinkRequest
   */
  store_credential: boolean;
  /**
   * this is a mandatory field
   * @type {boolean}
   * @memberof RelinkRequest
   */
  consent?: boolean | null;
}
/**
 *
 * @export
 * @interface SingleSourceIncome
 */
export interface SingleSourceIncome {
  /**
   *
   * @type {Array<IncomeStream>}
   * @memberof SingleSourceIncome
   */
  income_streams: Array<IncomeStream>;
  /**
   *
   * @type {IncomeTotal}
   * @memberof SingleSourceIncome
   */
  income_total: IncomeTotal;
  /**
   * Where the income estimate was sourced from
   * @type {string}
   * @memberof SingleSourceIncome
   */
  source: string;
  /**
   * Unknown
   * @type {string}
   * @memberof SingleSourceIncome
   */
  source_id: string;
}
/**
 *
 * @export
 * @interface Statement
 */
export interface Statement {
  /**
   *
   * @type {string}
   * @memberof Statement
   */
  id?: string;
  /**
   * YYYY-MM-DD
   * @type {string}
   * @memberof Statement
   */
  date?: string;
  /**
   *
   * @type {string}
   * @memberof Statement
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof Statement
   */
  created_at?: string;
}
/**
 *
 * @export
 * @interface StatementLink
 */
export interface StatementLink {
  /**
   * signedURL to download statement
   * @type {string}
   * @memberof StatementLink
   */
  url?: string;
  /**
   * expiry of the signedURL
   * @type {string}
   * @memberof StatementLink
   */
  expiry?: string;
  /**
   *
   * @type {string}
   * @memberof StatementLink
   */
  statement_id?: string;
}
/**
 *
 * @export
 * @interface TokenRequest
 */
export interface TokenRequest {
  /**
   *
   * @type {string}
   * @memberof TokenRequest
   */
  client_id: string;
  /**
   *
   * @type {string}
   * @memberof TokenRequest
   */
  client_secret: string;
  /**
   * support only client_credentials
   * @type {string}
   * @memberof TokenRequest
   */
  grant_type: string;
}
/**
 *
 * @export
 * @interface TokenResponse
 */
export interface TokenResponse {
  /**
   *
   * @type {string}
   * @memberof TokenResponse
   */
  access_token: string;
  /**
   *
   * @type {string}
   * @memberof TokenResponse
   */
  token_type: string;
  /**
   * seconds
   * @type {number}
   * @memberof TokenResponse
   */
  expires_in: number;
}
/**
 *
 * @export
 * @interface Transaction
 */
export interface Transaction {
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  transaction_id?: string;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  account_id?: string;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  transaction_state?: string;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  transaction_type?: string;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  category?: string;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  category_id?: string;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  merchant_name?: string;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  location?: string;
  /**
   *
   * @type {boolean}
   * @memberof Transaction
   */
  is_pending: boolean;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  status?: string;
  /**
   * YYYY-MM-DD
   * @type {string}
   * @memberof Transaction
   */
  posted_date?: string;
  /**
   * YYYY-MM-DD
   * @type {string}
   * @memberof Transaction
   */
  transaction_date?: string;
  /**
   *
   * @type {CurrencyAmount}
   * @memberof Transaction
   */
  amount?: CurrencyAmount;
  /**
   *
   * @type {object}
   * @memberof Transaction
   */
  transfer_details?: object;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  updated_at?: string;
}
/**
 *
 * @export
 * @interface TransactionLimits
 */
export interface TransactionLimits {
  /**
   * Maximum amount of money that can be paid during the reference period (across any number of transactions). Expressed in currency’s smallest unit or “minor unit”, as defined in ISO 4217.
   * @type {number}
   * @memberof TransactionLimits
   */
  max_period_amount?: number;
  /**
   * Maximum number of transactions (of any amount) that can be executed during the reference period.
   * @type {number}
   * @memberof TransactionLimits
   */
  max_period_count?: number;
  /**
   * The maximum amount of money that can be transferred in a single transaction under this mandate. Expressed in currency’s smallest unit or “minor unit”, as defined in ISO 4217.
   * @type {number}
   * @memberof TransactionLimits
   */
  max_transaction_amount?: number;
  /**
   * Reference calendar periods for the payment limits. Possible values (DAILY, WEEKLY, MONTHLY, QUARTERLY, YEARLY)
   * @type {string}
   * @memberof TransactionLimits
   */
  period: TransactionLimitsPeriodEnum;
}

export const TransactionLimitsPeriodEnum = {
  Daily: 'DAILY',
  Weekly: 'WEEKLY',
  Monthly: 'MONTHLY',
  Quarterly: 'QUARTERLY',
  Yearly: 'YEARLY',
} as const;

export type TransactionLimitsPeriodEnum = typeof TransactionLimitsPeriodEnum[keyof typeof TransactionLimitsPeriodEnum];

/**
 * CustomerApi - axios parameter creator
 * @export
 */
export const CustomerApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create new Payment
     * @param {CreatePaymentRequest} createPaymentRequest request body for creating payment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPayment: async (
      createPaymentRequest: CreatePaymentRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createPaymentRequest' is not null or undefined
      assertParamExists('createPayment', 'createPaymentRequest', createPaymentRequest);
      const localVarPath = `/payments`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(createPaymentRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a new payment instruction to be used when linking to perform new payment
     * @param {CustomerPaymentInstruction} paymentInstruction Request body for starting a new Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentInstruction: async (
      paymentInstruction: CustomerPaymentInstruction,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'paymentInstruction' is not null or undefined
      assertParamExists('createPaymentInstruction', 'paymentInstruction', paymentInstruction);
      const localVarPath = `/payments/instruction`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(paymentInstruction, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * generate a link token that can be used to create link
     * @param {LinkTokenRequest} linkTokenRequest token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateLinkToken: async (
      linkTokenRequest: LinkTokenRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'linkTokenRequest' is not null or undefined
      assertParamExists('generateLinkToken', 'linkTokenRequest', linkTokenRequest);
      const localVarPath = `/link/token`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(linkTokenRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a specific institution by institutionId
     * @param {string} institutionId The institution id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInstitution: async (institutionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'institutionId' is not null or undefined
      assertParamExists('getInstitution', 'institutionId', institutionId);
      const localVarPath = `/institutions/{institutionId}`.replace(
        `{${'institutionId'}}`,
        encodeURIComponent(String(institutionId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', ['institution'], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a specific loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoginIdentityById: async (loginIdentityId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'loginIdentityId' is not null or undefined
      assertParamExists('getLoginIdentityById', 'loginIdentityId', loginIdentityId);
      const localVarPath = `/login_identity/{loginIdentityId}`.replace(
        `{${'loginIdentityId'}}`,
        encodeURIComponent(String(loginIdentityId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a history of events for a specific loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoginIdentityHistory: async (
      loginIdentityId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'loginIdentityId' is not null or undefined
      assertParamExists('getLoginIdentityHistory', 'loginIdentityId', loginIdentityId);
      const localVarPath = `/login_identity/{loginIdentityId}/history`.replace(
        `{${'loginIdentityId'}}`,
        encodeURIComponent(String(loginIdentityId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get Mandates details by mandate_id
     * @param {string} mandateId mandate id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMandates: async (mandateId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'mandateId' is not null or undefined
      assertParamExists('getMandates', 'mandateId', mandateId);
      const localVarPath = `/mandates/{mandateId}`.replace(`{${'mandateId'}}`, encodeURIComponent(String(mandateId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get Payment details by payment_id
     * @param {string} paymentId payment id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPayment: async (paymentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'paymentId' is not null or undefined
      assertParamExists('getPayment', 'paymentId', paymentId);
      const localVarPath = `/payments/{paymentId}`.replace(`{${'paymentId'}}`, encodeURIComponent(String(paymentId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get payment instructions by payment_instruction_id
     * @param {string} paymentInstructionId The id of a payment instruction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentInstruction: async (
      paymentInstructionId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'paymentInstructionId' is not null or undefined
      assertParamExists('getPaymentInstruction', 'paymentInstructionId', paymentInstructionId);
      const localVarPath = `/payments/instruction/{paymentInstructionId}`.replace(
        `{${'paymentInstructionId'}}`,
        encodeURIComponent(String(paymentInstructionId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of institutions
     * @param {string} [country] The country the institution belongs to
     * @param {Array<string>} [countries] The countries the institution belongs to
     * @param {string} [productsSupported] The products that this institution supports
     * @param {string} [institutionType] The type of institution
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listInstitutions: async (
      country?: string,
      countries?: Array<string>,
      productsSupported?: string,
      institutionType?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/institutions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', ['institution'], configuration);

      if (country !== undefined) {
        localVarQueryParameter['country'] = country;
      }

      if (countries) {
        localVarQueryParameter['countries'] = countries.join(COLLECTION_FORMATS.csv);
      }

      if (productsSupported !== undefined) {
        localVarQueryParameter['products_supported'] = productsSupported;
      }

      if (institutionType !== undefined) {
        localVarQueryParameter['institution_type'] = institutionType;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * CREATE Mandates
     * @param {PostMandatesRequest} postMandatesRequest request body for creating mandate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postMandates: async (
      postMandatesRequest: PostMandatesRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'postMandatesRequest' is not null or undefined
      assertParamExists('postMandates', 'postMandatesRequest', postMandatesRequest);
      const localVarPath = `/mandates`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(postMandatesRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Refresh an access token
     * @param {RefreshRequest} refreshRequest The refresh token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshToken: async (refreshRequest: RefreshRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'refreshRequest' is not null or undefined
      assertParamExists('refreshToken', 'refreshRequest', refreshRequest);
      const localVarPath = `/auth/token/refresh`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(refreshRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CustomerApi - functional programming interface
 * @export
 */
export const CustomerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = CustomerApiAxiosParamCreator(configuration);
  return {
    /**
     * Create new Payment
     * @param {CreatePaymentRequest} createPaymentRequest request body for creating payment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPayment(
      createPaymentRequest: CreatePaymentRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePaymentResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createPayment(createPaymentRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Create a new payment instruction to be used when linking to perform new payment
     * @param {CustomerPaymentInstruction} paymentInstruction Request body for starting a new Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPaymentInstruction(
      paymentInstruction: CustomerPaymentInstruction,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePaymentInstructionResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createPaymentInstruction(paymentInstruction, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * generate a link token that can be used to create link
     * @param {LinkTokenRequest} linkTokenRequest token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async generateLinkToken(
      linkTokenRequest: LinkTokenRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkTokenResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.generateLinkToken(linkTokenRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get a specific institution by institutionId
     * @param {string} institutionId The institution id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getInstitution(
      institutionId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Institution>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getInstitution(institutionId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get a specific loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLoginIdentityById(
      loginIdentityId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLoginIdentityByIdResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLoginIdentityById(loginIdentityId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get a history of events for a specific loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLoginIdentityHistory(
      loginIdentityId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLoginIdentityHistoryResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLoginIdentityHistory(loginIdentityId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get Mandates details by mandate_id
     * @param {string} mandateId mandate id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMandates(
      mandateId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMandatesResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMandates(mandateId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get Payment details by payment_id
     * @param {string} paymentId payment id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPayment(
      paymentId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPaymentResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPayment(paymentId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get payment instructions by payment_instruction_id
     * @param {string} paymentInstructionId The id of a payment instruction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPaymentInstruction(
      paymentInstructionId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPaymentInstructionsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentInstruction(paymentInstructionId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get a list of institutions
     * @param {string} [country] The country the institution belongs to
     * @param {Array<string>} [countries] The countries the institution belongs to
     * @param {string} [productsSupported] The products that this institution supports
     * @param {string} [institutionType] The type of institution
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listInstitutions(
      country?: string,
      countries?: Array<string>,
      productsSupported?: string,
      institutionType?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Institution>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listInstitutions(
        country,
        countries,
        productsSupported,
        institutionType,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * CREATE Mandates
     * @param {PostMandatesRequest} postMandatesRequest request body for creating mandate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postMandates(
      postMandatesRequest: PostMandatesRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostMandatesResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postMandates(postMandatesRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Refresh an access token
     * @param {RefreshRequest} refreshRequest The refresh token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async refreshToken(
      refreshRequest: RefreshRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessTokenResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(refreshRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * CustomerApi - factory interface
 * @export
 */
export const CustomerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = CustomerApiFp(configuration);
  return {
    /**
     * Create new Payment
     * @param {CreatePaymentRequest} createPaymentRequest request body for creating payment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPayment(createPaymentRequest: CreatePaymentRequest, options?: any): AxiosPromise<CreatePaymentResponse> {
      return localVarFp.createPayment(createPaymentRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Create a new payment instruction to be used when linking to perform new payment
     * @param {CustomerPaymentInstruction} paymentInstruction Request body for starting a new Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentInstruction(
      paymentInstruction: CustomerPaymentInstruction,
      options?: any,
    ): AxiosPromise<CreatePaymentInstructionResponse> {
      return localVarFp
        .createPaymentInstruction(paymentInstruction, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * generate a link token that can be used to create link
     * @param {LinkTokenRequest} linkTokenRequest token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateLinkToken(linkTokenRequest: LinkTokenRequest, options?: any): AxiosPromise<LinkTokenResponse> {
      return localVarFp.generateLinkToken(linkTokenRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Get a specific institution by institutionId
     * @param {string} institutionId The institution id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInstitution(institutionId: string, options?: any): AxiosPromise<Institution> {
      return localVarFp.getInstitution(institutionId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get a specific loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoginIdentityById(loginIdentityId: string, options?: any): AxiosPromise<GetLoginIdentityByIdResponse> {
      return localVarFp.getLoginIdentityById(loginIdentityId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get a history of events for a specific loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoginIdentityHistory(loginIdentityId: string, options?: any): AxiosPromise<GetLoginIdentityHistoryResponse> {
      return localVarFp.getLoginIdentityHistory(loginIdentityId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get Mandates details by mandate_id
     * @param {string} mandateId mandate id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMandates(mandateId: string, options?: any): AxiosPromise<GetMandatesResponse> {
      return localVarFp.getMandates(mandateId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get Payment details by payment_id
     * @param {string} paymentId payment id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPayment(paymentId: string, options?: any): AxiosPromise<GetPaymentResponse> {
      return localVarFp.getPayment(paymentId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get payment instructions by payment_instruction_id
     * @param {string} paymentInstructionId The id of a payment instruction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentInstruction(paymentInstructionId: string, options?: any): AxiosPromise<GetPaymentInstructionsResponse> {
      return localVarFp
        .getPaymentInstruction(paymentInstructionId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a list of institutions
     * @param {string} [country] The country the institution belongs to
     * @param {Array<string>} [countries] The countries the institution belongs to
     * @param {string} [productsSupported] The products that this institution supports
     * @param {string} [institutionType] The type of institution
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listInstitutions(
      country?: string,
      countries?: Array<string>,
      productsSupported?: string,
      institutionType?: string,
      options?: any,
    ): AxiosPromise<Array<Institution>> {
      return localVarFp
        .listInstitutions(country, countries, productsSupported, institutionType, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * CREATE Mandates
     * @param {PostMandatesRequest} postMandatesRequest request body for creating mandate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postMandates(postMandatesRequest: PostMandatesRequest, options?: any): AxiosPromise<PostMandatesResponse> {
      return localVarFp.postMandates(postMandatesRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Refresh an access token
     * @param {RefreshRequest} refreshRequest The refresh token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshToken(refreshRequest: RefreshRequest, options?: any): AxiosPromise<AccessTokenResponse> {
      return localVarFp.refreshToken(refreshRequest, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * CustomerApi - interface
 * @export
 * @interface CustomerApi
 */
export interface CustomerApiInterface {
  /**
   * Create new Payment
   * @param {CreatePaymentRequest} createPaymentRequest request body for creating payment
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  createPayment(
    createPaymentRequest: CreatePaymentRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<CreatePaymentResponse>;

  /**
   * Create a new payment instruction to be used when linking to perform new payment
   * @param {CustomerPaymentInstruction} paymentInstruction Request body for starting a new Link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  createPaymentInstruction(
    paymentInstruction: CustomerPaymentInstruction,
    options?: AxiosRequestConfig,
  ): AxiosPromise<CreatePaymentInstructionResponse>;

  /**
   * generate a link token that can be used to create link
   * @param {LinkTokenRequest} linkTokenRequest token request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  generateLinkToken(linkTokenRequest: LinkTokenRequest, options?: AxiosRequestConfig): AxiosPromise<LinkTokenResponse>;

  /**
   * Get a specific institution by institutionId
   * @param {string} institutionId The institution id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  getInstitution(institutionId: string, options?: AxiosRequestConfig): AxiosPromise<Institution>;

  /**
   * Get a specific loginIdentity
   * @param {string} loginIdentityId The login identity id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  getLoginIdentityById(
    loginIdentityId: string,
    options?: AxiosRequestConfig,
  ): AxiosPromise<GetLoginIdentityByIdResponse>;

  /**
   * Get a history of events for a specific loginIdentity
   * @param {string} loginIdentityId The login identity id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  getLoginIdentityHistory(
    loginIdentityId: string,
    options?: AxiosRequestConfig,
  ): AxiosPromise<GetLoginIdentityHistoryResponse>;

  /**
   * Get Mandates details by mandate_id
   * @param {string} mandateId mandate id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  getMandates(mandateId: string, options?: AxiosRequestConfig): AxiosPromise<GetMandatesResponse>;

  /**
   * Get Payment details by payment_id
   * @param {string} paymentId payment id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  getPayment(paymentId: string, options?: AxiosRequestConfig): AxiosPromise<GetPaymentResponse>;

  /**
   * Get payment instructions by payment_instruction_id
   * @param {string} paymentInstructionId The id of a payment instruction
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  getPaymentInstruction(
    paymentInstructionId: string,
    options?: AxiosRequestConfig,
  ): AxiosPromise<GetPaymentInstructionsResponse>;

  /**
   * Get a list of institutions
   * @param {string} [country] The country the institution belongs to
   * @param {Array<string>} [countries] The countries the institution belongs to
   * @param {string} [productsSupported] The products that this institution supports
   * @param {string} [institutionType] The type of institution
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  listInstitutions(
    country?: string,
    countries?: Array<string>,
    productsSupported?: string,
    institutionType?: string,
    options?: AxiosRequestConfig,
  ): AxiosPromise<Array<Institution>>;

  /**
   * CREATE Mandates
   * @param {PostMandatesRequest} postMandatesRequest request body for creating mandate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  postMandates(
    postMandatesRequest: PostMandatesRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<PostMandatesResponse>;

  /**
   * Refresh an access token
   * @param {RefreshRequest} refreshRequest The refresh token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  refreshToken(refreshRequest: RefreshRequest, options?: AxiosRequestConfig): AxiosPromise<AccessTokenResponse>;
}

/**
 * CustomerApi - object-oriented interface
 * @export
 * @class CustomerApi
 * @extends {BaseAPI}
 */
export class CustomerApi extends BaseAPI implements CustomerApiInterface {
  /**
   * Create new Payment
   * @param {CreatePaymentRequest} createPaymentRequest request body for creating payment
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public createPayment(createPaymentRequest: CreatePaymentRequest, options?: AxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .createPayment(createPaymentRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a new payment instruction to be used when linking to perform new payment
   * @param {CustomerPaymentInstruction} paymentInstruction Request body for starting a new Link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public createPaymentInstruction(paymentInstruction: CustomerPaymentInstruction, options?: AxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .createPaymentInstruction(paymentInstruction, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * generate a link token that can be used to create link
   * @param {LinkTokenRequest} linkTokenRequest token request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public generateLinkToken(linkTokenRequest: LinkTokenRequest, options?: AxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .generateLinkToken(linkTokenRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a specific institution by institutionId
   * @param {string} institutionId The institution id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public getInstitution(institutionId: string, options?: AxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .getInstitution(institutionId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a specific loginIdentity
   * @param {string} loginIdentityId The login identity id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public getLoginIdentityById(loginIdentityId: string, options?: AxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .getLoginIdentityById(loginIdentityId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a history of events for a specific loginIdentity
   * @param {string} loginIdentityId The login identity id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public getLoginIdentityHistory(loginIdentityId: string, options?: AxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .getLoginIdentityHistory(loginIdentityId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get Mandates details by mandate_id
   * @param {string} mandateId mandate id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public getMandates(mandateId: string, options?: AxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .getMandates(mandateId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get Payment details by payment_id
   * @param {string} paymentId payment id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public getPayment(paymentId: string, options?: AxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .getPayment(paymentId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get payment instructions by payment_instruction_id
   * @param {string} paymentInstructionId The id of a payment instruction
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public getPaymentInstruction(paymentInstructionId: string, options?: AxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .getPaymentInstruction(paymentInstructionId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of institutions
   * @param {string} [country] The country the institution belongs to
   * @param {Array<string>} [countries] The countries the institution belongs to
   * @param {string} [productsSupported] The products that this institution supports
   * @param {string} [institutionType] The type of institution
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public listInstitutions(
    country?: string,
    countries?: Array<string>,
    productsSupported?: string,
    institutionType?: string,
    options?: AxiosRequestConfig,
  ) {
    return CustomerApiFp(this.configuration)
      .listInstitutions(country, countries, productsSupported, institutionType, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * CREATE Mandates
   * @param {PostMandatesRequest} postMandatesRequest request body for creating mandate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public postMandates(postMandatesRequest: PostMandatesRequest, options?: AxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .postMandates(postMandatesRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Refresh an access token
   * @param {RefreshRequest} refreshRequest The refresh token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public refreshToken(refreshRequest: RefreshRequest, options?: AxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .refreshToken(refreshRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * LinkApi - axios parameter creator
 * @export
 */
export const LinkApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Creates a new link
     * @param {LinkRequest} linkRequest Request body for starting a new Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLink: async (linkRequest: LinkRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'linkRequest' is not null or undefined
      assertParamExists('createLink', 'linkRequest', linkRequest);
      const localVarPath = `/link`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', ['link'], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(linkRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the customization details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCustomization: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/customer/customizations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', ['link'], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of institutions
     * @param {string} [country] The country the institution belongs to
     * @param {Array<string>} [countries] The countries the institution belongs to
     * @param {string} [productsSupported] The products that this institution supports
     * @param {string} [institutionType] The type of institution
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listInstitutions: async (
      country?: string,
      countries?: Array<string>,
      productsSupported?: string,
      institutionType?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/institutions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', ['institution'], configuration);

      if (country !== undefined) {
        localVarQueryParameter['country'] = country;
      }

      if (countries) {
        localVarQueryParameter['countries'] = countries.join(COLLECTION_FORMATS.csv);
      }

      if (productsSupported !== undefined) {
        localVarQueryParameter['products_supported'] = productsSupported;
      }

      if (institutionType !== undefined) {
        localVarQueryParameter['institution_type'] = institutionType;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update an existing link
     * @param {RelinkRequest} relinkRequest Request body for updating Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    relink: async (relinkRequest: RelinkRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'relinkRequest' is not null or undefined
      assertParamExists('relink', 'relinkRequest', relinkRequest);
      const localVarPath = `/link/relink`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(relinkRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Exchange authorization code for token
     * @param {string} grantType
     * @param {string} code
     * @param {string} clientId
     * @param {string} redirectUri
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    token: async (
      grantType: string,
      code: string,
      clientId: string,
      redirectUri: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'grantType' is not null or undefined
      assertParamExists('token', 'grantType', grantType);
      // verify required parameter 'code' is not null or undefined
      assertParamExists('token', 'code', code);
      // verify required parameter 'clientId' is not null or undefined
      assertParamExists('token', 'clientId', clientId);
      // verify required parameter 'redirectUri' is not null or undefined
      assertParamExists('token', 'redirectUri', redirectUri);
      const localVarPath = `/auth/token`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new URLSearchParams();

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      if (grantType !== undefined) {
        localVarFormParams.set('grant_type', grantType as any);
      }

      if (code !== undefined) {
        localVarFormParams.set('code', code as any);
      }

      if (clientId !== undefined) {
        localVarFormParams.set('client_id', clientId as any);
      }

      if (redirectUri !== undefined) {
        localVarFormParams.set('redirect_uri', redirectUri as any);
      }

      localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = localVarFormParams.toString();

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LinkApi - functional programming interface
 * @export
 */
export const LinkApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = LinkApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new link
     * @param {LinkRequest} linkRequest Request body for starting a new Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createLink(
      linkRequest: LinkRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createLink(linkRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get the customization details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCustomization(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomizationDetails>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomization(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get a list of institutions
     * @param {string} [country] The country the institution belongs to
     * @param {Array<string>} [countries] The countries the institution belongs to
     * @param {string} [productsSupported] The products that this institution supports
     * @param {string} [institutionType] The type of institution
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listInstitutions(
      country?: string,
      countries?: Array<string>,
      productsSupported?: string,
      institutionType?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Institution>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listInstitutions(
        country,
        countries,
        productsSupported,
        institutionType,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Update an existing link
     * @param {RelinkRequest} relinkRequest Request body for updating Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async relink(
      relinkRequest: RelinkRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.relink(relinkRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Exchange authorization code for token
     * @param {string} grantType
     * @param {string} code
     * @param {string} clientId
     * @param {string} redirectUri
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async token(
      grantType: string,
      code: string,
      clientId: string,
      redirectUri: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessTokenResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.token(grantType, code, clientId, redirectUri, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * LinkApi - factory interface
 * @export
 */
export const LinkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = LinkApiFp(configuration);
  return {
    /**
     * Creates a new link
     * @param {LinkRequest} linkRequest Request body for starting a new Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLink(linkRequest: LinkRequest, options?: any): AxiosPromise<LinkResponse> {
      return localVarFp.createLink(linkRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Get the customization details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCustomization(options?: any): AxiosPromise<CustomizationDetails> {
      return localVarFp.getCustomization(options).then((request) => request(axios, basePath));
    },
    /**
     * Get a list of institutions
     * @param {string} [country] The country the institution belongs to
     * @param {Array<string>} [countries] The countries the institution belongs to
     * @param {string} [productsSupported] The products that this institution supports
     * @param {string} [institutionType] The type of institution
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listInstitutions(
      country?: string,
      countries?: Array<string>,
      productsSupported?: string,
      institutionType?: string,
      options?: any,
    ): AxiosPromise<Array<Institution>> {
      return localVarFp
        .listInstitutions(country, countries, productsSupported, institutionType, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update an existing link
     * @param {RelinkRequest} relinkRequest Request body for updating Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    relink(relinkRequest: RelinkRequest, options?: any): AxiosPromise<LinkResponse> {
      return localVarFp.relink(relinkRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Exchange authorization code for token
     * @param {string} grantType
     * @param {string} code
     * @param {string} clientId
     * @param {string} redirectUri
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    token(
      grantType: string,
      code: string,
      clientId: string,
      redirectUri: string,
      options?: any,
    ): AxiosPromise<AccessTokenResponse> {
      return localVarFp
        .token(grantType, code, clientId, redirectUri, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * LinkApi - interface
 * @export
 * @interface LinkApi
 */
export interface LinkApiInterface {
  /**
   * Creates a new link
   * @param {LinkRequest} linkRequest Request body for starting a new Link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApiInterface
   */
  createLink(linkRequest: LinkRequest, options?: AxiosRequestConfig): AxiosPromise<LinkResponse>;

  /**
   * Get the customization details
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApiInterface
   */
  getCustomization(options?: AxiosRequestConfig): AxiosPromise<CustomizationDetails>;

  /**
   * Get a list of institutions
   * @param {string} [country] The country the institution belongs to
   * @param {Array<string>} [countries] The countries the institution belongs to
   * @param {string} [productsSupported] The products that this institution supports
   * @param {string} [institutionType] The type of institution
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApiInterface
   */
  listInstitutions(
    country?: string,
    countries?: Array<string>,
    productsSupported?: string,
    institutionType?: string,
    options?: AxiosRequestConfig,
  ): AxiosPromise<Array<Institution>>;

  /**
   * Update an existing link
   * @param {RelinkRequest} relinkRequest Request body for updating Link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApiInterface
   */
  relink(relinkRequest: RelinkRequest, options?: AxiosRequestConfig): AxiosPromise<LinkResponse>;

  /**
   * Exchange authorization code for token
   * @param {string} grantType
   * @param {string} code
   * @param {string} clientId
   * @param {string} redirectUri
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApiInterface
   */
  token(
    grantType: string,
    code: string,
    clientId: string,
    redirectUri: string,
    options?: AxiosRequestConfig,
  ): AxiosPromise<AccessTokenResponse>;
}

/**
 * LinkApi - object-oriented interface
 * @export
 * @class LinkApi
 * @extends {BaseAPI}
 */
export class LinkApi extends BaseAPI implements LinkApiInterface {
  /**
   * Creates a new link
   * @param {LinkRequest} linkRequest Request body for starting a new Link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApi
   */
  public createLink(linkRequest: LinkRequest, options?: AxiosRequestConfig) {
    return LinkApiFp(this.configuration)
      .createLink(linkRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get the customization details
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApi
   */
  public getCustomization(options?: AxiosRequestConfig) {
    return LinkApiFp(this.configuration)
      .getCustomization(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of institutions
   * @param {string} [country] The country the institution belongs to
   * @param {Array<string>} [countries] The countries the institution belongs to
   * @param {string} [productsSupported] The products that this institution supports
   * @param {string} [institutionType] The type of institution
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApi
   */
  public listInstitutions(
    country?: string,
    countries?: Array<string>,
    productsSupported?: string,
    institutionType?: string,
    options?: AxiosRequestConfig,
  ) {
    return LinkApiFp(this.configuration)
      .listInstitutions(country, countries, productsSupported, institutionType, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update an existing link
   * @param {RelinkRequest} relinkRequest Request body for updating Link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApi
   */
  public relink(relinkRequest: RelinkRequest, options?: AxiosRequestConfig) {
    return LinkApiFp(this.configuration)
      .relink(relinkRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Exchange authorization code for token
   * @param {string} grantType
   * @param {string} code
   * @param {string} clientId
   * @param {string} redirectUri
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApi
   */
  public token(grantType: string, code: string, clientId: string, redirectUri: string, options?: AxiosRequestConfig) {
    return LinkApiFp(this.configuration)
      .token(grantType, code, clientId, redirectUri, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * LoginIdentityApi - axios parameter creator
 * @export
 */
export const LoginIdentityApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Delete a specific loginIdentity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLoginIdentity: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/login_identity`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * generate a link token that can be used to create link
     * @param {LinkTokenRequest} linkTokenRequest token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateLinkToken: async (
      linkTokenRequest: LinkTokenRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'linkTokenRequest' is not null or undefined
      assertParamExists('generateLinkToken', 'linkTokenRequest', linkTokenRequest);
      const localVarPath = `/link/token`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(linkTokenRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a specific account\'s information
     * @param {string} accountId The account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccount: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('getAccount', 'accountId', accountId);
      const localVarPath = `/accounts/{accountId}`.replace(`{${'accountId'}}`, encodeURIComponent(String(accountId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', ['account'], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the account number for a specific account
     * @param {string} accountId The account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccountNumber: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('getAccountNumber', 'accountId', accountId);
      const localVarPath = `/account_numbers/{accountId}`.replace(
        `{${'accountId'}}`,
        encodeURIComponent(String(accountId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the balance history for a specific account
     * @param {string} accountId The account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBalanceHistory: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('getBalanceHistory', 'accountId', accountId);
      const localVarPath = `/balance_history/{accountId}`.replace(
        `{${'accountId'}}`,
        encodeURIComponent(String(accountId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Download composite statement
     * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCompositeStatement: async (redirect?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/composite_statement`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      if (redirect !== undefined) {
        localVarQueryParameter['redirect'] = redirect;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * \\[BETA] Get a list of identity data for a given login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentity: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/identity`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get income figures for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIncomeEstimateByLoginIdentityId: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/income`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a specific loginIdentity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoginIdentity: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/login_identity`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Download statement
     * @param {string} statementId The statement id
     * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatement: async (
      statementId: string,
      redirect?: boolean,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'statementId' is not null or undefined
      assertParamExists('getStatement', 'statementId', statementId);
      const localVarPath = `/statements/{statementId}`.replace(
        `{${'statementId'}}`,
        encodeURIComponent(String(statementId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      if (redirect !== undefined) {
        localVarQueryParameter['redirect'] = redirect;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * (Deprecated) Get statement link for download
     * @param {string} statementId The statement id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatementLink: async (statementId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'statementId' is not null or undefined
      assertParamExists('getStatementLink', 'statementId', statementId);
      const localVarPath = `/statement_links/{statementId}`.replace(
        `{${'statementId'}}`,
        encodeURIComponent(String(statementId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get list of available statements
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatements: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/statements`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of accounts for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAccounts: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/accounts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', ['account'], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of transactions for a particular account. The transactions are returned in sorted order, with the most recent one appearing first.
     * @param {string} accountId The account id (ULID, example - 01EP4A1MZDHKETZFRPF0K62S6S)
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTransactionsByAccountId: async (
      accountId: string,
      offset?: number,
      limit?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('listTransactionsByAccountId', 'accountId', accountId);
      const localVarPath = `/transactions/{accountId}`.replace(
        `{${'accountId'}}`,
        encodeURIComponent(String(accountId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', ['transaction'], configuration);

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of transactions for a login identity. The transactions are returned in sorted order, with the most recent one appearing first.
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTransactionsByLoginIdentityId: async (
      offset?: number,
      limit?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/transactions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', ['transaction'], configuration);

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a refresh job for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshLoginIdentity: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/login_identity/refresh`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LoginIdentityApi - functional programming interface
 * @export
 */
export const LoginIdentityApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = LoginIdentityApiAxiosParamCreator(configuration);
  return {
    /**
     * Delete a specific loginIdentity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteLoginIdentity(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteLoginIdentityResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLoginIdentity(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * generate a link token that can be used to create link
     * @param {LinkTokenRequest} linkTokenRequest token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async generateLinkToken(
      linkTokenRequest: LinkTokenRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkTokenResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.generateLinkToken(linkTokenRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get a specific account\'s information
     * @param {string} accountId The account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAccount(
      accountId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAccountResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(accountId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get the account number for a specific account
     * @param {string} accountId The account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAccountNumber(
      accountId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAccountNumberResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountNumber(accountId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get the balance history for a specific account
     * @param {string} accountId The account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBalanceHistory(
      accountId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBalanceHistoryResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBalanceHistory(accountId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Download composite statement
     * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCompositeStatement(
      redirect?: boolean,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompositeStatementLink>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCompositeStatement(redirect, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * \\[BETA] Get a list of identity data for a given login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getIdentity(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetIdentityResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentity(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get income figures for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getIncomeEstimateByLoginIdentityId(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IncomeResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getIncomeEstimateByLoginIdentityId(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get a specific loginIdentity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLoginIdentity(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLoginIdentityByIdResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLoginIdentity(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Download statement
     * @param {string} statementId The statement id
     * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStatement(
      statementId: string,
      redirect?: boolean,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStatementLinkResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStatement(statementId, redirect, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * (Deprecated) Get statement link for download
     * @param {string} statementId The statement id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStatementLink(
      statementId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStatementLinkResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStatementLink(statementId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get list of available statements
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStatements(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStatementsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStatements(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get a list of accounts for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listAccounts(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAccountsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listAccounts(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get a list of transactions for a particular account. The transactions are returned in sorted order, with the most recent one appearing first.
     * @param {string} accountId The account id (ULID, example - 01EP4A1MZDHKETZFRPF0K62S6S)
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listTransactionsByAccountId(
      accountId: string,
      offset?: number,
      limit?: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListTransactionsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listTransactionsByAccountId(
        accountId,
        offset,
        limit,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get a list of transactions for a login identity. The transactions are returned in sorted order, with the most recent one appearing first.
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listTransactionsByLoginIdentityId(
      offset?: number,
      limit?: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListTransactionsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listTransactionsByLoginIdentityId(
        offset,
        limit,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Create a refresh job for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async refreshLoginIdentity(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.refreshLoginIdentity(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * LoginIdentityApi - factory interface
 * @export
 */
export const LoginIdentityApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = LoginIdentityApiFp(configuration);
  return {
    /**
     * Delete a specific loginIdentity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLoginIdentity(options?: any): AxiosPromise<DeleteLoginIdentityResponse> {
      return localVarFp.deleteLoginIdentity(options).then((request) => request(axios, basePath));
    },
    /**
     * generate a link token that can be used to create link
     * @param {LinkTokenRequest} linkTokenRequest token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateLinkToken(linkTokenRequest: LinkTokenRequest, options?: any): AxiosPromise<LinkTokenResponse> {
      return localVarFp.generateLinkToken(linkTokenRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Get a specific account\'s information
     * @param {string} accountId The account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccount(accountId: string, options?: any): AxiosPromise<GetAccountResponse> {
      return localVarFp.getAccount(accountId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get the account number for a specific account
     * @param {string} accountId The account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccountNumber(accountId: string, options?: any): AxiosPromise<GetAccountNumberResponse> {
      return localVarFp.getAccountNumber(accountId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get the balance history for a specific account
     * @param {string} accountId The account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBalanceHistory(accountId: string, options?: any): AxiosPromise<GetBalanceHistoryResponse> {
      return localVarFp.getBalanceHistory(accountId, options).then((request) => request(axios, basePath));
    },
    /**
     * Download composite statement
     * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCompositeStatement(redirect?: boolean, options?: any): AxiosPromise<CompositeStatementLink> {
      return localVarFp.getCompositeStatement(redirect, options).then((request) => request(axios, basePath));
    },
    /**
     * \\[BETA] Get a list of identity data for a given login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentity(options?: any): AxiosPromise<GetIdentityResponse> {
      return localVarFp.getIdentity(options).then((request) => request(axios, basePath));
    },
    /**
     * Get income figures for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIncomeEstimateByLoginIdentityId(options?: any): AxiosPromise<IncomeResponse> {
      return localVarFp.getIncomeEstimateByLoginIdentityId(options).then((request) => request(axios, basePath));
    },
    /**
     * Get a specific loginIdentity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoginIdentity(options?: any): AxiosPromise<GetLoginIdentityByIdResponse> {
      return localVarFp.getLoginIdentity(options).then((request) => request(axios, basePath));
    },
    /**
     * Download statement
     * @param {string} statementId The statement id
     * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatement(statementId: string, redirect?: boolean, options?: any): AxiosPromise<GetStatementLinkResponse> {
      return localVarFp.getStatement(statementId, redirect, options).then((request) => request(axios, basePath));
    },
    /**
     * (Deprecated) Get statement link for download
     * @param {string} statementId The statement id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatementLink(statementId: string, options?: any): AxiosPromise<GetStatementLinkResponse> {
      return localVarFp.getStatementLink(statementId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get list of available statements
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatements(options?: any): AxiosPromise<GetStatementsResponse> {
      return localVarFp.getStatements(options).then((request) => request(axios, basePath));
    },
    /**
     * Get a list of accounts for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAccounts(options?: any): AxiosPromise<ListAccountsResponse> {
      return localVarFp.listAccounts(options).then((request) => request(axios, basePath));
    },
    /**
     * Get a list of transactions for a particular account. The transactions are returned in sorted order, with the most recent one appearing first.
     * @param {string} accountId The account id (ULID, example - 01EP4A1MZDHKETZFRPF0K62S6S)
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTransactionsByAccountId(
      accountId: string,
      offset?: number,
      limit?: number,
      options?: any,
    ): AxiosPromise<ListTransactionsResponse> {
      return localVarFp
        .listTransactionsByAccountId(accountId, offset, limit, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a list of transactions for a login identity. The transactions are returned in sorted order, with the most recent one appearing first.
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTransactionsByLoginIdentityId(
      offset?: number,
      limit?: number,
      options?: any,
    ): AxiosPromise<ListTransactionsResponse> {
      return localVarFp
        .listTransactionsByLoginIdentityId(offset, limit, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a refresh job for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshLoginIdentity(options?: any): AxiosPromise<void> {
      return localVarFp.refreshLoginIdentity(options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * LoginIdentityApi - interface
 * @export
 * @interface LoginIdentityApi
 */
export interface LoginIdentityApiInterface {
  /**
   * Delete a specific loginIdentity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  deleteLoginIdentity(options?: AxiosRequestConfig): AxiosPromise<DeleteLoginIdentityResponse>;

  /**
   * generate a link token that can be used to create link
   * @param {LinkTokenRequest} linkTokenRequest token request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  generateLinkToken(linkTokenRequest: LinkTokenRequest, options?: AxiosRequestConfig): AxiosPromise<LinkTokenResponse>;

  /**
   * Get a specific account\'s information
   * @param {string} accountId The account id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  getAccount(accountId: string, options?: AxiosRequestConfig): AxiosPromise<GetAccountResponse>;

  /**
   * Get the account number for a specific account
   * @param {string} accountId The account id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  getAccountNumber(accountId: string, options?: AxiosRequestConfig): AxiosPromise<GetAccountNumberResponse>;

  /**
   * Get the balance history for a specific account
   * @param {string} accountId The account id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  getBalanceHistory(accountId: string, options?: AxiosRequestConfig): AxiosPromise<GetBalanceHistoryResponse>;

  /**
   * Download composite statement
   * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  getCompositeStatement(redirect?: boolean, options?: AxiosRequestConfig): AxiosPromise<CompositeStatementLink>;

  /**
   * \\[BETA] Get a list of identity data for a given login identity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  getIdentity(options?: AxiosRequestConfig): AxiosPromise<GetIdentityResponse>;

  /**
   * Get income figures for a login identity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  getIncomeEstimateByLoginIdentityId(options?: AxiosRequestConfig): AxiosPromise<IncomeResponse>;

  /**
   * Get a specific loginIdentity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  getLoginIdentity(options?: AxiosRequestConfig): AxiosPromise<GetLoginIdentityByIdResponse>;

  /**
   * Download statement
   * @param {string} statementId The statement id
   * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  getStatement(
    statementId: string,
    redirect?: boolean,
    options?: AxiosRequestConfig,
  ): AxiosPromise<GetStatementLinkResponse>;

  /**
   * (Deprecated) Get statement link for download
   * @param {string} statementId The statement id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  getStatementLink(statementId: string, options?: AxiosRequestConfig): AxiosPromise<GetStatementLinkResponse>;

  /**
   * Get list of available statements
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  getStatements(options?: AxiosRequestConfig): AxiosPromise<GetStatementsResponse>;

  /**
   * Get a list of accounts for a login identity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  listAccounts(options?: AxiosRequestConfig): AxiosPromise<ListAccountsResponse>;

  /**
   * Get a list of transactions for a particular account. The transactions are returned in sorted order, with the most recent one appearing first.
   * @param {string} accountId The account id (ULID, example - 01EP4A1MZDHKETZFRPF0K62S6S)
   * @param {number} [offset] default is 0
   * @param {number} [limit] default is 500, max is 1000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  listTransactionsByAccountId(
    accountId: string,
    offset?: number,
    limit?: number,
    options?: AxiosRequestConfig,
  ): AxiosPromise<ListTransactionsResponse>;

  /**
   * Get a list of transactions for a login identity. The transactions are returned in sorted order, with the most recent one appearing first.
   * @param {number} [offset] default is 0
   * @param {number} [limit] default is 500, max is 1000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  listTransactionsByLoginIdentityId(
    offset?: number,
    limit?: number,
    options?: AxiosRequestConfig,
  ): AxiosPromise<ListTransactionsResponse>;

  /**
   * Create a refresh job for a login identity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  refreshLoginIdentity(options?: AxiosRequestConfig): AxiosPromise<void>;
}

/**
 * LoginIdentityApi - object-oriented interface
 * @export
 * @class LoginIdentityApi
 * @extends {BaseAPI}
 */
export class LoginIdentityApi extends BaseAPI implements LoginIdentityApiInterface {
  /**
   * Delete a specific loginIdentity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public deleteLoginIdentity(options?: AxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .deleteLoginIdentity(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * generate a link token that can be used to create link
   * @param {LinkTokenRequest} linkTokenRequest token request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public generateLinkToken(linkTokenRequest: LinkTokenRequest, options?: AxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .generateLinkToken(linkTokenRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a specific account\'s information
   * @param {string} accountId The account id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public getAccount(accountId: string, options?: AxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .getAccount(accountId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get the account number for a specific account
   * @param {string} accountId The account id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public getAccountNumber(accountId: string, options?: AxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .getAccountNumber(accountId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get the balance history for a specific account
   * @param {string} accountId The account id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public getBalanceHistory(accountId: string, options?: AxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .getBalanceHistory(accountId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Download composite statement
   * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public getCompositeStatement(redirect?: boolean, options?: AxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .getCompositeStatement(redirect, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * \\[BETA] Get a list of identity data for a given login identity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public getIdentity(options?: AxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .getIdentity(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get income figures for a login identity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public getIncomeEstimateByLoginIdentityId(options?: AxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .getIncomeEstimateByLoginIdentityId(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a specific loginIdentity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public getLoginIdentity(options?: AxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .getLoginIdentity(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Download statement
   * @param {string} statementId The statement id
   * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public getStatement(statementId: string, redirect?: boolean, options?: AxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .getStatement(statementId, redirect, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * (Deprecated) Get statement link for download
   * @param {string} statementId The statement id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public getStatementLink(statementId: string, options?: AxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .getStatementLink(statementId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get list of available statements
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public getStatements(options?: AxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .getStatements(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of accounts for a login identity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public listAccounts(options?: AxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .listAccounts(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of transactions for a particular account. The transactions are returned in sorted order, with the most recent one appearing first.
   * @param {string} accountId The account id (ULID, example - 01EP4A1MZDHKETZFRPF0K62S6S)
   * @param {number} [offset] default is 0
   * @param {number} [limit] default is 500, max is 1000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public listTransactionsByAccountId(accountId: string, offset?: number, limit?: number, options?: AxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .listTransactionsByAccountId(accountId, offset, limit, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of transactions for a login identity. The transactions are returned in sorted order, with the most recent one appearing first.
   * @param {number} [offset] default is 0
   * @param {number} [limit] default is 500, max is 1000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public listTransactionsByLoginIdentityId(offset?: number, limit?: number, options?: AxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .listTransactionsByLoginIdentityId(offset, limit, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a refresh job for a login identity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public refreshLoginIdentity(options?: AxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .refreshLoginIdentity(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PublicApi - axios parameter creator
 * @export
 */
export const PublicApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Callback url to get the oauth authorization token
     * @param {string} state The state of the client when oauth was initialized
     * @param {string} [code] The authorization code generated by the Oauth provider
     * @param {string} [error] error
     * @param {string} [errorDescription] error description
     * @param {string} [errorDetails] error details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authCallback: async (
      state: string,
      code?: string,
      error?: string,
      errorDescription?: string,
      errorDetails?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'state' is not null or undefined
      assertParamExists('authCallback', 'state', state);
      const localVarPath = `/auth/callback`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', ['test'], configuration);

      if (state !== undefined) {
        localVarQueryParameter['state'] = state;
      }

      if (code !== undefined) {
        localVarQueryParameter['code'] = code;
      }

      if (error !== undefined) {
        localVarQueryParameter['error'] = error;
      }

      if (errorDescription !== undefined) {
        localVarQueryParameter['error_description'] = errorDescription;
      }

      if (errorDetails !== undefined) {
        localVarQueryParameter['error_details'] = errorDetails;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * generate an access_token
     * @param {TokenRequest} [tokenRequest] token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateCustomerAccessToken: async (
      tokenRequest?: TokenRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/auth/customer/token`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', ['test'], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(tokenRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PublicApi - functional programming interface
 * @export
 */
export const PublicApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PublicApiAxiosParamCreator(configuration);
  return {
    /**
     * Callback url to get the oauth authorization token
     * @param {string} state The state of the client when oauth was initialized
     * @param {string} [code] The authorization code generated by the Oauth provider
     * @param {string} [error] error
     * @param {string} [errorDescription] error description
     * @param {string} [errorDetails] error details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authCallback(
      state: string,
      code?: string,
      error?: string,
      errorDescription?: string,
      errorDetails?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RedirectUriResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.authCallback(
        state,
        code,
        error,
        errorDescription,
        errorDetails,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * generate an access_token
     * @param {TokenRequest} [tokenRequest] token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async generateCustomerAccessToken(
      tokenRequest?: TokenRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.generateCustomerAccessToken(tokenRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * PublicApi - factory interface
 * @export
 */
export const PublicApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = PublicApiFp(configuration);
  return {
    /**
     * Callback url to get the oauth authorization token
     * @param {string} state The state of the client when oauth was initialized
     * @param {string} [code] The authorization code generated by the Oauth provider
     * @param {string} [error] error
     * @param {string} [errorDescription] error description
     * @param {string} [errorDetails] error details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authCallback(
      state: string,
      code?: string,
      error?: string,
      errorDescription?: string,
      errorDetails?: string,
      options?: any,
    ): AxiosPromise<RedirectUriResponse> {
      return localVarFp
        .authCallback(state, code, error, errorDescription, errorDetails, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * generate an access_token
     * @param {TokenRequest} [tokenRequest] token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateCustomerAccessToken(tokenRequest?: TokenRequest, options?: any): AxiosPromise<TokenResponse> {
      return localVarFp.generateCustomerAccessToken(tokenRequest, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * PublicApi - interface
 * @export
 * @interface PublicApi
 */
export interface PublicApiInterface {
  /**
   * Callback url to get the oauth authorization token
   * @param {string} state The state of the client when oauth was initialized
   * @param {string} [code] The authorization code generated by the Oauth provider
   * @param {string} [error] error
   * @param {string} [errorDescription] error description
   * @param {string} [errorDetails] error details
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PublicApiInterface
   */
  authCallback(
    state: string,
    code?: string,
    error?: string,
    errorDescription?: string,
    errorDetails?: string,
    options?: AxiosRequestConfig,
  ): AxiosPromise<RedirectUriResponse>;

  /**
   * generate an access_token
   * @param {TokenRequest} [tokenRequest] token request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PublicApiInterface
   */
  generateCustomerAccessToken(tokenRequest?: TokenRequest, options?: AxiosRequestConfig): AxiosPromise<TokenResponse>;
}

/**
 * PublicApi - object-oriented interface
 * @export
 * @class PublicApi
 * @extends {BaseAPI}
 */
export class PublicApi extends BaseAPI implements PublicApiInterface {
  /**
   * Callback url to get the oauth authorization token
   * @param {string} state The state of the client when oauth was initialized
   * @param {string} [code] The authorization code generated by the Oauth provider
   * @param {string} [error] error
   * @param {string} [errorDescription] error description
   * @param {string} [errorDetails] error details
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PublicApi
   */
  public authCallback(
    state: string,
    code?: string,
    error?: string,
    errorDescription?: string,
    errorDetails?: string,
    options?: AxiosRequestConfig,
  ) {
    return PublicApiFp(this.configuration)
      .authCallback(state, code, error, errorDescription, errorDetails, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * generate an access_token
   * @param {TokenRequest} [tokenRequest] token request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PublicApi
   */
  public generateCustomerAccessToken(tokenRequest?: TokenRequest, options?: AxiosRequestConfig) {
    return PublicApiFp(this.configuration)
      .generateCustomerAccessToken(tokenRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
