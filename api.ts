/* tslint:disable */
/* eslint-disable */
/**
 * Finverse Public
 * Documentation of the early finverse services
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: info@finverse.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 *
 * @export
 * @interface AccessTokenResponse
 */
export interface AccessTokenResponse {
  /**
   *
   * @type {string}
   * @memberof AccessTokenResponse
   */
  access_token: string;
  /**
   *
   * @type {string}
   * @memberof AccessTokenResponse
   */
  login_identity_id: string;
  /**
   *
   * @type {string}
   * @memberof AccessTokenResponse
   */
  token_type: string;
  /**
   * seconds
   * @type {number}
   * @memberof AccessTokenResponse
   */
  expires_in: number;
  /**
   *
   * @type {string}
   * @memberof AccessTokenResponse
   */
  refresh_token: string;
  /**
   *
   * @type {string}
   * @memberof AccessTokenResponse
   */
  issued_at: string;
}
/**
 *
 * @export
 * @interface Account
 */
export interface Account {
  /**
   *
   * @type {string}
   * @memberof Account
   */
  account_id: string;
  /**
   * The SHA3-256 hash of the account number, salted with the loginIdentityId
   * @type {string}
   * @memberof Account
   */
  group_id: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  account_holder_name?: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  account_name: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  account_nickname?: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  account_sub_type?: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  account_number_masked?: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  country?: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  updated_at?: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  account_currency?: string;
  /**
   *
   * @type {CurrencyAmount}
   * @memberof Account
   */
  balance?: CurrencyAmount;
  /**
   *
   * @type {CurrencyAmount}
   * @memberof Account
   */
  statement_balance?: CurrencyAmount;
  /**
   *
   * @type {boolean}
   * @memberof Account
   */
  is_parent: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Account
   */
  is_closed: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Account
   */
  is_excluded: boolean;
  /**
   *
   * @type {AccountType}
   * @memberof Account
   */
  account_type?: AccountType;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof Account
   */
  metadata: { [key: string]: string };
}
/**
 *
 * @export
 * @interface AccountNumber
 */
export interface AccountNumber {
  /**
   *
   * @type {string}
   * @memberof AccountNumber
   */
  account_id: string;
  /**
   *
   * @type {string}
   * @memberof AccountNumber
   */
  number?: string;
  /**
   *
   * @type {string}
   * @memberof AccountNumber
   */
  raw: string;
}
/**
 *
 * @export
 * @interface AccountType
 */
export interface AccountType {
  /**
   *
   * @type {string}
   * @memberof AccountType
   */
  type?: AccountTypeTypeEnum;
  /**
   *
   * @type {string}
   * @memberof AccountType
   */
  subtype?: AccountTypeSubtypeEnum;
}

export const AccountTypeTypeEnum = {
  Deposit: 'DEPOSIT',
  Card: 'CARD',
  Investment: 'INVESTMENT',
  Loan: 'LOAN',
  Unknown: 'UNKNOWN',
} as const;

export type AccountTypeTypeEnum = (typeof AccountTypeTypeEnum)[keyof typeof AccountTypeTypeEnum];
export const AccountTypeSubtypeEnum = {
  Current: 'CURRENT',
  Savings: 'SAVINGS',
  TimeDeposit: 'TIME_DEPOSIT',
  Other: 'OTHER',
  CreditCard: 'CREDIT_CARD',
  DebitCard: 'DEBIT_CARD',
  Securities: 'SECURITIES',
  Funds: 'FUNDS',
  Stocks: 'STOCKS',
  Bonds: 'BONDS',
  Mortgage: 'MORTGAGE',
  PersonalLoan: 'PERSONAL_LOAN',
  RevolvingLoan: 'REVOLVING_LOAN',
  Unknown: 'UNKNOWN',
} as const;

export type AccountTypeSubtypeEnum = (typeof AccountTypeSubtypeEnum)[keyof typeof AccountTypeSubtypeEnum];

/**
 *
 * @export
 * @interface ActionRequest
 */
export interface ActionRequest {
  /**
   *
   * @type {EncryptedPayload}
   * @memberof ActionRequest
   */
  encrypted_credentials: EncryptedPayload;
  /**
   * The action id
   * @type {string}
   * @memberof ActionRequest
   */
  action_id: string;
}
/**
 *
 * @export
 * @interface AllProductStatus
 */
export interface AllProductStatus {
  /**
   *
   * @type {ProductStatus}
   * @memberof AllProductStatus
   */
  accounts?: ProductStatus;
  /**
   *
   * @type {ProductStatus}
   * @memberof AllProductStatus
   */
  online_transactions?: ProductStatus;
  /**
   *
   * @type {ProductStatus}
   * @memberof AllProductStatus
   */
  statements?: ProductStatus;
  /**
   *
   * @type {ProductStatus}
   * @memberof AllProductStatus
   */
  historical_transactions?: ProductStatus;
  /**
   *
   * @type {ProductStatus}
   * @memberof AllProductStatus
   */
  account_numbers?: ProductStatus;
  /**
   *
   * @type {ProductStatus}
   * @memberof AllProductStatus
   */
  identity?: ProductStatus;
  /**
   *
   * @type {ProductStatus}
   * @memberof AllProductStatus
   */
  balance_history?: ProductStatus;
  /**
   *
   * @type {ProductStatus}
   * @memberof AllProductStatus
   */
  payments?: ProductStatus;
  /**
   *
   * @type {ProductStatus}
   * @memberof AllProductStatus
   */
  income_estimation?: ProductStatus;
  /**
   *
   * @type {ProductStatus}
   * @memberof AllProductStatus
   */
  card_details?: ProductStatus;
}
/**
 *
 * @export
 * @interface ApiLinkRequest
 */
export interface ApiLinkRequest {
  /**
   *
   * @type {string}
   * @memberof ApiLinkRequest
   */
  institution_id: string;
  /**
   * Identifier for end user
   * @type {string}
   * @memberof ApiLinkRequest
   */
  user_id: string;
  /**
   * this is a mandatory field
   * @type {boolean}
   * @memberof ApiLinkRequest
   */
  consent: boolean | null;
  /**
   * products that are requested
   * @type {Array<string>}
   * @memberof ApiLinkRequest
   */
  products_requested: Array<string>;
  /**
   *
   * @type {boolean}
   * @memberof ApiLinkRequest
   */
  store_credentials: boolean;
  /**
   *
   * @type {EncryptedPayload}
   * @memberof ApiLinkRequest
   */
  encrypted_credentials: EncryptedPayload;
  /**
   *
   * @type {string}
   * @memberof ApiLinkRequest
   */
  payment_instruction_id?: string;
}
/**
 *
 * @export
 * @interface ApiRelinkRequest
 */
export interface ApiRelinkRequest {
  /**
   *
   * @type {boolean}
   * @memberof ApiRelinkRequest
   */
  store_credential?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ApiRelinkRequest
   */
  consent: boolean;
  /**
   *
   * @type {EncryptedPayload}
   * @memberof ApiRelinkRequest
   */
  encrypted_credentials: EncryptedPayload;
}
/**
 *
 * @export
 * @interface AuthChecklistFactor
 */
export interface AuthChecklistFactor {
  /**
   * Type of authorization factor
   * @type {string}
   * @memberof AuthChecklistFactor
   */
  type: AuthChecklistFactorTypeEnum;
  /**
   * Allows grouping similar checklist item types together
   * @type {string}
   * @memberof AuthChecklistFactor
   */
  group_id: string;
  /**
   * Indicates whether authorization factor is known to be required at this time.  Possible values are YES, NO, OPTIONAL
   * @type {string}
   * @memberof AuthChecklistFactor
   */
  required: AuthChecklistFactorRequiredEnum;
  /**
   * Helper text that applies to a specific checklist item
   * @type {string}
   * @memberof AuthChecklistFactor
   */
  helper_text?: string;
  /**
   * Array of the options accepted for a specific authorization factor
   * @type {Array<AuthChecklistOptions>}
   * @memberof AuthChecklistFactor
   */
  options: Array<AuthChecklistOptions>;
}

export const AuthChecklistFactorTypeEnum = {
  AccountIdentification: 'ACCOUNT_IDENTIFICATION',
  UserIdentification: 'USER_IDENTIFICATION',
  EnduserConsent: 'ENDUSER_CONSENT',
  AccountholderAuthentication: 'ACCOUNTHOLDER_AUTHENTICATION',
} as const;

export type AuthChecklistFactorTypeEnum =
  (typeof AuthChecklistFactorTypeEnum)[keyof typeof AuthChecklistFactorTypeEnum];
export const AuthChecklistFactorRequiredEnum = {
  Yes: 'YES',
  No: 'NO',
  Optional: 'OPTIONAL',
} as const;

export type AuthChecklistFactorRequiredEnum =
  (typeof AuthChecklistFactorRequiredEnum)[keyof typeof AuthChecklistFactorRequiredEnum];

/**
 *
 * @export
 * @interface AuthChecklistOptions
 */
export interface AuthChecklistOptions {
  /**
   * Name of authorization factor. Possible values are INSTITUTION_CREDENTIALS_LOGIN, INSTITUTION_OAUTH_LOGIN,
   * @type {string}
   * @memberof AuthChecklistOptions
   */
  name: AuthChecklistOptionsNameEnum;
  /**
   * Timestamp in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ) for when the authorization factor was submitted to Finverse
   * @type {string}
   * @memberof AuthChecklistOptions
   */
  submitted_at?: string | null;
  /**
   * Indicates who submitted the authorization factor to Finverse. Possible values are CUSTOMER_APP, FINVERSE_LINK
   * @type {string}
   * @memberof AuthChecklistOptions
   */
  submitted_by?: AuthChecklistOptionsSubmittedByEnum;
  /**
   * Redirect to bank for authentication
   * @type {string}
   * @memberof AuthChecklistOptions
   */
  redirect_url?: string;
}

export const AuthChecklistOptionsNameEnum = {
  InstitutionCredentialsLogin: 'INSTITUTION_CREDENTIALS_LOGIN',
  InstitutionOauthLogin: 'INSTITUTION_OAUTH_LOGIN',
} as const;

export type AuthChecklistOptionsNameEnum =
  (typeof AuthChecklistOptionsNameEnum)[keyof typeof AuthChecklistOptionsNameEnum];
export const AuthChecklistOptionsSubmittedByEnum = {
  CustomerApp: 'CUSTOMER_APP',
  FinverseLink: 'FINVERSE_LINK',
} as const;

export type AuthChecklistOptionsSubmittedByEnum =
  (typeof AuthChecklistOptionsSubmittedByEnum)[keyof typeof AuthChecklistOptionsSubmittedByEnum];

/**
 *
 * @export
 * @interface AuthorizeMandateRequest
 */
export interface AuthorizeMandateRequest {
  /**
   * Whether a consent was provided by the enduser to authorize a mandate
   * @type {boolean}
   * @memberof AuthorizeMandateRequest
   */
  enduser_consent: boolean;
}
/**
 *
 * @export
 * @interface AutopayEnrollmentConfiguration
 */
export interface AutopayEnrollmentConfiguration {
  /**
   * Indicate whether the autopay enrollment screen should be prompted to the end user
   * @type {boolean}
   * @memberof AutopayEnrollmentConfiguration
   */
  display_enrollment_screen: boolean;
  /**
   * Indicate what value should be prefilled on the autopay enrollment screen
   * @type {string}
   * @memberof AutopayEnrollmentConfiguration
   */
  enrollment_prefill_value: AutopayEnrollmentConfigurationEnrollmentPrefillValueEnum;
}

export const AutopayEnrollmentConfigurationEnrollmentPrefillValueEnum = {
  Yes: 'YES',
  No: 'NO',
} as const;

export type AutopayEnrollmentConfigurationEnrollmentPrefillValueEnum =
  (typeof AutopayEnrollmentConfigurationEnrollmentPrefillValueEnum)[keyof typeof AutopayEnrollmentConfigurationEnrollmentPrefillValueEnum];

/**
 *
 * @export
 * @interface AvailablePaymentMethod
 */
export interface AvailablePaymentMethod {
  /**
   *
   * @type {string}
   * @memberof AvailablePaymentMethod
   */
  payment_account_id?: string;
  /**
   * The payment method type, possible values CARD, MANDATE and MANUAL
   * @type {string}
   * @memberof AvailablePaymentMethod
   */
  payment_method_type?: string;
  /**
   * The payment method subtype, e.g., EDDA_HK, CARD_GENERIC etc
   * @type {string}
   * @memberof AvailablePaymentMethod
   */
  payment_method_subtype?: string;
  /**
   *
   * @type {boolean}
   * @memberof AvailablePaymentMethod
   */
  recurring: boolean;
  /**
   *
   * @type {string}
   * @memberof AvailablePaymentMethod
   */
  fee?: string;
  /**
   *
   * @type {string}
   * @memberof AvailablePaymentMethod
   */
  payment_method_provider?: string;
}
/**
 *
 * @export
 * @interface AvailablePaymentMethodsFvLinkResponse
 */
export interface AvailablePaymentMethodsFvLinkResponse {
  /**
   *
   * @type {Array<AvailablePaymentMethod>}
   * @memberof AvailablePaymentMethodsFvLinkResponse
   */
  available_payment_methods?: Array<AvailablePaymentMethod>;
}
/**
 *
 * @export
 * @interface BadRequestModel
 */
export interface BadRequestModel {
  /**
   *
   * @type {BadRequestModelError}
   * @memberof BadRequestModel
   */
  error?: BadRequestModelError;
}
/**
 *
 * @export
 * @interface BadRequestModelError
 */
export interface BadRequestModelError {
  /**
   *
   * @type {number}
   * @memberof BadRequestModelError
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof BadRequestModelError
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof BadRequestModelError
   */
  message?: string;
  /**
   * A link to visit for further action
   * @type {string}
   * @memberof BadRequestModelError
   */
  link?: string;
}
/**
 *
 * @export
 * @interface BadRequestModelV2
 */
export interface BadRequestModelV2 {
  /**
   *
   * @type {BadRequestModelV2Error}
   * @memberof BadRequestModelV2
   */
  error?: BadRequestModelV2Error;
}
/**
 *
 * @export
 * @interface BadRequestModelV2Error
 */
export interface BadRequestModelV2Error {
  /**
   * The error type
   * @type {string}
   * @memberof BadRequestModelV2Error
   */
  type: BadRequestModelV2ErrorTypeEnum;
  /**
   *
   * @type {string}
   * @memberof BadRequestModelV2Error
   */
  error_code: string;
  /**
   *
   * @type {number}
   * @memberof BadRequestModelV2Error
   */
  code: number;
  /**
   *
   * @type {string}
   * @memberof BadRequestModelV2Error
   */
  message: string;
  /**
   *
   * @type {string}
   * @memberof BadRequestModelV2Error
   */
  details?: string;
  /**
   * The request_id provided in the request header
   * @type {string}
   * @memberof BadRequestModelV2Error
   */
  request_id: string;
}

export const BadRequestModelV2ErrorTypeEnum = {
  LinkError: 'LINK_ERROR',
  ApiError: 'API_ERROR',
} as const;

export type BadRequestModelV2ErrorTypeEnum =
  (typeof BadRequestModelV2ErrorTypeEnum)[keyof typeof BadRequestModelV2ErrorTypeEnum];

/**
 *
 * @export
 * @interface BalanceHistory
 */
export interface BalanceHistory {
  /**
   * The date the balance was recorded
   * @type {string}
   * @memberof BalanceHistory
   */
  date: string;
  /**
   * The end of day balance for this account on this specific date
   * @type {number}
   * @memberof BalanceHistory
   */
  amount: number;
  /**
   * The currency the balance
   * @type {string}
   * @memberof BalanceHistory
   */
  currency: string;
}
/**
 *
 * @export
 * @interface CardAccount
 */
export interface CardAccount {
  /**
   * Account this card is associated with
   * @type {string}
   * @memberof CardAccount
   */
  account_id?: string;
  /**
   *
   * @type {string}
   * @memberof CardAccount
   */
  account_name?: string;
  /**
   * Masked Account number of the card account
   * @type {string}
   * @memberof CardAccount
   */
  account_number_masked?: string;
  /**
   *
   * @type {AccountType}
   * @memberof CardAccount
   */
  account_type?: AccountType;
  /**
   * The statement payment due date
   * @type {string}
   * @memberof CardAccount
   */
  statement_payment_due_date?: string;
  /**
   * The next payment due date
   * @type {string}
   * @memberof CardAccount
   */
  next_payment_due_date?: string;
  /**
   * The statement date
   * @type {string}
   * @memberof CardAccount
   */
  statement_date?: string;
  /**
   * The date of the last payment
   * @type {string}
   * @memberof CardAccount
   */
  last_payment_date?: string;
  /**
   *
   * @type {CurrencyAmount}
   * @memberof CardAccount
   */
  last_payment_amount?: CurrencyAmount;
  /**
   *
   * @type {CurrencyAmount}
   * @memberof CardAccount
   */
  current_balance?: CurrencyAmount;
  /**
   *
   * @type {CurrencyAmount}
   * @memberof CardAccount
   */
  payment_due_amount?: CurrencyAmount;
  /**
   *
   * @type {CurrencyAmount}
   * @memberof CardAccount
   */
  statement_due_amount?: CurrencyAmount;
  /**
   *
   * @type {CurrencyAmount}
   * @memberof CardAccount
   */
  total_credit_limit?: CurrencyAmount;
  /**
   *
   * @type {CurrencyAmount}
   * @memberof CardAccount
   */
  available_credit_limit?: CurrencyAmount;
  /**
   *
   * @type {CurrencyAmount}
   * @memberof CardAccount
   */
  minimum_payment_due?: CurrencyAmount;
  /**
   *
   * @type {Array<GenericAmount>}
   * @memberof CardAccount
   */
  rewards_balances?: Array<GenericAmount>;
  /**
   *
   * @type {string}
   * @memberof CardAccount
   */
  updated_at?: string;
}
/**
 *
 * @export
 * @interface CardDetails
 */
export interface CardDetails {
  /**
   *
   * @type {Array<CardAccount>}
   * @memberof CardDetails
   */
  card_accounts?: Array<CardAccount>;
  /**
   *
   * @type {CardTotal}
   * @memberof CardDetails
   */
  card_total?: CardTotal;
}
/**
 *
 * @export
 * @interface CardFvLinkDetails
 */
export interface CardFvLinkDetails {
  /**
   * The credit card brand
   * @type {string}
   * @memberof CardFvLinkDetails
   */
  brand?: string;
  /**
   * Last 4 digits of the credit card number
   * @type {string}
   * @memberof CardFvLinkDetails
   */
  last4?: string;
  /**
   * The credit card expiry month
   * @type {number}
   * @memberof CardFvLinkDetails
   */
  expiry_month?: number;
  /**
   * The credit card expiry year
   * @type {number}
   * @memberof CardFvLinkDetails
   */
  expiry_year?: number;
  /**
   *
   * @type {string}
   * @memberof CardFvLinkDetails
   */
  collection_entity_name?: string;
}
/**
 *
 * @export
 * @interface CardFvLinkResponse
 */
export interface CardFvLinkResponse {
  /**
   *
   * @type {string}
   * @memberof CardFvLinkResponse
   */
  status?: CardFvLinkResponseStatusEnum;
  /**
   *
   * @type {CardFvLinkDetails}
   * @memberof CardFvLinkResponse
   */
  card_details?: CardFvLinkDetails;
  /**
   *
   * @type {CardRecipient}
   * @memberof CardFvLinkResponse
   */
  recipient?: CardRecipient;
  /**
   *
   * @type {FvEmbeddedErrorModel}
   * @memberof CardFvLinkResponse
   */
  error?: FvEmbeddedErrorModel;
}

export const CardFvLinkResponseStatusEnum = {
  Unknown: 'UNKNOWN',
  Processing: 'PROCESSING',
  Succeeded: 'SUCCEEDED',
  Cancelled: 'CANCELLED',
  Failed: 'FAILED',
} as const;

export type CardFvLinkResponseStatusEnum =
  (typeof CardFvLinkResponseStatusEnum)[keyof typeof CardFvLinkResponseStatusEnum];

/**
 *
 * @export
 * @interface CardRecipient
 */
export interface CardRecipient {
  /**
   * Merchant account name
   * @type {string}
   * @memberof CardRecipient
   */
  name?: string;
}
/**
 *
 * @export
 * @interface CardTotal
 */
export interface CardTotal {
  /**
   *
   * @type {CurrencyAmount}
   * @memberof CardTotal
   */
  current_balance?: CurrencyAmount;
  /**
   *
   * @type {CurrencyAmount}
   * @memberof CardTotal
   */
  payment_due_amount?: CurrencyAmount;
  /**
   *
   * @type {CurrencyAmount}
   * @memberof CardTotal
   */
  statement_due_amount?: CurrencyAmount;
  /**
   *
   * @type {CurrencyAmount}
   * @memberof CardTotal
   */
  total_credit_limit?: CurrencyAmount;
  /**
   *
   * @type {CurrencyAmount}
   * @memberof CardTotal
   */
  available_credit_limit?: CurrencyAmount;
  /**
   *
   * @type {CurrencyAmount}
   * @memberof CardTotal
   */
  minimum_payment_due?: CurrencyAmount;
  /**
   *
   * @type {Array<GenericAmount>}
   * @memberof CardTotal
   */
  rewards_balances?: Array<GenericAmount>;
  /**
   *
   * @type {string}
   * @memberof CardTotal
   */
  updated_at?: string;
}
/**
 *
 * @export
 * @interface CategoryPredictions
 */
export interface CategoryPredictions {
  /**
   *
   * @type {Array<string>}
   * @memberof CategoryPredictions
   */
  categories?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof CategoryPredictions
   */
  source?: string;
  /**
   *
   * @type {string}
   * @memberof CategoryPredictions
   */
  source_id?: string;
}
/**
 *
 * @export
 * @interface ChangePaymentMethodFvLinkResponse
 */
export interface ChangePaymentMethodFvLinkResponse {
  /**
   *
   * @type {string}
   * @memberof ChangePaymentMethodFvLinkResponse
   */
  redirect_url?: string;
}
/**
 *
 * @export
 * @interface CompleteKcpPaymentRequest
 */
export interface CompleteKcpPaymentRequest {
  /**
   *
   * @type {string}
   * @memberof CompleteKcpPaymentRequest
   */
  lang?: string;
  /**
   * Result code, \"0000\" if the payment is successful
   * @type {string}
   * @memberof CompleteKcpPaymentRequest
   */
  res_cd?: string;
  /**
   * Result message
   * @type {string}
   * @memberof CompleteKcpPaymentRequest
   */
  res_msg?: string;
  /**
   * Buyer\'s mail
   * @type {string}
   * @memberof CompleteKcpPaymentRequest
   */
  buyr_mail?: string;
  /**
   * Transaction code
   * @type {string}
   * @memberof CompleteKcpPaymentRequest
   */
  tran_cd: string;
  /**
   * Trace number
   * @type {string}
   * @memberof CompleteKcpPaymentRequest
   */
  trace_no?: string;
  /**
   *
   * @type {string}
   * @memberof CompleteKcpPaymentRequest
   */
  ret_pay_method?: string;
  /**
   *
   * @type {string}
   * @memberof CompleteKcpPaymentRequest
   */
  use_pay_method?: string;
  /**
   *
   * @type {string}
   * @memberof CompleteKcpPaymentRequest
   */
  enc_data: string;
  /**
   *
   * @type {string}
   * @memberof CompleteKcpPaymentRequest
   */
  enc_info: string;
  /**
   * FV Payment ID
   * @type {string}
   * @memberof CompleteKcpPaymentRequest
   */
  ordr_idxx: string;
  /**
   * Card payment method
   * @type {string}
   * @memberof CompleteKcpPaymentRequest
   */
  card_pay_method?: string;
  /**
   * If card point is used
   * @type {string}
   * @memberof CompleteKcpPaymentRequest
   */
  card_point_use?: CompleteKcpPaymentRequestCardPointUseEnum;
  /**
   * KCP select card code
   * @type {string}
   * @memberof CompleteKcpPaymentRequest
   */
  kcp_select_card_code?: string;
  /**
   * In the format of \"[FV Payment ID]|[Amount]\"
   * @type {string}
   * @memberof CompleteKcpPaymentRequest
   */
  ordr_chk?: string;
}

export const CompleteKcpPaymentRequestCardPointUseEnum = {
  Y: 'Y',
  N: 'N',
} as const;

export type CompleteKcpPaymentRequestCardPointUseEnum =
  (typeof CompleteKcpPaymentRequestCardPointUseEnum)[keyof typeof CompleteKcpPaymentRequestCardPointUseEnum];

/**
 *
 * @export
 * @interface CompleteKcpPaymentResponse
 */
export interface CompleteKcpPaymentResponse {
  /**
   * retryUrl from the token\'s claims
   * @type {string}
   * @memberof CompleteKcpPaymentResponse
   */
  redirect: string;
}
/**
 *
 * @export
 * @interface CompositeStatementLink
 */
export interface CompositeStatementLink {
  /**
   * signedURL to download statement
   * @type {string}
   * @memberof CompositeStatementLink
   */
  url: string;
  /**
   * expiry of the signedURL
   * @type {string}
   * @memberof CompositeStatementLink
   */
  expiry: string;
}
/**
 *
 * @export
 * @interface ConfirmPaymentResponse
 */
export interface ConfirmPaymentResponse {
  /**
   *
   * @type {boolean}
   * @memberof ConfirmPaymentResponse
   */
  success: boolean;
}
/**
 *
 * @export
 * @interface CreateCardRequest
 */
export interface CreateCardRequest {
  /**
   *
   * @type {CreateCardRequestCardDetails}
   * @memberof CreateCardRequest
   */
  card_details: CreateCardRequestCardDetails;
  /**
   *
   * @type {MandateRecipientRequest}
   * @memberof CreateCardRequest
   */
  recipient_account: MandateRecipientRequest;
  /**
   *
   * @type {string}
   * @memberof CreateCardRequest
   */
  status: CreateCardRequestStatusEnum;
}

export const CreateCardRequestStatusEnum = {
  Succeeded: 'SUCCEEDED',
} as const;

export type CreateCardRequestStatusEnum =
  (typeof CreateCardRequestStatusEnum)[keyof typeof CreateCardRequestStatusEnum];

/**
 *
 * @export
 * @interface CreateCardRequestCardDetails
 */
export interface CreateCardRequestCardDetails {
  /**
   *
   * @type {string}
   * @memberof CreateCardRequestCardDetails
   */
  brand: string;
  /**
   *
   * @type {string}
   * @memberof CreateCardRequestCardDetails
   */
  last4: string;
  /**
   *
   * @type {string}
   * @memberof CreateCardRequestCardDetails
   */
  currency: string;
  /**
   *
   * @type {number}
   * @memberof CreateCardRequestCardDetails
   */
  expiry_month?: number;
  /**
   *
   * @type {number}
   * @memberof CreateCardRequestCardDetails
   */
  expiry_year?: number;
}
/**
 *
 * @export
 * @interface CreateMandateRequest
 */
export interface CreateMandateRequest {
  /**
   *
   * @type {MandateRecipientRequest}
   * @memberof CreateMandateRequest
   */
  recipient_account: MandateRecipientRequest;
  /**
   *
   * @type {CreateMandateSender}
   * @memberof CreateMandateRequest
   */
  sender: CreateMandateSender;
  /**
   *
   * @type {MandateDetailsRequest}
   * @memberof CreateMandateRequest
   */
  mandate_details: MandateDetailsRequest;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof CreateMandateRequest
   */
  metadata?: { [key: string]: string };
}
/**
 *
 * @export
 * @interface CreateMandateRequestWithDdaReference
 */
export interface CreateMandateRequestWithDdaReference {
  /**
   *
   * @type {MandateRecipientRequest}
   * @memberof CreateMandateRequestWithDdaReference
   */
  recipient_account: MandateRecipientRequest;
  /**
   *
   * @type {MandateSenderAccountRequest}
   * @memberof CreateMandateRequestWithDdaReference
   */
  sender_account: MandateSenderAccountRequest;
  /**
   *
   * @type {MandateDetailsRequestWithDdaReference}
   * @memberof CreateMandateRequestWithDdaReference
   */
  mandate_details: MandateDetailsRequestWithDdaReference;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof CreateMandateRequestWithDdaReference
   */
  metadata?: { [key: string]: string };
  /**
   * The mandate status
   * @type {string}
   * @memberof CreateMandateRequestWithDdaReference
   */
  status: CreateMandateRequestWithDdaReferenceStatusEnum;
}

export const CreateMandateRequestWithDdaReferenceStatusEnum = {
  Succeeded: 'SUCCEEDED',
} as const;

export type CreateMandateRequestWithDdaReferenceStatusEnum =
  (typeof CreateMandateRequestWithDdaReferenceStatusEnum)[keyof typeof CreateMandateRequestWithDdaReferenceStatusEnum];

/**
 *
 * @export
 * @interface CreateMandateResponse
 */
export interface CreateMandateResponse {
  /**
   * Timestamp in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
   * @type {string}
   * @memberof CreateMandateResponse
   */
  created_at?: string;
  /**
   * Timestamp in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
   * @type {string}
   * @memberof CreateMandateResponse
   */
  updated_at: string;
  /**
   * Finverse Mandate ID (ULID)
   * @type {string}
   * @memberof CreateMandateResponse
   */
  mandate_id: string;
  /**
   * Finverse Payment Method ID (ULID)
   * @type {string}
   * @memberof CreateMandateResponse
   */
  payment_method_id?: string;
  /**
   * Mandate status
   * @type {string}
   * @memberof CreateMandateResponse
   */
  status: CreateMandateResponseStatusEnum;
  /**
   *
   * @type {MandateRecipient}
   * @memberof CreateMandateResponse
   */
  recipient: MandateRecipient;
  /**
   *
   * @type {MandateRecipientAccount}
   * @memberof CreateMandateResponse
   */
  recipient_account?: MandateRecipientAccount;
  /**
   *
   * @type {GetMandateSender}
   * @memberof CreateMandateResponse
   */
  sender: GetMandateSender;
  /**
   *
   * @type {MandateSenderAccount}
   * @memberof CreateMandateResponse
   */
  sender_account?: MandateSenderAccount;
  /**
   *
   * @type {MandateDetailsResponse}
   * @memberof CreateMandateResponse
   */
  mandate_details: MandateDetailsResponse;
  /**
   *
   * @type {Array<Fee>}
   * @memberof CreateMandateResponse
   */
  fees?: Array<Fee>;
  /**
   * Additional attributes of the mandate in key:value format (e.g. mandate_internal_id: 1234). It supports up to 10 key:value pairs, whereas the key and value supports up to 50 and 1000 characters respectively.
   * @type {{ [key: string]: string; }}
   * @memberof CreateMandateResponse
   */
  metadata?: { [key: string]: string };
  /**
   *
   * @type {FvEmbeddedErrorModel}
   * @memberof CreateMandateResponse
   */
  error?: FvEmbeddedErrorModel;
}

export const CreateMandateResponseStatusEnum = {
  AuthorizationRequired: 'AUTHORIZATION_REQUIRED',
  Authorizing: 'AUTHORIZING',
  Processing: 'PROCESSING',
  Submitted: 'SUBMITTED',
  Succeeded: 'SUCCEEDED',
  Failed: 'FAILED',
  Revoked: 'REVOKED',
  ReadyToSubmit: 'READY_TO_SUBMIT',
  Closed: 'CLOSED',
  Cancelled: 'CANCELLED',
} as const;

export type CreateMandateResponseStatusEnum =
  (typeof CreateMandateResponseStatusEnum)[keyof typeof CreateMandateResponseStatusEnum];

/**
 *
 * @export
 * @interface CreateMandateSender
 */
export interface CreateMandateSender {
  /**
   *
   * @type {string}
   * @memberof CreateMandateSender
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof CreateMandateSender
   */
  email: string;
  /**
   * Customer App\'s user ID, representing the end-user making the payment.
   * @type {string}
   * @memberof CreateMandateSender
   */
  external_user_id?: string;
  /**
   * Type of account held by the Sender at the Institution. Possible values are INDIVIDUAL, BUSINESS
   * @type {string}
   * @memberof CreateMandateSender
   */
  user_type?: CreateMandateSenderUserTypeEnum;
  /**
   * Sender details which will be used for fraud checking.
   * @type {Array<SenderDetail>}
   * @memberof CreateMandateSender
   */
  user_details?: Array<SenderDetail>;
}

export const CreateMandateSenderUserTypeEnum = {
  Individual: 'INDIVIDUAL',
  Business: 'BUSINESS',
} as const;

export type CreateMandateSenderUserTypeEnum =
  (typeof CreateMandateSenderUserTypeEnum)[keyof typeof CreateMandateSenderUserTypeEnum];

/**
 *
 * @export
 * @interface CreateMandateWithSenderAccountRequest
 */
export interface CreateMandateWithSenderAccountRequest {
  /**
   *
   * @type {MandateRecipientRequest}
   * @memberof CreateMandateWithSenderAccountRequest
   */
  recipient_account: MandateRecipientRequest;
  /**
   *
   * @type {MandateSenderAccountRequest}
   * @memberof CreateMandateWithSenderAccountRequest
   */
  sender_account: MandateSenderAccountRequest;
  /**
   *
   * @type {MandateDetailsRequest}
   * @memberof CreateMandateWithSenderAccountRequest
   */
  mandate_details: MandateDetailsRequest;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof CreateMandateWithSenderAccountRequest
   */
  metadata?: { [key: string]: string };
}
/**
 *
 * @export
 * @interface CreatePaymentAccountRequest
 */
export interface CreatePaymentAccountRequest {
  /**
   *
   * @type {RecipientAccountNumber}
   * @memberof CreatePaymentAccountRequest
   */
  account_number: RecipientAccountNumber;
  /**
   * Type of payment account. Currently only allow creating external account.
   * @type {string}
   * @memberof CreatePaymentAccountRequest
   */
  account_type: CreatePaymentAccountRequestAccountTypeEnum;
  /**
   * Accountholder name of the payment account
   * @type {string}
   * @memberof CreatePaymentAccountRequest
   */
  accountholder_name: string;
  /**
   * List of currencies supported by the payment account
   * @type {Array<string>}
   * @memberof CreatePaymentAccountRequest
   */
  currencies?: Array<string>;
  /**
   * Finverse Institution ID for the payment institution.
   * @type {string}
   * @memberof CreatePaymentAccountRequest
   */
  institution_id: string;
  /**
   * A unique identifier generated after creating user (Finverse Payment User ID)
   * @type {string}
   * @memberof CreatePaymentAccountRequest
   */
  user_id: string;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof CreatePaymentAccountRequest
   */
  metadata?: { [key: string]: string };
}

export const CreatePaymentAccountRequestAccountTypeEnum = {
  ExternalAccount: 'EXTERNAL_ACCOUNT',
} as const;

export type CreatePaymentAccountRequestAccountTypeEnum =
  (typeof CreatePaymentAccountRequestAccountTypeEnum)[keyof typeof CreatePaymentAccountRequestAccountTypeEnum];

/**
 *
 * @export
 * @interface CreatePaymentInstructionResponse
 */
export interface CreatePaymentInstructionResponse {
  /**
   *
   * @type {string}
   * @memberof CreatePaymentInstructionResponse
   */
  payment_instruction_id?: string;
}
/**
 *
 * @export
 * @interface CreatePaymentLinkRequest
 */
export interface CreatePaymentLinkRequest {
  /**
   * The amount of the payment. Expressed in currency\'s smallest unit or “minor unit”, as defined in ISO 4217.
   * @type {number}
   * @memberof CreatePaymentLinkRequest
   */
  amount?: number;
  /**
   *
   * @type {string}
   * @memberof CreatePaymentLinkRequest
   */
  currency: string;
  /**
   *
   * @type {PaymentLinkCustomizations}
   * @memberof CreatePaymentLinkRequest
   */
  link_customizations?: PaymentLinkCustomizations;
  /**
   * The payment link mode
   * @type {string}
   * @memberof CreatePaymentLinkRequest
   */
  mode: CreatePaymentLinkRequestModeEnum;
  /**
   *
   * @type {PaymentLinkDetails}
   * @memberof CreatePaymentLinkRequest
   */
  payment_details?: PaymentLinkDetails;
  /**
   *
   * @type {PaymentLinkSender}
   * @memberof CreatePaymentLinkRequest
   */
  sender: PaymentLinkSender;
  /**
   * Unique reference id to identifying the payment to be collected.
   * @type {string}
   * @memberof CreatePaymentLinkRequest
   */
  unique_reference_id: string;
  /**
   *
   * @type {PaymentSetupOptionsRequest}
   * @memberof CreatePaymentLinkRequest
   */
  payment_setup_options?: PaymentSetupOptionsRequest;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof CreatePaymentLinkRequest
   */
  metadata?: { [key: string]: string };
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof CreatePaymentLinkRequest
   */
  payment_metadata?: { [key: string]: string };
  /**
   *
   * @type {IntegrationMetadataRequest}
   * @memberof CreatePaymentLinkRequest
   */
  integration_metadata?: IntegrationMetadataRequest;
}

export const CreatePaymentLinkRequestModeEnum = {
  Payment: 'PAYMENT',
  Setup: 'SETUP',
} as const;

export type CreatePaymentLinkRequestModeEnum =
  (typeof CreatePaymentLinkRequestModeEnum)[keyof typeof CreatePaymentLinkRequestModeEnum];

/**
 *
 * @export
 * @interface CreatePaymentMethodRequest
 */
export interface CreatePaymentMethodRequest {
  /**
   *
   * @type {CreateCardRequest}
   * @memberof CreatePaymentMethodRequest
   */
  card?: CreateCardRequest;
  /**
   *
   * @type {CreateMandateRequestWithDdaReference}
   * @memberof CreatePaymentMethodRequest
   */
  mandate?: CreateMandateRequestWithDdaReference;
  /**
   *
   * @type {PaymentMethodIntegrationMetadata}
   * @memberof CreatePaymentMethodRequest
   */
  integration_metadata?: PaymentMethodIntegrationMetadata;
  /**
   *
   * @type {string}
   * @memberof CreatePaymentMethodRequest
   */
  payment_method_type: CreatePaymentMethodRequestPaymentMethodTypeEnum;
}

export const CreatePaymentMethodRequestPaymentMethodTypeEnum = {
  Card: 'CARD',
  Mandate: 'MANDATE',
} as const;

export type CreatePaymentMethodRequestPaymentMethodTypeEnum =
  (typeof CreatePaymentMethodRequestPaymentMethodTypeEnum)[keyof typeof CreatePaymentMethodRequestPaymentMethodTypeEnum];

/**
 *
 * @export
 * @interface CreatePaymentRequest
 */
export interface CreatePaymentRequest {
  /**
   * Amount to be paid, in currency\'s smallest unit or “minor unit”, as defined in ISO 4217. For example, HKD 100.01 is represented as amount = 10001 (minor unit = cents). For currencies without minor units (e.g. VND, JPY), the amount is represented as is, without modification. For example, VND 15101 is represented as amount = 15101.
   * @type {number}
   * @memberof CreatePaymentRequest
   */
  amount: number;
  /**
   * The currency code as defined in ISO 4217.
   * @type {string}
   * @memberof CreatePaymentRequest
   */
  currency: string;
  /**
   * ID of the payment method this pament is referring to.
   * @type {string}
   * @memberof CreatePaymentRequest
   */
  payment_method_id?: string;
  /**
   *
   * @type {PaymentDetails2}
   * @memberof CreatePaymentRequest
   */
  payment_details: PaymentDetails2;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof CreatePaymentRequest
   */
  metadata?: { [key: string]: string };
}
/**
 *
 * @export
 * @interface CreatePaymentUserRequest
 */
export interface CreatePaymentUserRequest {
  /**
   *
   * @type {string}
   * @memberof CreatePaymentUserRequest
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof CreatePaymentUserRequest
   */
  external_user_id: string;
  /**
   *
   * @type {string}
   * @memberof CreatePaymentUserRequest
   */
  user_type?: CreatePaymentUserRequestUserTypeEnum;
  /**
   *
   * @type {string}
   * @memberof CreatePaymentUserRequest
   */
  email?: string;
  /**
   *
   * @type {Array<SenderDetail>}
   * @memberof CreatePaymentUserRequest
   */
  user_details?: Array<SenderDetail>;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof CreatePaymentUserRequest
   */
  metadata?: { [key: string]: string };
  /**
   *
   * @type {boolean}
   * @memberof CreatePaymentUserRequest
   */
  autopay_consent?: boolean;
  /**
   *
   * @type {IntegrationMetadataRequest}
   * @memberof CreatePaymentUserRequest
   */
  integration_metadata?: IntegrationMetadataRequest;
}

export const CreatePaymentUserRequestUserTypeEnum = {
  Individual: 'INDIVIDUAL',
  Business: 'BUSINESS',
} as const;

export type CreatePaymentUserRequestUserTypeEnum =
  (typeof CreatePaymentUserRequestUserTypeEnum)[keyof typeof CreatePaymentUserRequestUserTypeEnum];

/**
 *
 * @export
 * @interface CreateRecipientAccount
 */
export interface CreateRecipientAccount {
  /**
   * Accountholder name of the recipient\'s account
   * @type {string}
   * @memberof CreateRecipientAccount
   */
  accountholder_name: string;
  /**
   *
   * @type {RecipientAccountNumber}
   * @memberof CreateRecipientAccount
   */
  account_number: RecipientAccountNumber;
  /**
   * Type of recipient account.
   * @type {string}
   * @memberof CreateRecipientAccount
   */
  account_type: CreateRecipientAccountAccountTypeEnum;
  /**
   * List of currencies supported by the recipient account
   * @type {Array<string>}
   * @memberof CreateRecipientAccount
   */
  currencies: Array<string>;
  /**
   * Finverse Institution ID for the recipient’s institution.
   * @type {string}
   * @memberof CreateRecipientAccount
   */
  institution_id: string;
}

export const CreateRecipientAccountAccountTypeEnum = {
  ExternalAccount: 'EXTERNAL_ACCOUNT',
} as const;

export type CreateRecipientAccountAccountTypeEnum =
  (typeof CreateRecipientAccountAccountTypeEnum)[keyof typeof CreateRecipientAccountAccountTypeEnum];

/**
 *
 * @export
 * @interface CreateScheduledPayoutRequest
 */
export interface CreateScheduledPayoutRequest {
  /**
   * Amount to be paid, in currency\'s smallest unit or “minor unit”, as defined in ISO 4217. For example, HKD 100.01 is represented as amount = 10001 (minor unit = cents). For currencies without minor units (e.g. VND, JPY), the amount is represented as is, without modification. For example, VND 15101 is represented as amount = 15101.
   * @type {number}
   * @memberof CreateScheduledPayoutRequest
   */
  amount: number;
  /**
   * The currency code as defined in ISO 4217.
   * @type {string}
   * @memberof CreateScheduledPayoutRequest
   */
  currency: string;
  /**
   *
   * @type {PayoutDetails}
   * @memberof CreateScheduledPayoutRequest
   */
  payment_details: PayoutDetails;
  /**
   *
   * @type {MandateRecipientRequest}
   * @memberof CreateScheduledPayoutRequest
   */
  recipient_account: MandateRecipientRequest;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof CreateScheduledPayoutRequest
   */
  metadata?: { [key: string]: string };
}
/**
 *
 * @export
 * @interface CurrencyAmount
 */
export interface CurrencyAmount {
  /**
   *
   * @type {string}
   * @memberof CurrencyAmount
   */
  currency?: string;
  /**
   *
   * @type {number}
   * @memberof CurrencyAmount
   */
  value: number;
  /**
   *
   * @type {string}
   * @memberof CurrencyAmount
   */
  raw?: string;
}
/**
 *
 * @export
 * @interface CustomerPaymentInstruction
 */
export interface CustomerPaymentInstruction {
  /**
   * A id of the user of this payment, need to equal to userId when creating link
   * @type {string}
   * @memberof CustomerPaymentInstruction
   */
  user_id: string;
  /**
   * Type of payment is being created, please check Documentation on which payment type is supported in each institution
   * @type {string}
   * @memberof CustomerPaymentInstruction
   */
  type: CustomerPaymentInstructionTypeEnum;
  /**
   * The recipient name
   * @type {string}
   * @memberof CustomerPaymentInstruction
   */
  recipient_name?: string;
  /**
   * The recipient account Id
   * @type {string}
   * @memberof CustomerPaymentInstruction
   */
  recipient_account_id?: string;
  /**
   * The sender name
   * @type {string}
   * @memberof CustomerPaymentInstruction
   */
  sender_name?: string;
  /**
   * The sender account Id
   * @type {string}
   * @memberof CustomerPaymentInstruction
   */
  sender_account_id?: string;
  /**
   * When the payment should start
   * @type {string}
   * @memberof CustomerPaymentInstruction
   */
  start_date?: string | null;
  /**
   * When the payment should stop
   * @type {string}
   * @memberof CustomerPaymentInstruction
   */
  end_date?: string | null;
  /**
   * The currency for the payment
   * @type {string}
   * @memberof CustomerPaymentInstruction
   */
  currency?: string;
  /**
   * The payment amount
   * @type {number}
   * @memberof CustomerPaymentInstruction
   */
  amount?: number;
  /**
   * How often the payment should be executed
   * @type {string}
   * @memberof CustomerPaymentInstruction
   */
  frequency?: string;
  /**
   * Related remarks about this instruction
   * @type {string}
   * @memberof CustomerPaymentInstruction
   */
  remarks?: string;
}

export const CustomerPaymentInstructionTypeEnum = {
  DebitAuthorization: 'DEBIT_AUTHORIZATION',
} as const;

export type CustomerPaymentInstructionTypeEnum =
  (typeof CustomerPaymentInstructionTypeEnum)[keyof typeof CustomerPaymentInstructionTypeEnum];

/**
 *
 * @export
 * @interface DeleteLoginIdentityResponse
 */
export interface DeleteLoginIdentityResponse {
  /**
   *
   * @type {boolean}
   * @memberof DeleteLoginIdentityResponse
   */
  success?: boolean;
}
/**
 *
 * @export
 * @interface DisputeResponse
 */
export interface DisputeResponse {
  /**
   * The dispute id
   * @type {string}
   * @memberof DisputeResponse
   */
  dispute_id?: string;
  /**
   * Amount to be disputed, in currency\'s smallest unit or “minor unit”, as defined in ISO 4217. For example, HKD 100.01 is represented as amount = 10001 (minor unit = cents). For currencies without minor units (e.g. VND, JPY), the amount is represented as is, without modification. For example, VND 15101 is represented as amount = 15101.
   * @type {number}
   * @memberof DisputeResponse
   */
  amount?: number;
  /**
   * The currency of the balance
   * @type {string}
   * @memberof DisputeResponse
   */
  currency?: string;
  /**
   * The name of the last event for this dispute
   * @type {string}
   * @memberof DisputeResponse
   */
  last_event_name?: string;
  /**
   * The payment id
   * @type {string}
   * @memberof DisputeResponse
   */
  payment_id?: string;
  /**
   * The payment processor handling the dispute
   * @type {string}
   * @memberof DisputeResponse
   */
  payment_processor?: string;
  /**
   *
   * @type {string}
   * @memberof DisputeResponse
   */
  payment_processor_merchant_reference?: string;
  /**
   * The payment reference for the disputed transaction
   * @type {string}
   * @memberof DisputeResponse
   */
  payment_reference?: string;
  /**
   * The payment processor\'s payment reference
   * @type {string}
   * @memberof DisputeResponse
   */
  payment_processor_payment_reference?: string;
  /**
   *
   * @type {DisputeResponseCardDetails}
   * @memberof DisputeResponse
   */
  card_details?: DisputeResponseCardDetails;
  /**
   * The payment processor\'s dispute reference
   * @type {string}
   * @memberof DisputeResponse
   */
  payment_processor_dispute_reference?: string;
  /**
   * The reason for the dispute as provided by the payment processor
   * @type {string}
   * @memberof DisputeResponse
   */
  payment_processor_dispute_reason?: string;
  /**
   * Acquirer Reference Number
   * @type {string}
   * @memberof DisputeResponse
   */
  arn?: string;
  /**
   * The dispute code from the payment processor
   * @type {string}
   * @memberof DisputeResponse
   */
  payment_processor_dispute_code?: string;
  /**
   * Whether the dispute is defendable
   * @type {boolean}
   * @memberof DisputeResponse
   */
  is_defendable?: boolean | null;
  /**
   * The status of the dispute
   * @type {string}
   * @memberof DisputeResponse
   */
  dispute_status?: DisputeResponseDisputeStatusEnum;
  /**
   * The status of the dispute at the payment processor
   * @type {string}
   * @memberof DisputeResponse
   */
  payment_processor_dispute_status?: string;
  /**
   * Whether the dispute was automatically defended
   * @type {boolean}
   * @memberof DisputeResponse
   */
  is_auto_defended?: boolean | null;
  /**
   * Timestamp in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
   * @type {string}
   * @memberof DisputeResponse
   */
  defense_period_deadline?: string | null;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof DisputeResponse
   */
  issuer_comments?: { [key: string]: string };
  /**
   * Timestamp in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
   * @type {string}
   * @memberof DisputeResponse
   */
  created_at?: string;
  /**
   * Timestamp in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
   * @type {string}
   * @memberof DisputeResponse
   */
  updated_at?: string;
}

export const DisputeResponseDisputeStatusEnum = {
  Unknown: 'UNKNOWN',
  Undefended: 'UNDEFENDED',
  ActionRequired: 'ACTION_REQUIRED',
  Processing: 'PROCESSING',
  Accepted: 'ACCEPTED',
  Lost: 'LOST',
  Won: 'WON',
} as const;

export type DisputeResponseDisputeStatusEnum =
  (typeof DisputeResponseDisputeStatusEnum)[keyof typeof DisputeResponseDisputeStatusEnum];

/**
 *
 * @export
 * @interface DisputeResponseCardDetails
 */
export interface DisputeResponseCardDetails {
  /**
   *
   * @type {string}
   * @memberof DisputeResponseCardDetails
   */
  brand?: string;
}
/**
 *
 * @export
 * @interface DownloadBalanceStatementResponse
 */
export interface DownloadBalanceStatementResponse {
  /**
   * Signed URL to download the CSV from
   * @type {string}
   * @memberof DownloadBalanceStatementResponse
   */
  download_url: string;
}
/**
 *
 * @export
 * @interface EncryptedPayload
 */
export interface EncryptedPayload {
  /**
   * The credential payload encrypted with AES (base64)
   * @type {string}
   * @memberof EncryptedPayload
   */
  ciphertext: string;
  /**
   * The 16 byte IV used w/ AES (base64)
   * @type {string}
   * @memberof EncryptedPayload
   */
  initializationVector: string;
  /**
   * The MAC to verify AES decryption validity
   * @type {string}
   * @memberof EncryptedPayload
   */
  messageAuthenticationCode: string;
  /**
   * The AES key encrypted with an RSA pubkey (base64)
   * @type {string}
   * @memberof EncryptedPayload
   */
  envelopeEncryptionKey: string;
  /**
   * The identifier of the public key used to encrypt the AES key
   * @type {string}
   * @memberof EncryptedPayload
   */
  keyId: string;
}
/**
 *
 * @export
 * @interface ErrBodyModel
 */
export interface ErrBodyModel {
  /**
   *
   * @type {FvErrorModel}
   * @memberof ErrBodyModel
   */
  error?: FvErrorModel;
}
/**
 *
 * @export
 * @interface ErrBodyModelV2
 */
export interface ErrBodyModelV2 {
  /**
   *
   * @type {FvErrorModelV2}
   * @memberof ErrBodyModelV2
   */
  error?: FvErrorModelV2;
}
/**
 *
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
  /**
   *
   * @type {string}
   * @memberof ErrorResponse
   */
  err?: string;
  /**
   *
   * @type {number}
   * @memberof ErrorResponse
   */
  http_status_code?: number;
  /**
   *
   * @type {string}
   * @memberof ErrorResponse
   */
  status_text?: string;
  /**
   *
   * @type {number}
   * @memberof ErrorResponse
   */
  app_code?: number;
  /**
   *
   * @type {string}
   * @memberof ErrorResponse
   */
  error_category?: string;
  /**
   *
   * @type {string}
   * @memberof ErrorResponse
   */
  error_text?: string;
  /**
   *
   * @type {string}
   * @memberof ErrorResponse
   */
  request_id?: string;
}
/**
 *
 * @export
 * @interface FVCard
 */
export interface FVCard {
  /**
   * Timestamp in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
   * @type {string}
   * @memberof FVCard
   */
  created_at?: string;
  /**
   * Timestamp in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
   * @type {string}
   * @memberof FVCard
   */
  updated_at?: string;
  /**
   * Card Status
   * @type {string}
   * @memberof FVCard
   */
  status?: FVCardStatusEnum;
  /**
   *
   * @type {FvEmbeddedErrorModel}
   * @memberof FVCard
   */
  error?: FvEmbeddedErrorModel;
  /**
   *
   * @type {FVCardDetails}
   * @memberof FVCard
   */
  card_details?: FVCardDetails;
  /**
   *
   * @type {MandateRecipientAccount}
   * @memberof FVCard
   */
  recipient_account?: MandateRecipientAccount;
}

export const FVCardStatusEnum = {
  Unknown: 'UNKNOWN',
  Processing: 'PROCESSING',
  Succeeded: 'SUCCEEDED',
  Cancelled: 'CANCELLED',
  Failed: 'FAILED',
} as const;

export type FVCardStatusEnum = (typeof FVCardStatusEnum)[keyof typeof FVCardStatusEnum];

/**
 *
 * @export
 * @interface FVCardDetails
 */
export interface FVCardDetails {
  /**
   * The credit card brand
   * @type {string}
   * @memberof FVCardDetails
   */
  brand?: string;
  /**
   * Last 4 digits of the credit card number
   * @type {string}
   * @memberof FVCardDetails
   */
  last4?: string;
  /**
   * The credit card expiry month
   * @type {number}
   * @memberof FVCardDetails
   */
  expiry_month?: number;
  /**
   * The credit card expiry year
   * @type {number}
   * @memberof FVCardDetails
   */
  expiry_year?: number;
  /**
   *
   * @type {string}
   * @memberof FVCardDetails
   */
  processor_entity_name?: string;
  /**
   *
   * @type {string}
   * @memberof FVCardDetails
   */
  collection_entity_name?: string;
  /**
   *
   * @type {string}
   * @memberof FVCardDetails
   */
  country?: string;
  /**
   *
   * @type {string}
   * @memberof FVCardDetails
   */
  fingerprint?: string;
  /**
   *
   * @type {string}
   * @memberof FVCardDetails
   */
  funding?: FVCardDetailsFundingEnum;
  /**
   *
   * @type {string}
   * @memberof FVCardDetails
   */
  finverse_authorization_reference?: string;
  /**
   *
   * @type {FVCardProcessorDetails}
   * @memberof FVCardDetails
   */
  processor_details?: FVCardProcessorDetails;
  /**
   * The recurring payment mode
   * @type {string}
   * @memberof FVCardDetails
   */
  recurring_payment_mode?: string;
}

export const FVCardDetailsFundingEnum = {
  Unknown: 'UNKNOWN',
  Credit: 'CREDIT',
  Debit: 'DEBIT',
  Prepaid: 'PREPAID',
} as const;

export type FVCardDetailsFundingEnum = (typeof FVCardDetailsFundingEnum)[keyof typeof FVCardDetailsFundingEnum];

/**
 *
 * @export
 * @interface FVCardProcessorDetails
 */
export interface FVCardProcessorDetails {
  /**
   *
   * @type {string}
   * @memberof FVCardProcessorDetails
   */
  auth_code?: string;
  /**
   *
   * @type {string}
   * @memberof FVCardProcessorDetails
   */
  processor_id?: string;
  /**
   *
   * @type {string}
   * @memberof FVCardProcessorDetails
   */
  processor_reference?: string;
  /**
   *
   * @type {string}
   * @memberof FVCardProcessorDetails
   */
  token_id?: string;
  /**
   * The network transaction reference
   * @type {string}
   * @memberof FVCardProcessorDetails
   */
  network_transaction_reference?: string;
}
/**
 *
 * @export
 * @interface Fee
 */
export interface Fee {
  /**
   * The amount of fee for a single transaction. Expressed in currency\'s smallest unit or “minor unit”, as defined in ISO 4217.
   * @type {number}
   * @memberof Fee
   */
  amount: number;
  /**
   *
   * @type {string}
   * @memberof Fee
   */
  currency?: string;
  /**
   *
   * @type {string}
   * @memberof Fee
   */
  paid_by?: FeePaidByEnum;
  /**
   * The payment account Id
   * @type {string}
   * @memberof Fee
   */
  paid_by_account_id?: string;
}

export const FeePaidByEnum = {
  Recipient: 'RECIPIENT',
  Sender: 'SENDER',
} as const;

export type FeePaidByEnum = (typeof FeePaidByEnum)[keyof typeof FeePaidByEnum];

/**
 *
 * @export
 * @interface FpsQrCodeResponse
 */
export interface FpsQrCodeResponse {
  /**
   * The FPS QR code in base64
   * @type {string}
   * @memberof FpsQrCodeResponse
   */
  qr_code: string;
}
/**
 *
 * @export
 * @interface FvEmbeddedErrorModel
 */
export interface FvEmbeddedErrorModel {
  /**
   * The error type
   * @type {string}
   * @memberof FvEmbeddedErrorModel
   */
  type: FvEmbeddedErrorModelTypeEnum;
  /**
   *
   * @type {string}
   * @memberof FvEmbeddedErrorModel
   */
  error_code: string;
  /**
   *
   * @type {string}
   * @memberof FvEmbeddedErrorModel
   */
  message: string;
  /**
   *
   * @type {string}
   * @memberof FvEmbeddedErrorModel
   */
  details: string;
}

export const FvEmbeddedErrorModelTypeEnum = {
  LinkError: 'LINK_ERROR',
  ApiError: 'API_ERROR',
} as const;

export type FvEmbeddedErrorModelTypeEnum =
  (typeof FvEmbeddedErrorModelTypeEnum)[keyof typeof FvEmbeddedErrorModelTypeEnum];

/**
 *
 * @export
 * @interface FvErrorModel
 */
export interface FvErrorModel {
  /**
   * The error type
   * @type {string}
   * @memberof FvErrorModel
   */
  type: FvErrorModelTypeEnum;
  /**
   *
   * @type {string}
   * @memberof FvErrorModel
   */
  error_code: string;
  /**
   *
   * @type {string}
   * @memberof FvErrorModel
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof FvErrorModel
   */
  message: string;
  /**
   *
   * @type {string}
   * @memberof FvErrorModel
   */
  details: string;
  /**
   * The request_id provided in the request header
   * @type {string}
   * @memberof FvErrorModel
   */
  request_id: string;
}

export const FvErrorModelTypeEnum = {
  LinkError: 'LINK_ERROR',
  ApiError: 'API_ERROR',
} as const;

export type FvErrorModelTypeEnum = (typeof FvErrorModelTypeEnum)[keyof typeof FvErrorModelTypeEnum];

/**
 *
 * @export
 * @interface FvErrorModelV2
 */
export interface FvErrorModelV2 {
  /**
   * The error type
   * @type {string}
   * @memberof FvErrorModelV2
   */
  type: FvErrorModelV2TypeEnum;
  /**
   *
   * @type {string}
   * @memberof FvErrorModelV2
   */
  error_code: string;
  /**
   *
   * @type {string}
   * @memberof FvErrorModelV2
   */
  message: string;
  /**
   *
   * @type {string}
   * @memberof FvErrorModelV2
   */
  details: string;
  /**
   * The request_id provided in the request header
   * @type {string}
   * @memberof FvErrorModelV2
   */
  request_id: string;
}

export const FvErrorModelV2TypeEnum = {
  LinkError: 'LINK_ERROR',
  ApiError: 'API_ERROR',
} as const;

export type FvErrorModelV2TypeEnum = (typeof FvErrorModelV2TypeEnum)[keyof typeof FvErrorModelV2TypeEnum];

/**
 *
 * @export
 * @interface GenericAmount
 */
export interface GenericAmount {
  /**
   *
   * @type {string}
   * @memberof GenericAmount
   */
  unit?: string;
  /**
   *
   * @type {number}
   * @memberof GenericAmount
   */
  value: number;
  /**
   *
   * @type {string}
   * @memberof GenericAmount
   */
  raw?: string;
}
/**
 *
 * @export
 * @interface GetAccountNumberResponse
 */
export interface GetAccountNumberResponse {
  /**
   *
   * @type {AccountNumber}
   * @memberof GetAccountNumberResponse
   */
  account_number?: AccountNumber;
  /**
   *
   * @type {Account}
   * @memberof GetAccountNumberResponse
   */
  account?: Account;
  /**
   *
   * @type {LoginIdentityShort}
   * @memberof GetAccountNumberResponse
   */
  login_identity?: LoginIdentityShort;
  /**
   *
   * @type {InstitutionShort}
   * @memberof GetAccountNumberResponse
   */
  institution?: InstitutionShort;
  /**
   *
   * @type {Array<PaymentDetails>}
   * @memberof GetAccountNumberResponse
   */
  payment_details?: Array<PaymentDetails>;
}
/**
 *
 * @export
 * @interface GetAccountResponse
 */
export interface GetAccountResponse {
  /**
   *
   * @type {Account}
   * @memberof GetAccountResponse
   */
  account?: Account;
  /**
   *
   * @type {LoginIdentityShort}
   * @memberof GetAccountResponse
   */
  login_identity?: LoginIdentityShort;
  /**
   *
   * @type {InstitutionShort}
   * @memberof GetAccountResponse
   */
  institution?: InstitutionShort;
}
/**
 *
 * @export
 * @interface GetBalanceHistoryResponse
 */
export interface GetBalanceHistoryResponse {
  /**
   *
   * @type {Account}
   * @memberof GetBalanceHistoryResponse
   */
  account?: Account;
  /**
   *
   * @type {LoginIdentityShort}
   * @memberof GetBalanceHistoryResponse
   */
  login_identity?: LoginIdentityShort;
  /**
   *
   * @type {InstitutionShort}
   * @memberof GetBalanceHistoryResponse
   */
  institution?: InstitutionShort;
  /**
   *
   * @type {Array<BalanceHistory>}
   * @memberof GetBalanceHistoryResponse
   */
  balance_history?: Array<BalanceHistory>;
  /**
   *
   * @type {string}
   * @memberof GetBalanceHistoryResponse
   */
  source?: GetBalanceHistoryResponseSourceEnum;
}

export const GetBalanceHistoryResponseSourceEnum = {
  Institution: 'INSTITUTION',
  Computed: 'COMPUTED',
} as const;

export type GetBalanceHistoryResponseSourceEnum =
  (typeof GetBalanceHistoryResponseSourceEnum)[keyof typeof GetBalanceHistoryResponseSourceEnum];

/**
 *
 * @export
 * @interface GetIdentityResponse
 */
export interface GetIdentityResponse {
  /**
   *
   * @type {Identity}
   * @memberof GetIdentityResponse
   */
  identity?: Identity;
  /**
   *
   * @type {LoginIdentityShort}
   * @memberof GetIdentityResponse
   */
  login_identity?: LoginIdentityShort;
  /**
   *
   * @type {InstitutionShort}
   * @memberof GetIdentityResponse
   */
  institution?: InstitutionShort;
}
/**
 *
 * @export
 * @interface GetJWKSResponse
 */
export interface GetJWKSResponse {
  /**
   *
   * @type {Array<JWKSKey>}
   * @memberof GetJWKSResponse
   */
  keys?: Array<JWKSKey>;
}
/**
 *
 * @export
 * @interface GetLineItemsForDisplayResponseV2
 */
export interface GetLineItemsForDisplayResponseV2 {
  /**
   *
   * @type {Array<LineItem>}
   * @memberof GetLineItemsForDisplayResponseV2
   */
  line_items?: Array<LineItem>;
}
/**
 *
 * @export
 * @interface GetLoginIdentityByIdResponse
 */
export interface GetLoginIdentityByIdResponse {
  /**
   *
   * @type {LoginIdentity}
   * @memberof GetLoginIdentityByIdResponse
   */
  login_identity?: LoginIdentity;
  /**
   *
   * @type {InstitutionShort}
   * @memberof GetLoginIdentityByIdResponse
   */
  institution?: InstitutionShort;
}
/**
 *
 * @export
 * @interface GetLoginIdentityHistoryResponse
 */
export interface GetLoginIdentityHistoryResponse {
  /**
   *
   * @type {LoginIdentity}
   * @memberof GetLoginIdentityHistoryResponse
   */
  login_identity?: LoginIdentity;
  /**
   *
   * @type {Array<LoginIdentityStatusDetails>}
   * @memberof GetLoginIdentityHistoryResponse
   */
  status_history?: Array<LoginIdentityStatusDetails>;
}
/**
 *
 * @export
 * @interface GetMandateAuthLinkRequest
 */
export interface GetMandateAuthLinkRequest {
  /**
   * Mandate ID
   * @type {string}
   * @memberof GetMandateAuthLinkRequest
   */
  mandate_id: string;
  /**
   *
   * @type {MandateAuthLinkCustomizations}
   * @memberof GetMandateAuthLinkRequest
   */
  link_customizations: MandateAuthLinkCustomizations;
}
/**
 *
 * @export
 * @interface GetMandateAuthLinkResponse
 */
export interface GetMandateAuthLinkResponse {
  /**
   * Short-lived access-token to interact with Finverse Link
   * @type {string}
   * @memberof GetMandateAuthLinkResponse
   */
  access_token: string;
  /**
   * Access token validity duration (in seconds)
   * @type {number}
   * @memberof GetMandateAuthLinkResponse
   */
  expires_in: number;
  /**
   * URL to launch Finverse Link to authorize the mandate
   * @type {string}
   * @memberof GetMandateAuthLinkResponse
   */
  link_url: string;
  /**
   *
   * @type {string}
   * @memberof GetMandateAuthLinkResponse
   */
  token_type: GetMandateAuthLinkResponseTokenTypeEnum;
}

export const GetMandateAuthLinkResponseTokenTypeEnum = {
  Bearer: 'Bearer',
} as const;

export type GetMandateAuthLinkResponseTokenTypeEnum =
  (typeof GetMandateAuthLinkResponseTokenTypeEnum)[keyof typeof GetMandateAuthLinkResponseTokenTypeEnum];

/**
 *
 * @export
 * @interface GetMandateAuthResponse
 */
export interface GetMandateAuthResponse {
  /**
   * Finverse Mandate ID
   * @type {string}
   * @memberof GetMandateAuthResponse
   */
  mandate_id: string;
  /**
   * Mandate status
   * @type {string}
   * @memberof GetMandateAuthResponse
   */
  mandate_status: GetMandateAuthResponseMandateStatusEnum;
  /**
   * Merchant account ID assigned by Finverse
   * @type {string}
   * @memberof GetMandateAuthResponse
   */
  recipient_account_id: string;
  /**
   * Finverse Institution ID. Only returned if institution_id was included in the request.
   * @type {string}
   * @memberof GetMandateAuthResponse
   */
  institution_id: string;
  /**
   * Type of account held by the Sender at the Institution. Possible values are INDIVIDUAL, BUSINESS
   * @type {string}
   * @memberof GetMandateAuthResponse
   */
  sender_type?: GetMandateAuthResponseSenderTypeEnum;
  /**
   * Checklist of the authorization factors needed to complete Mandate authorization
   * @type {Array<AuthChecklistFactor>}
   * @memberof GetMandateAuthResponse
   */
  auth_checklist: Array<AuthChecklistFactor>;
  /**
   *
   * @type {MandateAuthEncryptionInfo}
   * @memberof GetMandateAuthResponse
   */
  encryption_info: MandateAuthEncryptionInfo;
  /**
   * Timestamp in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
   * @type {string}
   * @memberof GetMandateAuthResponse
   */
  last_update: string;
  /**
   *
   * @type {FvEmbeddedErrorModel}
   * @memberof GetMandateAuthResponse
   */
  error?: FvEmbeddedErrorModel;
  /**
   *
   * @type {MandateDetailsResponse}
   * @memberof GetMandateAuthResponse
   */
  mandate_details?: MandateDetailsResponse;
  /**
   *
   * @type {MandateRecipient}
   * @memberof GetMandateAuthResponse
   */
  recipient?: MandateRecipient;
}

export const GetMandateAuthResponseMandateStatusEnum = {
  Created: 'CREATED',
  Processing: 'PROCESSING',
  Submitted: 'SUBMITTED',
  Error: 'ERROR',
} as const;

export type GetMandateAuthResponseMandateStatusEnum =
  (typeof GetMandateAuthResponseMandateStatusEnum)[keyof typeof GetMandateAuthResponseMandateStatusEnum];
export const GetMandateAuthResponseSenderTypeEnum = {
  Individual: 'INDIVIDUAL',
  Business: 'BUSINESS',
} as const;

export type GetMandateAuthResponseSenderTypeEnum =
  (typeof GetMandateAuthResponseSenderTypeEnum)[keyof typeof GetMandateAuthResponseSenderTypeEnum];

/**
 *
 * @export
 * @interface GetMandateResponse
 */
export interface GetMandateResponse {
  /**
   * Timestamp in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
   * @type {string}
   * @memberof GetMandateResponse
   */
  created_at?: string;
  /**
   * Timestamp in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
   * @type {string}
   * @memberof GetMandateResponse
   */
  updated_at: string;
  /**
   * Finverse Mandate ID (ULID)
   * @type {string}
   * @memberof GetMandateResponse
   */
  mandate_id: string;
  /**
   * Finverse Payment Method ID (ULID)
   * @type {string}
   * @memberof GetMandateResponse
   */
  payment_method_id?: string;
  /**
   * Mandate Status
   * @type {string}
   * @memberof GetMandateResponse
   */
  status: GetMandateResponseStatusEnum;
  /**
   *
   * @type {MandateRecipient}
   * @memberof GetMandateResponse
   */
  recipient: MandateRecipient;
  /**
   *
   * @type {MandateRecipientAccount}
   * @memberof GetMandateResponse
   */
  recipient_account?: MandateRecipientAccount;
  /**
   *
   * @type {GetMandateSender}
   * @memberof GetMandateResponse
   */
  sender: GetMandateSender;
  /**
   *
   * @type {MandateSenderAccount}
   * @memberof GetMandateResponse
   */
  sender_account?: MandateSenderAccount;
  /**
   *
   * @type {MandateDetailsResponse}
   * @memberof GetMandateResponse
   */
  mandate_details: MandateDetailsResponse;
  /**
   *
   * @type {Array<Fee>}
   * @memberof GetMandateResponse
   */
  fees?: Array<Fee>;
  /**
   *
   * @type {FvEmbeddedErrorModel}
   * @memberof GetMandateResponse
   */
  error?: FvEmbeddedErrorModel;
  /**
   * Additional attributes of the mandate in key:value format (e.g. mandate_internal_id: 1234). It supports up to 10 key:value pairs, whereas the key and value supports up to 50 and 1000 characters respectively.
   * @type {{ [key: string]: string; }}
   * @memberof GetMandateResponse
   */
  metadata?: { [key: string]: string };
}

export const GetMandateResponseStatusEnum = {
  AuthorizationRequired: 'AUTHORIZATION_REQUIRED',
  Authorizing: 'AUTHORIZING',
  Processing: 'PROCESSING',
  Submitted: 'SUBMITTED',
  Succeeded: 'SUCCEEDED',
  Failed: 'FAILED',
  Revoked: 'REVOKED',
} as const;

export type GetMandateResponseStatusEnum =
  (typeof GetMandateResponseStatusEnum)[keyof typeof GetMandateResponseStatusEnum];

/**
 *
 * @export
 * @interface GetMandateSender
 */
export interface GetMandateSender {
  /**
   * A unique identifier generated after creating sender
   * @type {string}
   * @memberof GetMandateSender
   */
  user_id: string;
  /**
   *
   * @type {string}
   * @memberof GetMandateSender
   */
  name?: string;
  /**
   * Customer App\'s user ID, representing the end-user making the payment.
   * @type {string}
   * @memberof GetMandateSender
   */
  external_user_id: string;
  /**
   * Type of account held by the Sender at the Institution. Possible values are INDIVIDUAL, BUSINESS
   * @type {string}
   * @memberof GetMandateSender
   */
  user_type: GetMandateSenderUserTypeEnum;
  /**
   * Sender details which will be used for fraud checking.
   * @type {Array<SenderDetail>}
   * @memberof GetMandateSender
   */
  user_details?: Array<SenderDetail>;
}

export const GetMandateSenderUserTypeEnum = {
  Individual: 'INDIVIDUAL',
  Business: 'BUSINESS',
} as const;

export type GetMandateSenderUserTypeEnum =
  (typeof GetMandateSenderUserTypeEnum)[keyof typeof GetMandateSenderUserTypeEnum];

/**
 *
 * @export
 * @interface GetPaymentInstructionsResponse
 */
export interface GetPaymentInstructionsResponse {
  /**
   *
   * @type {PaymentInstruction}
   * @memberof GetPaymentInstructionsResponse
   */
  payment_instruction?: PaymentInstruction;
}
/**
 *
 * @export
 * @interface GetPaymentUserResponse
 */
export interface GetPaymentUserResponse {
  /**
   *
   * @type {string}
   * @memberof GetPaymentUserResponse
   */
  payment_user_id: string;
  /**
   *
   * @type {string}
   * @memberof GetPaymentUserResponse
   */
  customer_app_id: string;
  /**
   * The user\'s current autopay value
   * @type {boolean}
   * @memberof GetPaymentUserResponse
   */
  autopay_consent: boolean;
  /**
   * This indicates the value that the user\'s pre-set selection should be. If this is a new user, the value will be set to true by default, else it will be the user\'s current autopay value.
   * @type {boolean}
   * @memberof GetPaymentUserResponse
   */
  autopay_prefill: boolean;
}
/**
 *
 * @export
 * @interface GetStatementLinkResponse
 */
export interface GetStatementLinkResponse {
  /**
   *
   * @type {Array<StatementLink>}
   * @memberof GetStatementLinkResponse
   */
  statement_links?: Array<StatementLink>;
}
/**
 *
 * @export
 * @interface GetStatementsResponse
 */
export interface GetStatementsResponse {
  /**
   *
   * @type {Array<Statement>}
   * @memberof GetStatementsResponse
   */
  statements?: Array<Statement>;
  /**
   *
   * @type {LoginIdentityShort}
   * @memberof GetStatementsResponse
   */
  login_identity?: LoginIdentityShort;
  /**
   *
   * @type {InstitutionShort}
   * @memberof GetStatementsResponse
   */
  institution?: InstitutionShort;
}
/**
 *
 * @export
 * @interface Identity
 */
export interface Identity {
  /**
   *
   * @type {Array<IdentityName>}
   * @memberof Identity
   */
  names?: Array<IdentityName>;
  /**
   *
   * @type {Array<IdentityAddress>}
   * @memberof Identity
   */
  addresses?: Array<IdentityAddress>;
  /**
   *
   * @type {Array<IdentityEmail>}
   * @memberof Identity
   */
  emails?: Array<IdentityEmail>;
  /**
   *
   * @type {Array<IdentityPhoneNumber>}
   * @memberof Identity
   */
  phone_numbers?: Array<IdentityPhoneNumber>;
  /**
   *
   * @type {Array<IdentityDateOfBirth>}
   * @memberof Identity
   */
  date_of_births?: Array<IdentityDateOfBirth>;
}
/**
 *
 * @export
 * @interface IdentityAddress
 */
export interface IdentityAddress {
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  raw?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  full_address?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  unit_number?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  floor_number?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  building_name?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  street_number?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  street_name?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  city?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  district?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  ward?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  street_address?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  province?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  country?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  postal_code?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  source?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof IdentityAddress
   */
  source_ids?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof IdentityAddress
   */
  account_ids?: Array<string>;
}
/**
 *
 * @export
 * @interface IdentityDateOfBirth
 */
export interface IdentityDateOfBirth {
  /**
   *
   * @type {string}
   * @memberof IdentityDateOfBirth
   */
  raw?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityDateOfBirth
   */
  date_of_birth?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityDateOfBirth
   */
  masked_date_of_birth?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityDateOfBirth
   */
  source?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof IdentityDateOfBirth
   */
  source_ids?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof IdentityDateOfBirth
   */
  account_ids?: Array<string>;
}
/**
 *
 * @export
 * @interface IdentityEmail
 */
export interface IdentityEmail {
  /**
   *
   * @type {string}
   * @memberof IdentityEmail
   */
  raw?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityEmail
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityEmail
   */
  masked_email?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityEmail
   */
  source?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof IdentityEmail
   */
  source_ids?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof IdentityEmail
   */
  account_ids?: Array<string>;
}
/**
 *
 * @export
 * @interface IdentityName
 */
export interface IdentityName {
  /**
   *
   * @type {string}
   * @memberof IdentityName
   */
  raw?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityName
   */
  full_name?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityName
   */
  first_name?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityName
   */
  last_name?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityName
   */
  other_name?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityName
   */
  source?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof IdentityName
   */
  source_ids?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof IdentityName
   */
  account_ids?: Array<string>;
}
/**
 *
 * @export
 * @interface IdentityPhoneNumber
 */
export interface IdentityPhoneNumber {
  /**
   *
   * @type {string}
   * @memberof IdentityPhoneNumber
   */
  raw?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityPhoneNumber
   */
  mobile_phone?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityPhoneNumber
   */
  other_phone?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityPhoneNumber
   */
  masked_phone?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityPhoneNumber
   */
  source?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof IdentityPhoneNumber
   */
  source_ids?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof IdentityPhoneNumber
   */
  account_ids?: Array<string>;
}
/**
 *
 * @export
 * @interface IncomeEstimate
 */
export interface IncomeEstimate {
  /**
   * Income amount
   * @type {number}
   * @memberof IncomeEstimate
   */
  amount: number;
  /**
   * Currency
   * @type {string}
   * @memberof IncomeEstimate
   */
  currency: string;
}
/**
 *
 * @export
 * @interface IncomeResponse
 */
export interface IncomeResponse {
  /**
   *
   * @type {Array<SingleSourceIncome>}
   * @memberof IncomeResponse
   */
  income: Array<SingleSourceIncome>;
  /**
   *
   * @type {LoginIdentityShort}
   * @memberof IncomeResponse
   */
  login_identity: LoginIdentityShort;
  /**
   *
   * @type {InstitutionShort}
   * @memberof IncomeResponse
   */
  institution: InstitutionShort;
}
/**
 *
 * @export
 * @interface IncomeStream
 */
export interface IncomeStream {
  /**
   * Account this income estimate is associated with
   * @type {string}
   * @memberof IncomeStream
   */
  account_id: string;
  /**
   *
   * @type {IncomeEstimate}
   * @memberof IncomeStream
   */
  estimated_monthly_income?: IncomeEstimate;
  /**
   * Number of transactions counted towards income
   * @type {number}
   * @memberof IncomeStream
   */
  transaction_count: number;
  /**
   *
   * @type {Array<MonthlyIncomeEstimate>}
   * @memberof IncomeStream
   */
  monthly_history: Array<MonthlyIncomeEstimate>;
}
/**
 *
 * @export
 * @interface IncomeTotal
 */
export interface IncomeTotal {
  /**
   *
   * @type {IncomeEstimate}
   * @memberof IncomeTotal
   */
  estimated_monthly_income?: IncomeEstimate;
  /**
   * Number of transactions counted towards income
   * @type {number}
   * @memberof IncomeTotal
   */
  transaction_count: number;
  /**
   *
   * @type {Array<MonthlyIncomeEstimate>}
   * @memberof IncomeTotal
   */
  monthly_history: Array<MonthlyIncomeEstimate>;
}
/**
 *
 * @export
 * @interface Institution
 */
export interface Institution {
  /**
   *
   * @type {string}
   * @memberof Institution
   */
  institution_id: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Institution
   */
  countries: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof Institution
   */
  tags?: Array<InstitutionTagsEnum>;
  /**
   *
   * @type {string}
   * @memberof Institution
   */
  institution_type: InstitutionInstitutionTypeEnum;
  /**
   *
   * @type {Array<string>}
   * @memberof Institution
   */
  products_supported: Array<InstitutionProductsSupportedEnum>;
  /**
   *
   * @type {string}
   * @memberof Institution
   */
  parent_institution_name?: string;
  /**
   *
   * @type {string}
   * @memberof Institution
   */
  institution_name: string;
  /**
   *
   * @type {string}
   * @memberof Institution
   */
  portal_name?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Institution
   */
  user_type: Array<InstitutionUserTypeEnum>;
  /**
   *
   * @type {string}
   * @memberof Institution
   */
  status: InstitutionStatusEnum;
  /**
   *
   * @type {object}
   * @memberof Institution
   */
  status_details?: object;
  /**
   *
   * @type {string}
   * @memberof Institution
   */
  login_url?: string;
  /**
   *
   * @type {object}
   * @memberof Institution
   */
  login_details: object;
  /**
   *
   * @type {Array<LoginMethod>}
   * @memberof Institution
   */
  login_methods?: Array<LoginMethod>;
  /**
   *
   * @type {PaymentInfo}
   * @memberof Institution
   */
  payment_info?: PaymentInfo;
  /**
   *
   * @type {string}
   * @memberof Institution
   */
  color?: string;
  /**
   *
   * @type {string}
   * @memberof Institution
   */
  updated_at?: string;
  /**
   *
   * @type {Array<LoginAction>}
   * @memberof Institution
   */
  login_actions?: Array<LoginAction>;
}

export const InstitutionTagsEnum = {
  Real: 'real',
  Test: 'test',
} as const;

export type InstitutionTagsEnum = (typeof InstitutionTagsEnum)[keyof typeof InstitutionTagsEnum];
export const InstitutionInstitutionTypeEnum = {
  Bank: 'BANK',
  Wallet: 'WALLET',
  Test: 'TEST',
} as const;

export type InstitutionInstitutionTypeEnum =
  (typeof InstitutionInstitutionTypeEnum)[keyof typeof InstitutionInstitutionTypeEnum];
export const InstitutionProductsSupportedEnum = {
  Accounts: 'ACCOUNTS',
  Transactions: 'TRANSACTIONS',
  Statements: 'STATEMENTS',
  AccountNumbers: 'ACCOUNT_NUMBERS',
  Identity: 'IDENTITY',
  AutoDebitSetup: 'AUTO_DEBIT_SETUP',
} as const;

export type InstitutionProductsSupportedEnum =
  (typeof InstitutionProductsSupportedEnum)[keyof typeof InstitutionProductsSupportedEnum];
export const InstitutionUserTypeEnum = {
  Personal: 'PERSONAL',
  Individual: 'INDIVIDUAL',
  Business: 'BUSINESS',
} as const;

export type InstitutionUserTypeEnum = (typeof InstitutionUserTypeEnum)[keyof typeof InstitutionUserTypeEnum];
export const InstitutionStatusEnum = {
  Supported: 'SUPPORTED',
  Alpha: 'ALPHA',
  Beta: 'BETA',
} as const;

export type InstitutionStatusEnum = (typeof InstitutionStatusEnum)[keyof typeof InstitutionStatusEnum];

/**
 *
 * @export
 * @interface InstitutionShort
 */
export interface InstitutionShort {
  /**
   *
   * @type {string}
   * @memberof InstitutionShort
   */
  institution_id?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof InstitutionShort
   */
  countries?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof InstitutionShort
   */
  institution_name?: string;
  /**
   *
   * @type {string}
   * @memberof InstitutionShort
   */
  portal_name?: string;
}
/**
 *
 * @export
 * @interface IntegrationMetadataRequest
 */
export interface IntegrationMetadataRequest {
  /**
   *
   * @type {string}
   * @memberof IntegrationMetadataRequest
   */
  integration_id: IntegrationMetadataRequestIntegrationIdEnum;
  /**
   *
   * @type {RapidstorMetadataRequest}
   * @memberof IntegrationMetadataRequest
   */
  rapidstor_metadata?: RapidstorMetadataRequest;
}

export const IntegrationMetadataRequestIntegrationIdEnum = {
  Rapidstor: 'RAPIDSTOR',
} as const;

export type IntegrationMetadataRequestIntegrationIdEnum =
  (typeof IntegrationMetadataRequestIntegrationIdEnum)[keyof typeof IntegrationMetadataRequestIntegrationIdEnum];

/**
 *
 * @export
 * @interface IntegrationMetadataResponse
 */
export interface IntegrationMetadataResponse {
  /**
   *
   * @type {string}
   * @memberof IntegrationMetadataResponse
   */
  integration_id?: IntegrationMetadataResponseIntegrationIdEnum;
  /**
   *
   * @type {RapidstorMetadataResponse}
   * @memberof IntegrationMetadataResponse
   */
  rapidstor_metadata?: RapidstorMetadataResponse;
}

export const IntegrationMetadataResponseIntegrationIdEnum = {
  Rapidstor: 'RAPIDSTOR',
} as const;

export type IntegrationMetadataResponseIntegrationIdEnum =
  (typeof IntegrationMetadataResponseIntegrationIdEnum)[keyof typeof IntegrationMetadataResponseIntegrationIdEnum];

/**
 *
 * @export
 * @interface JWKSKey
 */
export interface JWKSKey {
  /**
   * The \"kty\" (key type) parameter identifies the cryptographic algorithm family used with the key, such as \"RSA\" or \"EC\".
   * @type {string}
   * @memberof JWKSKey
   */
  kty?: string;
  /**
   * The \"kid\" (key ID) parameter is used to match a specific key
   * @type {string}
   * @memberof JWKSKey
   */
  kid?: string;
  /**
   * The \"use\" (public key use) parameter identifies the intended use of the public key
   * @type {string}
   * @memberof JWKSKey
   */
  use?: string;
  /**
   * RSA key value \"e\"
   * @type {string}
   * @memberof JWKSKey
   */
  e?: string;
  /**
   * RSA key value \"n\"
   * @type {string}
   * @memberof JWKSKey
   */
  n?: string;
  /**
   * The \"x5c\" (X.509 certificate chain) parameter contains a chain of one or more PKIX certificates
   * @type {Array<string>}
   * @memberof JWKSKey
   */
  x5c?: Array<string>;
}
/**
 *
 * @export
 * @interface LineItem
 */
export interface LineItem {
  /**
   *
   * @type {string}
   * @memberof LineItem
   */
  currency?: string;
  /**
   * The amount in decimal
   * @type {string}
   * @memberof LineItem
   */
  amount?: string;
  /**
   *
   * @type {string}
   * @memberof LineItem
   */
  item_type?: LineItemItemTypeEnum;
}

export const LineItemItemTypeEnum = {
  AmountDue: 'AMOUNT_DUE',
  Surcharge: 'SURCHARGE',
  Total: 'TOTAL',
} as const;

export type LineItemItemTypeEnum = (typeof LineItemItemTypeEnum)[keyof typeof LineItemItemTypeEnum];

/**
 *
 * @export
 * @interface LinkRequest
 */
export interface LinkRequest {
  /**
   *
   * @type {string}
   * @memberof LinkRequest
   */
  institution_id: string;
  /**
   *
   * @type {boolean}
   * @memberof LinkRequest
   */
  store_credential: boolean;
  /**
   * this is a mandatory field
   * @type {boolean}
   * @memberof LinkRequest
   */
  consent?: boolean | null;
  /**
   * products that is requested
   * @type {Array<string>}
   * @memberof LinkRequest
   */
  products_requested?: Array<string>;
  /**
   * The identifier returned after creating payment instruction
   * @type {string}
   * @memberof LinkRequest
   */
  payment_instruction_id?: string;
}
/**
 *
 * @export
 * @interface LinkResponse
 */
export interface LinkResponse {
  /**
   *
   * @type {string}
   * @memberof LinkResponse
   */
  auth_url?: string;
}
/**
 *
 * @export
 * @interface LinkStatusActionModel
 */
export interface LinkStatusActionModel {
  /**
   * Unique identifier
   * @type {string}
   * @memberof LinkStatusActionModel
   */
  action_id: string;
  /**
   * The type of user screen the UI is to render
   * @type {string}
   * @memberof LinkStatusActionModel
   */
  type: string;
  /**
   * The name of the user screen the UI is to render
   * @type {string}
   * @memberof LinkStatusActionModel
   */
  name: string;
  /**
   *
   * @type {Array<UserMessage>}
   * @memberof LinkStatusActionModel
   */
  messages: Array<UserMessage>;
  /**
   *
   * @type {Array<UserField>}
   * @memberof LinkStatusActionModel
   */
  fields: Array<UserField>;
  /**
   *
   * @type {Array<UserButton>}
   * @memberof LinkStatusActionModel
   */
  buttons?: Array<UserButton>;
}
/**
 *
 * @export
 * @interface LinkStatusPendingModel
 */
export interface LinkStatusPendingModel {
  /**
   *
   * @type {string}
   * @memberof LinkStatusPendingModel
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof LinkStatusPendingModel
   */
  message?: string;
  /**
   *
   * @type {string}
   * @memberof LinkStatusPendingModel
   */
  details?: string;
}
/**
 *
 * @export
 * @interface LinkStatusResponse
 */
export interface LinkStatusResponse {
  /**
   *
   * @type {AccessTokenResponse}
   * @memberof LinkStatusResponse
   */
  success?: AccessTokenResponse;
  /**
   *
   * @type {LinkStatusPendingModel}
   * @memberof LinkStatusResponse
   */
  pending?: LinkStatusPendingModel;
  /**
   *
   * @type {LinkStatusActionModel}
   * @memberof LinkStatusResponse
   */
  action?: LinkStatusActionModel;
}
/**
 *
 * @export
 * @interface LinkTokenRequest
 */
export interface LinkTokenRequest {
  /**
   * support only client_credentials
   * @type {string}
   * @memberof LinkTokenRequest
   */
  grant_type: string;
  /**
   *
   * @type {string}
   * @memberof LinkTokenRequest
   */
  response_type: string;
  /**
   *
   * @type {string}
   * @memberof LinkTokenRequest
   */
  response_mode: string;
  /**
   * required when creating new Link, ignored when updating existing Link
   * @type {string}
   * @memberof LinkTokenRequest
   */
  user_id?: string;
  /**
   *
   * @type {string}
   * @memberof LinkTokenRequest
   */
  client_id: string;
  /**
   *
   * @type {string}
   * @memberof LinkTokenRequest
   */
  redirect_uri: string;
  /**
   *
   * @type {string}
   * @memberof LinkTokenRequest
   */
  state?: string;
  /**
   *
   * @type {string}
   * @memberof LinkTokenRequest
   */
  scope?: string;
  /**
   * Space separated list of the tags of the institutions to view.
   * @type {string}
   * @memberof LinkTokenRequest
   */
  link_mode?: string;
  /**
   * The UI mode link is intended to be used in - \"iframe\", \"auto_redirect\", \"redirect\" or \"standalone\"
   * @type {string}
   * @memberof LinkTokenRequest
   */
  ui_mode?: LinkTokenRequestUiModeEnum;
  /**
   * ISO639-1 language code. Language to display when user open the link, default to English (en) if not specified
   * @type {string}
   * @memberof LinkTokenRequest
   */
  language?: LinkTokenRequestLanguageEnum;
  /**
   *
   * @type {string}
   * @memberof LinkTokenRequest
   */
  code_challenge?: string;
  /**
   *
   * @type {string}
   * @memberof LinkTokenRequest
   */
  code_challenge_method?: string;
  /**
   * use this to update a specific login identity
   * @type {string}
   * @memberof LinkTokenRequest
   */
  login_identity_id?: string;
  /**
   * The customization id if the customer wishes to embed it into link token for spawning link with their choice of stuffs
   * @type {string}
   * @memberof LinkTokenRequest
   */
  customization_id?: string;
  /**
   * Institution to preselect
   * @type {string}
   * @memberof LinkTokenRequest
   */
  institution_id?: string;
  /**
   * institution\'s country filter
   * @type {Array<string>}
   * @memberof LinkTokenRequest
   */
  countries?: Array<string>;
  /**
   * institution\'s supported user_type filter
   * @type {Array<string>}
   * @memberof LinkTokenRequest
   */
  user_type?: Array<string>;
  /**
   * institution\'s supported product filter
   * @type {Array<string>}
   * @memberof LinkTokenRequest
   */
  products_supported?: Array<string>;
  /**
   * products that is requested
   * @type {Array<string>}
   * @memberof LinkTokenRequest
   */
  products_requested?: Array<string>;
  /**
   * The identifier returned after creating payment instruction
   * @type {string}
   * @memberof LinkTokenRequest
   */
  payment_instruction_id?: string;
  /**
   * Controls the behavior of the automatic data refresh checkbox
   * @type {string}
   * @memberof LinkTokenRequest
   */
  automatic_data_refresh?: LinkTokenRequestAutomaticDataRefreshEnum;
  /**
   * institution\'s status filter
   * @type {string}
   * @memberof LinkTokenRequest
   */
  institution_status?: string;
  /**
   *
   * @type {LinkTokenUserConfigs}
   * @memberof LinkTokenRequest
   */
  user_configs?: LinkTokenUserConfigs;
}

export const LinkTokenRequestUiModeEnum = {
  Iframe: 'iframe',
  Redirect: 'redirect',
  AutoRedirect: 'auto_redirect',
  Standalone: 'standalone',
} as const;

export type LinkTokenRequestUiModeEnum = (typeof LinkTokenRequestUiModeEnum)[keyof typeof LinkTokenRequestUiModeEnum];
export const LinkTokenRequestLanguageEnum = {
  En: 'en',
  Vi: 'vi',
  Zh: 'zh',
  Ko: 'ko',
} as const;

export type LinkTokenRequestLanguageEnum =
  (typeof LinkTokenRequestLanguageEnum)[keyof typeof LinkTokenRequestLanguageEnum];
export const LinkTokenRequestAutomaticDataRefreshEnum = {
  On: 'ON',
  Off: 'OFF',
  ForcedOn: 'FORCED_ON',
} as const;

export type LinkTokenRequestAutomaticDataRefreshEnum =
  (typeof LinkTokenRequestAutomaticDataRefreshEnum)[keyof typeof LinkTokenRequestAutomaticDataRefreshEnum];

/**
 *
 * @export
 * @interface LinkTokenResponse
 */
export interface LinkTokenResponse {
  /**
   *
   * @type {string}
   * @memberof LinkTokenResponse
   */
  access_token: string;
  /**
   *
   * @type {string}
   * @memberof LinkTokenResponse
   */
  token_type: string;
  /**
   * seconds
   * @type {number}
   * @memberof LinkTokenResponse
   */
  expires_in: number;
  /**
   *
   * @type {string}
   * @memberof LinkTokenResponse
   */
  issued_at: string;
  /**
   *
   * @type {string}
   * @memberof LinkTokenResponse
   */
  link_url: string;
}
/**
 *
 * @export
 * @interface LinkTokenUserConfigs
 */
export interface LinkTokenUserConfigs {
  /**
   * Account Number to use for ADA setup
   * @type {string}
   * @memberof LinkTokenUserConfigs
   */
  ada_account_number?: string;
}
/**
 *
 * @export
 * @interface ListAccountsResponse
 */
export interface ListAccountsResponse {
  /**
   *
   * @type {Array<Account>}
   * @memberof ListAccountsResponse
   */
  accounts?: Array<Account>;
  /**
   *
   * @type {LoginIdentityShort}
   * @memberof ListAccountsResponse
   */
  login_identity?: LoginIdentityShort;
  /**
   *
   * @type {InstitutionShort}
   * @memberof ListAccountsResponse
   */
  institution?: InstitutionShort;
}
/**
 *
 * @export
 * @interface ListCardsDetailsResponse
 */
export interface ListCardsDetailsResponse {
  /**
   *
   * @type {LoginIdentityShort}
   * @memberof ListCardsDetailsResponse
   */
  login_identity?: LoginIdentityShort;
  /**
   *
   * @type {InstitutionShort}
   * @memberof ListCardsDetailsResponse
   */
  institution?: InstitutionShort;
  /**
   *
   * @type {CardDetails}
   * @memberof ListCardsDetailsResponse
   */
  card_details?: CardDetails;
}
/**
 *
 * @export
 * @interface ListDisputesResponse
 */
export interface ListDisputesResponse {
  /**
   *
   * @type {Array<DisputeResponse>}
   * @memberof ListDisputesResponse
   */
  disputes: Array<DisputeResponse>;
  /**
   *
   * @type {number}
   * @memberof ListDisputesResponse
   */
  total_disputes: number;
}
/**
 *
 * @export
 * @interface ListMandatesResponse
 */
export interface ListMandatesResponse {
  /**
   *
   * @type {Array<GetMandateResponse>}
   * @memberof ListMandatesResponse
   */
  mandates?: Array<GetMandateResponse>;
  /**
   *
   * @type {number}
   * @memberof ListMandatesResponse
   */
  total_mandates: number;
}
/**
 *
 * @export
 * @interface ListPaymentAccountsResponse
 */
export interface ListPaymentAccountsResponse {
  /**
   *
   * @type {Array<PaymentAccountDetails>}
   * @memberof ListPaymentAccountsResponse
   */
  payment_accounts?: Array<PaymentAccountDetails>;
}
/**
 *
 * @export
 * @interface ListPaymentAccountsWithEnrichedDataResponse
 */
export interface ListPaymentAccountsWithEnrichedDataResponse {
  /**
   *
   * @type {Array<PaymentAccountDetailsWithEnrichedData>}
   * @memberof ListPaymentAccountsWithEnrichedDataResponse
   */
  payment_accounts?: Array<PaymentAccountDetailsWithEnrichedData>;
  /**
   * Total number of matching payment accounts
   * @type {number}
   * @memberof ListPaymentAccountsWithEnrichedDataResponse
   */
  total?: number;
}
/**
 *
 * @export
 * @interface ListPaymentMethodsResponse
 */
export interface ListPaymentMethodsResponse {
  /**
   *
   * @type {Array<PaymentMethodResponse>}
   * @memberof ListPaymentMethodsResponse
   */
  payment_methods?: Array<PaymentMethodResponse>;
  /**
   *
   * @type {PaymentUserWithoutEmail}
   * @memberof ListPaymentMethodsResponse
   */
  sender?: PaymentUserWithoutEmail;
}
/**
 *
 * @export
 * @interface ListPaymentsResponse
 */
export interface ListPaymentsResponse {
  /**
   *
   * @type {Array<PaymentResponse>}
   * @memberof ListPaymentsResponse
   */
  payments?: Array<PaymentResponse>;
  /**
   *
   * @type {number}
   * @memberof ListPaymentsResponse
   */
  total_payments: number;
}
/**
 *
 * @export
 * @interface ListPayoutsResponse
 */
export interface ListPayoutsResponse {
  /**
   *
   * @type {Array<PayoutSnapshotResponse>}
   * @memberof ListPayoutsResponse
   */
  payouts: Array<PayoutSnapshotResponse>;
  /**
   *
   * @type {number}
   * @memberof ListPayoutsResponse
   */
  total_payouts: number;
}
/**
 *
 * @export
 * @interface ListTransactionsResponse
 */
export interface ListTransactionsResponse {
  /**
   *
   * @type {Array<Account>}
   * @memberof ListTransactionsResponse
   */
  accounts?: Array<Account>;
  /**
   *
   * @type {Array<Transaction>}
   * @memberof ListTransactionsResponse
   */
  transactions?: Array<Transaction>;
  /**
   *
   * @type {LoginIdentityShort}
   * @memberof ListTransactionsResponse
   */
  login_identity?: LoginIdentityShort;
  /**
   *
   * @type {InstitutionShort}
   * @memberof ListTransactionsResponse
   */
  institution?: InstitutionShort;
  /**
   *
   * @type {number}
   * @memberof ListTransactionsResponse
   */
  total_transactions: number;
}
/**
 *
 * @export
 * @interface LoginAction
 */
export interface LoginAction {
  /**
   *
   * @type {string}
   * @memberof LoginAction
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof LoginAction
   */
  name?: string;
  /**
   *
   * @type {Array<UserMessage>}
   * @memberof LoginAction
   */
  messages?: Array<UserMessage>;
  /**
   *
   * @type {Array<UserField>}
   * @memberof LoginAction
   */
  fields?: Array<UserField>;
  /**
   *
   * @type {Array<UserButton>}
   * @memberof LoginAction
   */
  buttons?: Array<UserButton>;
}
/**
 *
 * @export
 * @interface LoginField
 */
export interface LoginField {
  /**
   *
   * @type {string}
   * @memberof LoginField
   */
  key?: string;
  /**
   *
   * @type {string}
   * @memberof LoginField
   */
  name?: string;
  /**
   * could be password, text, number
   * @type {string}
   * @memberof LoginField
   */
  type?: string;
}
/**
 *
 * @export
 * @interface LoginIdentity
 */
export interface LoginIdentity {
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  login_identity_id?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  customer_app_id: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  user_id: string;
  /**
   *
   * @type {LoginIdentityLoginMethodsAvailable}
   * @memberof LoginIdentity
   */
  login_methods_available?: LoginIdentityLoginMethodsAvailable;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  permissions_grant_date?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  permissions_expiry_date?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof LoginIdentity
   */
  permissions?: Array<string>;
  /**
   *
   * @type {LoginIdentityBillingDetails}
   * @memberof LoginIdentity
   */
  billing_details?: LoginIdentityBillingDetails;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  status?: string;
  /**
   *
   * @type {LoginIdentityStatusDetails}
   * @memberof LoginIdentity
   */
  status_details?: LoginIdentityStatusDetails;
  /**
   *
   * @type {AllProductStatus}
   * @memberof LoginIdentity
   */
  product_status?: AllProductStatus;
  /**
   *
   * @type {ProductStatus}
   * @memberof LoginIdentity
   */
  authentication_status?: ProductStatus;
  /**
   *
   * @type {LoginIdentityError}
   * @memberof LoginIdentity
   */
  error?: LoginIdentityError;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  last_success?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  first_success?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  webhook?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  session_status?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  institution_id: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  updated_at?: string;
  /**
   * a login attempt id which is unique per login_identity
   * @type {string}
   * @memberof LoginIdentity
   */
  linking_attempt_id?: string;
  /**
   * a successful login attempt id which is unique per login_identity
   * @type {string}
   * @memberof LoginIdentity
   */
  authentication_id?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  last_session_id?: string;
  /**
   *
   * @type {RefreshData}
   * @memberof LoginIdentity
   */
  refresh?: RefreshData;
}
/**
 *
 * @export
 * @interface LoginIdentityBillingDetails
 */
export interface LoginIdentityBillingDetails {
  /**
   *
   * @type {Array<string>}
   * @memberof LoginIdentityBillingDetails
   */
  billed_products?: Array<string>;
}
/**
 *
 * @export
 * @interface LoginIdentityError
 */
export interface LoginIdentityError {
  /**
   *
   * @type {number}
   * @memberof LoginIdentityError
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof LoginIdentityError
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentityError
   */
  message?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentityError
   */
  details?: string;
}
/**
 *
 * @export
 * @interface LoginIdentityLoginMethodsAvailable
 */
export interface LoginIdentityLoginMethodsAvailable {
  /**
   *
   * @type {boolean}
   * @memberof LoginIdentityLoginMethodsAvailable
   */
  havePassword?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof LoginIdentityLoginMethodsAvailable
   */
  haveSecret?: boolean;
}
/**
 *
 * @export
 * @interface LoginIdentityShort
 */
export interface LoginIdentityShort {
  /**
   *
   * @type {string}
   * @memberof LoginIdentityShort
   */
  login_identity_id?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentityShort
   */
  status?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentityShort
   */
  last_session_id?: string;
}
/**
 *
 * @export
 * @interface LoginIdentityStatusDetails
 */
export interface LoginIdentityStatusDetails {
  /**
   *
   * @type {string}
   * @memberof LoginIdentityStatusDetails
   */
  event_date?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentityStatusDetails
   */
  event_name?: string;
}
/**
 *
 * @export
 * @interface LoginMethod
 */
export interface LoginMethod {
  /**
   *
   * @type {string}
   * @memberof LoginMethod
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof LoginMethod
   */
  name?: string;
  /**
   *
   * @type {boolean}
   * @memberof LoginMethod
   */
  is_default_method?: boolean | null;
  /**
   *
   * @type {string}
   * @memberof LoginMethod
   */
  status?: LoginMethodStatusEnum;
  /**
   *
   * @type {Array<LoginField>}
   * @memberof LoginMethod
   */
  login_fields?: Array<LoginField>;
}

export const LoginMethodStatusEnum = {
  Supported: 'SUPPORTED',
  Alpha: 'ALPHA',
  Beta: 'BETA',
} as const;

export type LoginMethodStatusEnum = (typeof LoginMethodStatusEnum)[keyof typeof LoginMethodStatusEnum];

/**
 *
 * @export
 * @interface MandateAuthEncryptionInfo
 */
export interface MandateAuthEncryptionInfo {
  /**
   *
   * @type {string}
   * @memberof MandateAuthEncryptionInfo
   */
  jwks_url: string;
  /**
   *
   * @type {string}
   * @memberof MandateAuthEncryptionInfo
   */
  key_id: string;
}
/**
 *
 * @export
 * @interface MandateAuthLinkCustomizations
 */
export interface MandateAuthLinkCustomizations {
  /**
   * institution\'s country filter
   * @type {Array<string>}
   * @memberof MandateAuthLinkCustomizations
   */
  countries?: Array<string>;
  /**
   * Institution to preselect
   * @type {string}
   * @memberof MandateAuthLinkCustomizations
   */
  institution_id?: string;
  /**
   * institution\'s status filter
   * @type {string}
   * @memberof MandateAuthLinkCustomizations
   */
  institution_status?: string;
  /**
   * ISO639-1 language code. Language to display when user open the link, default to English (en) if not specified
   * @type {string}
   * @memberof MandateAuthLinkCustomizations
   */
  language?: MandateAuthLinkCustomizationsLanguageEnum;
  /**
   * Space separated list of the tags of the institutions to view.
   * @type {string}
   * @memberof MandateAuthLinkCustomizations
   */
  link_mode?: string;
  /**
   * institution\'s supported product filter. For mandate authorization, this field should contain [\"MANDATE\"]
   * @type {Array<string>}
   * @memberof MandateAuthLinkCustomizations
   */
  products_supported?: Array<string>;
  /**
   * The UI mode link is intended to be used in - \"iframe\", \"auto_redirect\", \"redirect\" or \"standalone\"
   * @type {string}
   * @memberof MandateAuthLinkCustomizations
   */
  ui_mode?: MandateAuthLinkCustomizationsUiModeEnum;
  /**
   * The URI to redirect to. Required if ui_mode is \"redirect\" or \"auto_redirect\"
   * @type {string}
   * @memberof MandateAuthLinkCustomizations
   */
  redirect_uri?: string;
  /**
   * institution\'s supported user_type filter
   * @type {Array<string>}
   * @memberof MandateAuthLinkCustomizations
   */
  user_type?: Array<string>;
}

export const MandateAuthLinkCustomizationsLanguageEnum = {
  En: 'en',
  Vi: 'vi',
  Zh: 'zh',
  Ko: 'ko',
} as const;

export type MandateAuthLinkCustomizationsLanguageEnum =
  (typeof MandateAuthLinkCustomizationsLanguageEnum)[keyof typeof MandateAuthLinkCustomizationsLanguageEnum];
export const MandateAuthLinkCustomizationsUiModeEnum = {
  Iframe: 'iframe',
  Redirect: 'redirect',
  AutoRedirect: 'auto_redirect',
  Standalone: 'standalone',
} as const;

export type MandateAuthLinkCustomizationsUiModeEnum =
  (typeof MandateAuthLinkCustomizationsUiModeEnum)[keyof typeof MandateAuthLinkCustomizationsUiModeEnum];

/**
 *
 * @export
 * @interface MandateDetailsForPaymentLink
 */
export interface MandateDetailsForPaymentLink {
  /**
   * YYYY-MM-DD, must be later than or the same as the date of creation. If unspecified, default to the date of creation.
   * @type {string}
   * @memberof MandateDetailsForPaymentLink
   */
  start_date?: string | null;
  /**
   * YYYY-MM-DD, must be later than the date of creation.
   * @type {string}
   * @memberof MandateDetailsForPaymentLink
   */
  end_date?: string | null;
  /**
   *
   * @type {TransactionLimitsResponse}
   * @memberof MandateDetailsForPaymentLink
   */
  transaction_limits?: TransactionLimitsResponse;
  /**
   * End-user facing description of the mandate (used in notifications, and in payments if no description is provided)
   * @type {string}
   * @memberof MandateDetailsForPaymentLink
   */
  description?: string;
}
/**
 *
 * @export
 * @interface MandateDetailsForPaymentLinkRequest
 */
export interface MandateDetailsForPaymentLinkRequest {
  /**
   * YYYY-MM-DD, must be later than or the same as the date of creation. If unspecified, default to the date of creation.
   * @type {string}
   * @memberof MandateDetailsForPaymentLinkRequest
   */
  start_date?: string | null;
  /**
   * YYYY-MM-DD, must be later than the date of creation.
   * @type {string}
   * @memberof MandateDetailsForPaymentLinkRequest
   */
  end_date?: string | null;
  /**
   *
   * @type {TransactionLimitsRequest}
   * @memberof MandateDetailsForPaymentLinkRequest
   */
  transaction_limits?: TransactionLimitsRequest;
  /**
   * End-user facing description of the mandate (used in notifications, and in payments if no description is provided)
   * @type {string}
   * @memberof MandateDetailsForPaymentLinkRequest
   */
  description?: string;
}
/**
 *
 * @export
 * @interface MandateDetailsRequest
 */
export interface MandateDetailsRequest {
  /**
   * ISO currency code
   * @type {string}
   * @memberof MandateDetailsRequest
   */
  currency: string;
  /**
   * YYYY-MM-DD, must be later than or the same as the date of creation. If unspecified, default to the date of creation.
   * @type {string}
   * @memberof MandateDetailsRequest
   */
  start_date?: string | null;
  /**
   * YYYY-MM-DD, must be later than the date of creation.
   * @type {string}
   * @memberof MandateDetailsRequest
   */
  end_date?: string | null;
  /**
   *
   * @type {PaymentSchedule}
   * @memberof MandateDetailsRequest
   */
  payment_schedule?: PaymentSchedule;
  /**
   *
   * @type {TransactionLimitsRequest}
   * @memberof MandateDetailsRequest
   */
  transaction_limits?: TransactionLimitsRequest;
  /**
   * End-user facing description of the mandate (used in notifications, and in payments if no description is provided)
   * @type {string}
   * @memberof MandateDetailsRequest
   */
  description?: string;
  /**
   * A bank specific reference, what the end user may see
   * @type {string}
   * @memberof MandateDetailsRequest
   */
  mandate_bank_reference?: string;
}
/**
 *
 * @export
 * @interface MandateDetailsRequestWithDdaReference
 */
export interface MandateDetailsRequestWithDdaReference {
  /**
   * The direct debit authorization reference
   * @type {string}
   * @memberof MandateDetailsRequestWithDdaReference
   */
  dda_reference?: string;
  /**
   * ISO currency code
   * @type {string}
   * @memberof MandateDetailsRequestWithDdaReference
   */
  currency: string;
  /**
   * YYYY-MM-DD, must be later than or the same as the date of creation. If unspecified, default to the date of creation.
   * @type {string}
   * @memberof MandateDetailsRequestWithDdaReference
   */
  start_date?: string | null;
  /**
   * YYYY-MM-DD, must be later than the date of creation.
   * @type {string}
   * @memberof MandateDetailsRequestWithDdaReference
   */
  end_date?: string | null;
  /**
   *
   * @type {TransactionLimitsRequest}
   * @memberof MandateDetailsRequestWithDdaReference
   */
  transaction_limits?: TransactionLimitsRequest;
  /**
   * End-user facing description of the mandate (used in notifications, and in payments if no description is provided)
   * @type {string}
   * @memberof MandateDetailsRequestWithDdaReference
   */
  description: string;
}
/**
 *
 * @export
 * @interface MandateDetailsResponse
 */
export interface MandateDetailsResponse {
  /**
   * The direct debit authorization reference, if empty this will be omitted from response
   * @type {string}
   * @memberof MandateDetailsResponse
   */
  dda_reference?: string;
  /**
   * ISO currency code
   * @type {string}
   * @memberof MandateDetailsResponse
   */
  currency: string;
  /**
   * YYYY-MM-DD, must be later than or the same as the date of creation. If unspecified, default to the date of creation.
   * @type {string}
   * @memberof MandateDetailsResponse
   */
  start_date?: string | null;
  /**
   * YYYY-MM-DD, must be later than the date of creation.
   * @type {string}
   * @memberof MandateDetailsResponse
   */
  end_date?: string | null;
  /**
   *
   * @type {PaymentSchedule}
   * @memberof MandateDetailsResponse
   */
  payment_schedule?: PaymentSchedule;
  /**
   *
   * @type {TransactionLimitsResponse}
   * @memberof MandateDetailsResponse
   */
  transaction_limits?: TransactionLimitsResponse;
  /**
   * End-user facing description of the mandate (used in notifications, and in payments if no description is provided)
   * @type {string}
   * @memberof MandateDetailsResponse
   */
  description?: string;
  /**
   * A bank specific reference, what the end user may see
   * @type {string}
   * @memberof MandateDetailsResponse
   */
  mandate_bank_reference?: string;
  /**
   *
   * @type {string}
   * @memberof MandateDetailsResponse
   */
  processor_entity_name?: string;
  /**
   *
   * @type {string}
   * @memberof MandateDetailsResponse
   */
  collection_entity_name?: string;
}
/**
 *
 * @export
 * @interface MandateFvLinkDetails
 */
export interface MandateFvLinkDetails {
  /**
   *
   * @type {string}
   * @memberof MandateFvLinkDetails
   */
  collection_entity_name?: string;
}
/**
 *
 * @export
 * @interface MandateFvLinkResponse
 */
export interface MandateFvLinkResponse {
  /**
   *
   * @type {string}
   * @memberof MandateFvLinkResponse
   */
  mandate_id?: string;
  /**
   *
   * @type {string}
   * @memberof MandateFvLinkResponse
   */
  institution_id?: string;
  /**
   *
   * @type {string}
   * @memberof MandateFvLinkResponse
   */
  mandate_status?: string;
  /**
   *
   * @type {MandateRecipient}
   * @memberof MandateFvLinkResponse
   */
  recipient?: MandateRecipient;
  /**
   *
   * @type {SenderAccountFvLinkResponse}
   * @memberof MandateFvLinkResponse
   */
  sender_account?: SenderAccountFvLinkResponse;
  /**
   *
   * @type {FvEmbeddedErrorModel}
   * @memberof MandateFvLinkResponse
   */
  error?: FvEmbeddedErrorModel;
  /**
   *
   * @type {MandateFvLinkDetails}
   * @memberof MandateFvLinkResponse
   */
  mandate_details?: MandateFvLinkDetails;
}
/**
 *
 * @export
 * @interface MandateRecipient
 */
export interface MandateRecipient {
  /**
   * Merchant account name
   * @type {string}
   * @memberof MandateRecipient
   */
  name: string;
}
/**
 *
 * @export
 * @interface MandateRecipientAccount
 */
export interface MandateRecipientAccount {
  /**
   * Merchant account ID assigned by Finverse
   * @type {string}
   * @memberof MandateRecipientAccount
   */
  account_id: string;
  /**
   * Type of recipient account.
   * @type {string}
   * @memberof MandateRecipientAccount
   */
  account_type: MandateRecipientAccountAccountTypeEnum;
}

export const MandateRecipientAccountAccountTypeEnum = {
  ExternalAccount: 'EXTERNAL_ACCOUNT',
  SettlementAccount: 'SETTLEMENT_ACCOUNT',
} as const;

export type MandateRecipientAccountAccountTypeEnum =
  (typeof MandateRecipientAccountAccountTypeEnum)[keyof typeof MandateRecipientAccountAccountTypeEnum];

/**
 *
 * @export
 * @interface MandateRecipientRequest
 */
export interface MandateRecipientRequest {
  /**
   * Merchant account ID assigned by Finverse
   * @type {string}
   * @memberof MandateRecipientRequest
   */
  account_id: string;
}
/**
 *
 * @export
 * @interface MandateSenderAccount
 */
export interface MandateSenderAccount {
  /**
   * A unique identifier generated after creating sender account
   * @type {string}
   * @memberof MandateSenderAccount
   */
  account_id?: string;
  /**
   * Tokenized accountholder name of the sender\'s account
   * @type {string}
   * @memberof MandateSenderAccount
   */
  accountholder_name?: string;
  /**
   * Accountholder name of the sender\'s account in plain text
   * @type {string}
   * @memberof MandateSenderAccount
   */
  accountholder_name_plaintext?: string | null;
  /**
   *
   * @type {RecipientAccountNumber}
   * @memberof MandateSenderAccount
   */
  account_number?: RecipientAccountNumber;
  /**
   * Masked Account number of the sender’s account
   * @type {string}
   * @memberof MandateSenderAccount
   */
  account_number_masked?: string;
  /**
   * Type of sender account.
   * @type {string}
   * @memberof MandateSenderAccount
   */
  account_type?: MandateSenderAccountAccountTypeEnum;
  /**
   * Finverse Institution ID for the sender’s institution.
   * @type {string}
   * @memberof MandateSenderAccount
   */
  institution_id?: string;
  /**
   * Institution Name for the sender’s institution.
   * @type {string}
   * @memberof MandateSenderAccount
   */
  institution_name?: string;
  /**
   * A unique identifier generated after creating sender (Finverse Payment User ID)
   * @type {string}
   * @memberof MandateSenderAccount
   */
  user_id?: string;
  /**
   *
   * @type {string}
   * @memberof MandateSenderAccount
   */
  bank_code?: string;
  /**
   * Additional attributes of the sender account in key:value format (e.g. sender_id: 1234). It supports up to 10 key:value pairs, whereas the key and value supports up to 50 and 1000 characters respectively.
   * @type {{ [key: string]: string; }}
   * @memberof MandateSenderAccount
   */
  metadata?: { [key: string]: string };
}

export const MandateSenderAccountAccountTypeEnum = {
  ExternalAccount: 'EXTERNAL_ACCOUNT',
} as const;

export type MandateSenderAccountAccountTypeEnum =
  (typeof MandateSenderAccountAccountTypeEnum)[keyof typeof MandateSenderAccountAccountTypeEnum];

/**
 *
 * @export
 * @interface MandateSenderAccountRequest
 */
export interface MandateSenderAccountRequest {
  /**
   * account ID assigned by Finverse
   * @type {string}
   * @memberof MandateSenderAccountRequest
   */
  account_id: string;
}
/**
 *
 * @export
 * @interface ManualPaymentConfirmationRequest
 */
export interface ManualPaymentConfirmationRequest {
  /**
   * Required if manual payment provider is HK_FPS. Not required for SG_PAYNOW
   * @type {string}
   * @memberof ManualPaymentConfirmationRequest
   */
  accountholder_name?: string;
}
/**
 *
 * @export
 * @interface ManualPaymentConfirmationResponse
 */
export interface ManualPaymentConfirmationResponse {
  /**
   *
   * @type {string}
   * @memberof ManualPaymentConfirmationResponse
   */
  payment_id?: string;
  /**
   *
   * @type {string}
   * @memberof ManualPaymentConfirmationResponse
   */
  status?: ManualPaymentConfirmationResponseStatusEnum;
}

export const ManualPaymentConfirmationResponseStatusEnum = {
  AuthorizationRequired: 'AUTHORIZATION_REQUIRED',
  Authorizing: 'AUTHORIZING',
  Processing: 'PROCESSING',
  Submitted: 'SUBMITTED',
  Executed: 'EXECUTED',
  Failed: 'FAILED',
  Revoked: 'REVOKED',
  Cancelled: 'CANCELLED',
  Created: 'CREATED',
} as const;

export type ManualPaymentConfirmationResponseStatusEnum =
  (typeof ManualPaymentConfirmationResponseStatusEnum)[keyof typeof ManualPaymentConfirmationResponseStatusEnum];

/**
 *
 * @export
 * @interface MonthlyIncomeEstimate
 */
export interface MonthlyIncomeEstimate {
  /**
   *
   * @type {IncomeEstimate}
   * @memberof MonthlyIncomeEstimate
   */
  estimated_income: IncomeEstimate;
  /**
   * The numeric month
   * @type {number}
   * @memberof MonthlyIncomeEstimate
   */
  month: number;
  /**
   * The year
   * @type {number}
   * @memberof MonthlyIncomeEstimate
   */
  year: number;
}
/**
 *
 * @export
 * @interface NonSensitiveLinkStatusResponse
 */
export interface NonSensitiveLinkStatusResponse {
  /**
   *
   * @type {LinkStatusActionModel}
   * @memberof NonSensitiveLinkStatusResponse
   */
  action?: LinkStatusActionModel;
  /**
   *
   * @type {string}
   * @memberof NonSensitiveLinkStatusResponse
   */
  redirect_uri?: string;
  /**
   *
   * @type {NonSensitiveLinkStatusSuccessModel}
   * @memberof NonSensitiveLinkStatusResponse
   */
  success?: NonSensitiveLinkStatusSuccessModel;
  /**
   *
   * @type {FvErrorModelV2}
   * @memberof NonSensitiveLinkStatusResponse
   */
  error?: FvErrorModelV2;
}
/**
 *
 * @export
 * @interface NonSensitiveLinkStatusSuccessModel
 */
export interface NonSensitiveLinkStatusSuccessModel {
  /**
   *
   * @type {string}
   * @memberof NonSensitiveLinkStatusSuccessModel
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof NonSensitiveLinkStatusSuccessModel
   */
  state?: string;
  /**
   *
   * @type {string}
   * @memberof NonSensitiveLinkStatusSuccessModel
   */
  login_identity_id?: string;
}
/**
 *
 * @export
 * @interface OtherInfo
 */
export interface OtherInfo {
  /**
   *
   * @type {string}
   * @memberof OtherInfo
   */
  bank_code?: string;
}
/**
 *
 * @export
 * @interface PaymentAccount
 */
export interface PaymentAccount {
  /**
   * The raw value for the account the user selected when making payment request
   * @type {string}
   * @memberof PaymentAccount
   */
  raw?: string;
  /**
   * Finverse Institution ID. Only returned if institution_id was included in the request.
   * @type {string}
   * @memberof PaymentAccount
   */
  institution_id?: string;
}
/**
 *
 * @export
 * @interface PaymentAccountDetails
 */
export interface PaymentAccountDetails {
  /**
   * Payment account id
   * @type {string}
   * @memberof PaymentAccountDetails
   */
  account_id?: string;
  /**
   *
   * @type {RecipientAccountNumber}
   * @memberof PaymentAccountDetails
   */
  account_number?: RecipientAccountNumber;
  /**
   * Masked Account number of the payment account
   * @type {string}
   * @memberof PaymentAccountDetails
   */
  account_number_masked?: string;
  /**
   * Type of payment account.
   * @type {string}
   * @memberof PaymentAccountDetails
   */
  account_type?: PaymentAccountDetailsAccountTypeEnum;
  /**
   * Accountholder name of the payment account
   * @type {string}
   * @memberof PaymentAccountDetails
   */
  accountholder_name?: string;
  /**
   * The customer app ID
   * @type {string}
   * @memberof PaymentAccountDetails
   */
  customer_app_id?: string;
  /**
   * Finverse Institution ID for the payment institution.
   * @type {string}
   * @memberof PaymentAccountDetails
   */
  institution_id?: string;
  /**
   * Institution Name for the sender’s institution.
   * @type {string}
   * @memberof PaymentAccountDetails
   */
  institution_name?: string;
  /**
   * A unique identifier generated after creating user (Finverse Payment User ID)
   * @type {string}
   * @memberof PaymentAccountDetails
   */
  user_id?: string;
  /**
   * 3-digit code associated with bank
   * @type {string}
   * @memberof PaymentAccountDetails
   */
  bank_code?: string;
  /**
   * 3-digit code used to identify specific bank branch
   * @type {string}
   * @memberof PaymentAccountDetails
   */
  branch_code?: string;
  /**
   * List of currencies supported by the payment account
   * @type {Array<string>}
   * @memberof PaymentAccountDetails
   */
  currencies?: Array<string>;
  /**
   * The business units the payment account belongs to
   * @type {Array<string>}
   * @memberof PaymentAccountDetails
   */
  business_units?: Array<string>;
  /**
   * This field is only applicable to settlement account
   * @type {string}
   * @memberof PaymentAccountDetails
   */
  legal_entity_name?: string;
  /**
   * Additional attributes of the sender account in key:value format (e.g. sender_id: 1234). It supports up to 10 key:value pairs, whereas the key and value supports up to 50 and 1000 characters respectively.
   * @type {{ [key: string]: string; }}
   * @memberof PaymentAccountDetails
   */
  metadata?: { [key: string]: string };
  /**
   * Timestamp of when the payment link was created in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
   * @type {string}
   * @memberof PaymentAccountDetails
   */
  created_at?: string;
  /**
   * Timestamp of when the payment link was last updated in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
   * @type {string}
   * @memberof PaymentAccountDetails
   */
  updated_at?: string;
}

export const PaymentAccountDetailsAccountTypeEnum = {
  ExternalAccount: 'EXTERNAL_ACCOUNT',
  SettlementAccount: 'SETTLEMENT_ACCOUNT',
} as const;

export type PaymentAccountDetailsAccountTypeEnum =
  (typeof PaymentAccountDetailsAccountTypeEnum)[keyof typeof PaymentAccountDetailsAccountTypeEnum];

/**
 *
 * @export
 * @interface PaymentAccountDetailsWithEnrichedData
 */
export interface PaymentAccountDetailsWithEnrichedData {
  /**
   * Payment account id
   * @type {string}
   * @memberof PaymentAccountDetailsWithEnrichedData
   */
  account_id?: string;
  /**
   *
   * @type {RecipientAccountNumber}
   * @memberof PaymentAccountDetailsWithEnrichedData
   */
  account_number?: RecipientAccountNumber;
  /**
   * Masked Account number of the payment account
   * @type {string}
   * @memberof PaymentAccountDetailsWithEnrichedData
   */
  account_number_masked?: string;
  /**
   * Type of payment account.
   * @type {string}
   * @memberof PaymentAccountDetailsWithEnrichedData
   */
  account_type?: PaymentAccountDetailsWithEnrichedDataAccountTypeEnum;
  /**
   * Accountholder name of the payment account
   * @type {string}
   * @memberof PaymentAccountDetailsWithEnrichedData
   */
  accountholder_name?: string;
  /**
   * The customer app ID
   * @type {string}
   * @memberof PaymentAccountDetailsWithEnrichedData
   */
  customer_app_id?: string;
  /**
   * Finverse Institution ID for the payment institution.
   * @type {string}
   * @memberof PaymentAccountDetailsWithEnrichedData
   */
  institution_id?: string;
  /**
   * Institution Name for the sender’s institution.
   * @type {string}
   * @memberof PaymentAccountDetailsWithEnrichedData
   */
  institution_name?: string;
  /**
   * A unique identifier generated after creating user (Finverse Payment User ID)
   * @type {string}
   * @memberof PaymentAccountDetailsWithEnrichedData
   */
  user_id?: string;
  /**
   * 3-digit code associated with bank
   * @type {string}
   * @memberof PaymentAccountDetailsWithEnrichedData
   */
  bank_code?: string;
  /**
   * 3-digit code used to identify specific bank branch
   * @type {string}
   * @memberof PaymentAccountDetailsWithEnrichedData
   */
  branch_code?: string;
  /**
   * List of currencies supported by the payment account
   * @type {Array<string>}
   * @memberof PaymentAccountDetailsWithEnrichedData
   */
  currencies?: Array<string>;
  /**
   * The business units the payment account belongs to
   * @type {Array<string>}
   * @memberof PaymentAccountDetailsWithEnrichedData
   */
  business_units?: Array<string>;
  /**
   * This field is only applicable to settlement account
   * @type {string}
   * @memberof PaymentAccountDetailsWithEnrichedData
   */
  legal_entity_name?: string;
  /**
   * Additional attributes of the sender account in key:value format (e.g. sender_id: 1234). It supports up to 10 key:value pairs, whereas the key and value supports up to 50 and 1000 characters respectively.
   * @type {{ [key: string]: string; }}
   * @memberof PaymentAccountDetailsWithEnrichedData
   */
  metadata?: { [key: string]: string };
  /**
   * Timestamp of when the payment link was created in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
   * @type {string}
   * @memberof PaymentAccountDetailsWithEnrichedData
   */
  created_at?: string;
  /**
   * Timestamp of when the payment link was last updated in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
   * @type {string}
   * @memberof PaymentAccountDetailsWithEnrichedData
   */
  updated_at?: string;
  /**
   *
   * @type {PaymentMethodOverview}
   * @memberof PaymentAccountDetailsWithEnrichedData
   */
  payment_method_overview?: PaymentMethodOverview;
}

export const PaymentAccountDetailsWithEnrichedDataAccountTypeEnum = {
  ExternalAccount: 'EXTERNAL_ACCOUNT',
  SettlementAccount: 'SETTLEMENT_ACCOUNT',
} as const;

export type PaymentAccountDetailsWithEnrichedDataAccountTypeEnum =
  (typeof PaymentAccountDetailsWithEnrichedDataAccountTypeEnum)[keyof typeof PaymentAccountDetailsWithEnrichedDataAccountTypeEnum];

/**
 *
 * @export
 * @interface PaymentDetails
 */
export interface PaymentDetails {
  /**
   *
   * @type {string}
   * @memberof PaymentDetails
   */
  format?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentDetails
   */
  bic?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentDetails
   */
  bank_fullname?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentDetails
   */
  bank_shortname?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentDetails
   */
  bank_address?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentDetails
   */
  bank_country?: string;
  /**
   *
   * @type {OtherInfo}
   * @memberof PaymentDetails
   */
  other_info?: OtherInfo;
}
/**
 *
 * @export
 * @interface PaymentDetails2
 */
export interface PaymentDetails2 {
  /**
   * The transaction description provided to banks, which banks will show to their customers.
   * @type {string}
   * @memberof PaymentDetails2
   */
  description?: string;
  /**
   * ID of the mandate this pament is referring to.
   * @type {string}
   * @memberof PaymentDetails2
   */
  mandate_id?: string;
  /**
   * Deprecated: Customer\'s ID for this transaction
   * @type {string}
   * @memberof PaymentDetails2
   */
  transaction_reference_id?: string;
  /**
   * Customer reference for this transaction
   * @type {string}
   * @memberof PaymentDetails2
   */
  external_transaction_reference?: string;
  /**
   *
   * @type {PaymentDetailsReferences}
   * @memberof PaymentDetails2
   */
  references?: PaymentDetailsReferences;
  /**
   *
   * @type {string}
   * @memberof PaymentDetails2
   */
  processor_entity_name?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentDetails2
   */
  collection_entity_name?: string;
  /**
   *
   * @type {PaymentProcessorDetails}
   * @memberof PaymentDetails2
   */
  processor_details?: PaymentProcessorDetails;
  /**
   * The recurring payment mode
   * @type {string}
   * @memberof PaymentDetails2
   */
  recurring_payment_mode?: string;
}
/**
 *
 * @export
 * @interface PaymentDetailsReferences
 */
export interface PaymentDetailsReferences {
  /**
   *
   * @type {string}
   * @memberof PaymentDetailsReferences
   */
  finverse_transaction_reference?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentDetailsReferences
   */
  dda_reference?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentDetailsReferences
   */
  bank_transaction_reference?: string;
}
/**
 *
 * @export
 * @interface PaymentFvLinkDetails
 */
export interface PaymentFvLinkDetails {
  /**
   *
   * @type {string}
   * @memberof PaymentFvLinkDetails
   */
  collection_entity_name?: string;
}
/**
 *
 * @export
 * @interface PaymentFvLinkResponse
 */
export interface PaymentFvLinkResponse {
  /**
   *
   * @type {string}
   * @memberof PaymentFvLinkResponse
   */
  payment_id?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentFvLinkResponse
   */
  status?: PaymentFvLinkResponseStatusEnum;
  /**
   *
   * @type {string}
   * @memberof PaymentFvLinkResponse
   */
  type?: PaymentFvLinkResponseTypeEnum;
  /**
   *
   * @type {PaymentFvLinkDetails}
   * @memberof PaymentFvLinkResponse
   */
  payment_details?: PaymentFvLinkDetails;
  /**
   *
   * @type {FvEmbeddedErrorModel}
   * @memberof PaymentFvLinkResponse
   */
  error?: FvEmbeddedErrorModel;
}

export const PaymentFvLinkResponseStatusEnum = {
  AuthorizationRequired: 'AUTHORIZATION_REQUIRED',
  Authorizing: 'AUTHORIZING',
  Processing: 'PROCESSING',
  Submitted: 'SUBMITTED',
  Executed: 'EXECUTED',
  Failed: 'FAILED',
  Revoked: 'REVOKED',
  Cancelled: 'CANCELLED',
  Created: 'CREATED',
} as const;

export type PaymentFvLinkResponseStatusEnum =
  (typeof PaymentFvLinkResponseStatusEnum)[keyof typeof PaymentFvLinkResponseStatusEnum];
export const PaymentFvLinkResponseTypeEnum = {
  Mandate: 'MANDATE',
  Single: 'SINGLE',
  Card: 'CARD',
  Manual: 'MANUAL',
} as const;

export type PaymentFvLinkResponseTypeEnum =
  (typeof PaymentFvLinkResponseTypeEnum)[keyof typeof PaymentFvLinkResponseTypeEnum];

/**
 *
 * @export
 * @interface PaymentInfo
 */
export interface PaymentInfo {
  /**
   *
   * @type {Array<string>}
   * @memberof PaymentInfo
   */
  currencies_supported?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof PaymentInfo
   */
  payments_supported: Array<PaymentInfoPaymentsSupportedEnum>;
  /**
   *
   * @type {OtherInfo}
   * @memberof PaymentInfo
   */
  other_info?: OtherInfo;
}

export const PaymentInfoPaymentsSupportedEnum = {
  Mandate: 'MANDATE',
  DebitAuthorization: 'DEBIT_AUTHORIZATION',
} as const;

export type PaymentInfoPaymentsSupportedEnum =
  (typeof PaymentInfoPaymentsSupportedEnum)[keyof typeof PaymentInfoPaymentsSupportedEnum];

/**
 *
 * @export
 * @interface PaymentInstruction
 */
export interface PaymentInstruction {
  /**
   * An id of the this payment
   * @type {string}
   * @memberof PaymentInstruction
   */
  payment_instruction_id?: string;
  /**
   * An id of the user of this payment, need to equal to userId when creating link
   * @type {string}
   * @memberof PaymentInstruction
   */
  user_id?: string;
  /**
   * An id that links this payment to a specific Login Identity
   * @type {string}
   * @memberof PaymentInstruction
   */
  login_identity_id?: string;
  /**
   * Type of payment that was created, please check Documentation on which payment type is supported in each institution
   * @type {string}
   * @memberof PaymentInstruction
   */
  type?: PaymentInstructionTypeEnum;
  /**
   * The recipient name
   * @type {string}
   * @memberof PaymentInstruction
   */
  recipient_name?: string;
  /**
   * The recipient account Id
   * @type {string}
   * @memberof PaymentInstruction
   */
  recipient_account_id?: string;
  /**
   * The sender name
   * @type {string}
   * @memberof PaymentInstruction
   */
  sender_name?: string;
  /**
   *
   * @type {PaymentAccount}
   * @memberof PaymentInstruction
   */
  sender_account?: PaymentAccount;
  /**
   * The sender account Id
   * @type {string}
   * @memberof PaymentInstruction
   */
  sender_account_id?: string;
  /**
   * When the payment should start
   * @type {string}
   * @memberof PaymentInstruction
   */
  start_date?: string | null;
  /**
   * When the payment should stop
   * @type {string}
   * @memberof PaymentInstruction
   */
  end_date?: string | null;
  /**
   * The currency for the payment
   * @type {string}
   * @memberof PaymentInstruction
   */
  currency?: string;
  /**
   * The payment amount
   * @type {number}
   * @memberof PaymentInstruction
   */
  amount?: number;
  /**
   * How often the payment should be executed
   * @type {string}
   * @memberof PaymentInstruction
   */
  frequency?: string;
  /**
   * Related remarks about this instruction
   * @type {string}
   * @memberof PaymentInstruction
   */
  remarks?: string;
  /**
   * Status of the payment
   * @type {string}
   * @memberof PaymentInstruction
   */
  status?: string;
  /**
   * Reference identification returned by institution
   * @type {string}
   * @memberof PaymentInstruction
   */
  reference_id?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentInstruction
   */
  last_update?: string;
  /**
   * Extra information collected for this payment instruction
   * @type {object}
   * @memberof PaymentInstruction
   */
  info?: object;
}

export const PaymentInstructionTypeEnum = {
  DebitAuthorization: 'DEBIT_AUTHORIZATION',
} as const;

export type PaymentInstructionTypeEnum = (typeof PaymentInstructionTypeEnum)[keyof typeof PaymentInstructionTypeEnum];

/**
 *
 * @export
 * @interface PaymentLinkCustomizations
 */
export interface PaymentLinkCustomizations {
  /**
   * ISO639-1 language code. Language to display when user open the link, default to English (en) if not specified
   * @type {string}
   * @memberof PaymentLinkCustomizations
   */
  language?: PaymentLinkCustomizationsLanguageEnum;
  /**
   * The UI mode link is intended to be used in - \"iframe\", \"auto_redirect\", \"redirect\" or \"standalone\"
   * @type {string}
   * @memberof PaymentLinkCustomizations
   */
  ui_mode?: PaymentLinkCustomizationsUiModeEnum;
  /**
   * URI to redirect to. Only needed if ui_mode = redirect
   * @type {string}
   * @memberof PaymentLinkCustomizations
   */
  redirect_uri?: string;
}

export const PaymentLinkCustomizationsLanguageEnum = {
  En: 'en',
  Vi: 'vi',
  Zh: 'zh',
  Ko: 'ko',
} as const;

export type PaymentLinkCustomizationsLanguageEnum =
  (typeof PaymentLinkCustomizationsLanguageEnum)[keyof typeof PaymentLinkCustomizationsLanguageEnum];
export const PaymentLinkCustomizationsUiModeEnum = {
  Iframe: 'iframe',
  Redirect: 'redirect',
  AutoRedirect: 'auto_redirect',
  Standalone: 'standalone',
} as const;

export type PaymentLinkCustomizationsUiModeEnum =
  (typeof PaymentLinkCustomizationsUiModeEnum)[keyof typeof PaymentLinkCustomizationsUiModeEnum];

/**
 *
 * @export
 * @interface PaymentLinkDetails
 */
export interface PaymentLinkDetails {
  /**
   *
   * @type {string}
   * @memberof PaymentLinkDetails
   */
  description: string;
  /**
   * For external invoice/transaction reference
   * @type {string}
   * @memberof PaymentLinkDetails
   */
  external_transaction_reference: string;
}
/**
 *
 * @export
 * @interface PaymentLinkResponse
 */
export interface PaymentLinkResponse {
  /**
   * Finverse Payment Link ID
   * @type {string}
   * @memberof PaymentLinkResponse
   */
  payment_link_id?: string;
  /**
   * The amount of the payment. Expressed in currency\'s smallest unit or “minor unit”, as defined in ISO 4217.
   * @type {number}
   * @memberof PaymentLinkResponse
   */
  amount?: number;
  /**
   *
   * @type {string}
   * @memberof PaymentLinkResponse
   */
  currency?: string;
  /**
   *
   * @type {PaymentLinkCustomizations}
   * @memberof PaymentLinkResponse
   */
  link_customizations?: PaymentLinkCustomizations;
  /**
   * The payment link mode
   * @type {string}
   * @memberof PaymentLinkResponse
   */
  mode?: PaymentLinkResponseModeEnum;
  /**
   *
   * @type {PaymentLinkDetails}
   * @memberof PaymentLinkResponse
   */
  payment_details?: PaymentLinkDetails;
  /**
   * Unique reference id to identifying the payment to be collected.
   * @type {string}
   * @memberof PaymentLinkResponse
   */
  unique_reference_id?: string;
  /**
   *
   * @type {PaymentSetupOptions}
   * @memberof PaymentLinkResponse
   */
  payment_setup_options?: PaymentSetupOptions;
  /**
   * Additional attributes of the payment link in key:value format (e.g. payment_id: 1234). It supports up to 10 key:value pairs, whereas the key and value supports up to 50 and 1000 characters respectively.
   * @type {{ [key: string]: string; }}
   * @memberof PaymentLinkResponse
   */
  metadata?: { [key: string]: string };
  /**
   * Key-Value metadata to store on payments created on this Payment Link
   * @type {{ [key: string]: string; }}
   * @memberof PaymentLinkResponse
   */
  payment_metadata?: { [key: string]: string };
  /**
   * The URL for payment link
   * @type {string}
   * @memberof PaymentLinkResponse
   */
  url?: string;
  /**
   * The status of payment link
   * @type {string}
   * @memberof PaymentLinkResponse
   */
  status?: PaymentLinkResponseStatusEnum;
  /**
   * The session status of payment link
   * @type {string}
   * @memberof PaymentLinkResponse
   */
  session_status?: PaymentLinkResponseSessionStatusEnum;
  /**
   * Timestamp of when the payment link was or will expired in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
   * @type {string}
   * @memberof PaymentLinkResponse
   */
  expires_at?: string;
  /**
   * Timestamp of when the payment link was created in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
   * @type {string}
   * @memberof PaymentLinkResponse
   */
  created_at?: string;
  /**
   * Timestamp of when the payment link was last updated in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
   * @type {string}
   * @memberof PaymentLinkResponse
   */
  updated_at?: string;
  /**
   *
   * @type {PaymentResponse}
   * @memberof PaymentLinkResponse
   */
  payment?: PaymentResponse;
  /**
   *
   * @type {PaymentLinkSenderResponse}
   * @memberof PaymentLinkResponse
   */
  sender?: PaymentLinkSenderResponse;
  /**
   *
   * @type {PaymentMethodResponse}
   * @memberof PaymentLinkResponse
   */
  payment_method?: PaymentMethodResponse;
  /**
   *
   * @type {IntegrationMetadataResponse}
   * @memberof PaymentLinkResponse
   */
  integration_metadata?: IntegrationMetadataResponse;
}

export const PaymentLinkResponseModeEnum = {
  Payment: 'PAYMENT',
} as const;

export type PaymentLinkResponseModeEnum =
  (typeof PaymentLinkResponseModeEnum)[keyof typeof PaymentLinkResponseModeEnum];
export const PaymentLinkResponseStatusEnum = {
  Created: 'CREATED',
  Paid: 'PAID',
  Expired: 'EXPIRED',
} as const;

export type PaymentLinkResponseStatusEnum =
  (typeof PaymentLinkResponseStatusEnum)[keyof typeof PaymentLinkResponseStatusEnum];
export const PaymentLinkResponseSessionStatusEnum = {
  Open: 'OPEN',
  Processing: 'PROCESSING',
  Complete: 'COMPLETE',
  Failed: 'FAILED',
} as const;

export type PaymentLinkResponseSessionStatusEnum =
  (typeof PaymentLinkResponseSessionStatusEnum)[keyof typeof PaymentLinkResponseSessionStatusEnum];

/**
 *
 * @export
 * @interface PaymentLinkSender
 */
export interface PaymentLinkSender {
  /**
   *
   * @type {string}
   * @memberof PaymentLinkSender
   */
  email?: string;
  /**
   * Customer App\'s user ID, representing the end-user making the payment.
   * @type {string}
   * @memberof PaymentLinkSender
   */
  external_user_id: string;
  /**
   * Accountholder name of the sender\'s account
   * @type {string}
   * @memberof PaymentLinkSender
   */
  name: string;
}
/**
 *
 * @export
 * @interface PaymentLinkSenderResponse
 */
export interface PaymentLinkSenderResponse {
  /**
   *
   * @type {string}
   * @memberof PaymentLinkSenderResponse
   */
  email?: string;
  /**
   * Customer App\'s user ID, representing the end-user making the payment.
   * @type {string}
   * @memberof PaymentLinkSenderResponse
   */
  external_user_id?: string;
  /**
   * Accountholder name of the sender\'s account
   * @type {string}
   * @memberof PaymentLinkSenderResponse
   */
  name?: string;
  /**
   * A unique identifier generated after creating sender
   * @type {string}
   * @memberof PaymentLinkSenderResponse
   */
  user_id?: string;
}
/**
 *
 * @export
 * @interface PaymentLinkTokenResponse
 */
export interface PaymentLinkTokenResponse {
  /**
   * Short-lived access-token to interact with Finverse Link
   * @type {string}
   * @memberof PaymentLinkTokenResponse
   */
  access_token: string;
  /**
   * Access token validity duration (in seconds)
   * @type {number}
   * @memberof PaymentLinkTokenResponse
   */
  expires_in: number;
  /**
   * URL to launch Finverse Link to authorize the mandate
   * @type {string}
   * @memberof PaymentLinkTokenResponse
   */
  link_url: string;
  /**
   *
   * @type {string}
   * @memberof PaymentLinkTokenResponse
   */
  token_type: PaymentLinkTokenResponseTokenTypeEnum;
}

export const PaymentLinkTokenResponseTokenTypeEnum = {
  Bearer: 'Bearer',
} as const;

export type PaymentLinkTokenResponseTokenTypeEnum =
  (typeof PaymentLinkTokenResponseTokenTypeEnum)[keyof typeof PaymentLinkTokenResponseTokenTypeEnum];

/**
 *
 * @export
 * @interface PaymentMethodFvLinkResponse
 */
export interface PaymentMethodFvLinkResponse {
  /**
   *
   * @type {string}
   * @memberof PaymentMethodFvLinkResponse
   */
  payment_method_id?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentMethodFvLinkResponse
   */
  payment_method_type?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentMethodFvLinkResponse
   */
  recipient_entity_name?: string;
  /**
   *
   * @type {MandateFvLinkResponse}
   * @memberof PaymentMethodFvLinkResponse
   */
  mandate?: MandateFvLinkResponse;
  /**
   *
   * @type {CardFvLinkResponse}
   * @memberof PaymentMethodFvLinkResponse
   */
  card?: CardFvLinkResponse;
}
/**
 *
 * @export
 * @interface PaymentMethodIntegrationMetadata
 */
export interface PaymentMethodIntegrationMetadata {
  /**
   *
   * @type {string}
   * @memberof PaymentMethodIntegrationMetadata
   */
  integration_id: PaymentMethodIntegrationMetadataIntegrationIdEnum;
  /**
   *
   * @type {PaymentMethodIntegrationMetadataStripeMetadata}
   * @memberof PaymentMethodIntegrationMetadata
   */
  stripe_metadata?: PaymentMethodIntegrationMetadataStripeMetadata;
  /**
   *
   * @type {PaymentMethodIntegrationMetadataCybersourceMetadata}
   * @memberof PaymentMethodIntegrationMetadata
   */
  cybersource_metadata?: PaymentMethodIntegrationMetadataCybersourceMetadata;
  /**
   *
   * @type {PaymentMethodIntegrationMetadataAdyenMetadata}
   * @memberof PaymentMethodIntegrationMetadata
   */
  adyen_metadata?: PaymentMethodIntegrationMetadataAdyenMetadata;
}

export const PaymentMethodIntegrationMetadataIntegrationIdEnum = {
  Stripe: 'STRIPE',
  Cybersource: 'CYBERSOURCE',
  Adyen: 'ADYEN',
} as const;

export type PaymentMethodIntegrationMetadataIntegrationIdEnum =
  (typeof PaymentMethodIntegrationMetadataIntegrationIdEnum)[keyof typeof PaymentMethodIntegrationMetadataIntegrationIdEnum];

/**
 *
 * @export
 * @interface PaymentMethodIntegrationMetadataAdyenMetadata
 */
export interface PaymentMethodIntegrationMetadataAdyenMetadata {
  /**
   *
   * @type {string}
   * @memberof PaymentMethodIntegrationMetadataAdyenMetadata
   */
  payment_method_id: string;
  /**
   *
   * @type {string}
   * @memberof PaymentMethodIntegrationMetadataAdyenMetadata
   */
  auth_code?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentMethodIntegrationMetadataAdyenMetadata
   */
  psp_reference?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentMethodIntegrationMetadataAdyenMetadata
   */
  recurring_processing_model?: PaymentMethodIntegrationMetadataAdyenMetadataRecurringProcessingModelEnum;
  /**
   *
   * @type {string}
   * @memberof PaymentMethodIntegrationMetadataAdyenMetadata
   */
  network_transaction_reference?: string;
}

export const PaymentMethodIntegrationMetadataAdyenMetadataRecurringProcessingModelEnum = {
  CardOnFile: 'CardOnFile',
  UnscheduledCardOnFile: 'UnscheduledCardOnFile',
  Subscription: 'Subscription',
} as const;

export type PaymentMethodIntegrationMetadataAdyenMetadataRecurringProcessingModelEnum =
  (typeof PaymentMethodIntegrationMetadataAdyenMetadataRecurringProcessingModelEnum)[keyof typeof PaymentMethodIntegrationMetadataAdyenMetadataRecurringProcessingModelEnum];

/**
 *
 * @export
 * @interface PaymentMethodIntegrationMetadataCybersourceMetadata
 */
export interface PaymentMethodIntegrationMetadataCybersourceMetadata {
  /**
   *
   * @type {string}
   * @memberof PaymentMethodIntegrationMetadataCybersourceMetadata
   */
  payment_token: string;
}
/**
 *
 * @export
 * @interface PaymentMethodIntegrationMetadataStripeMetadata
 */
export interface PaymentMethodIntegrationMetadataStripeMetadata {
  /**
   *
   * @type {PaymentMethodIntegrationMetadataStripeMetadataCustomer}
   * @memberof PaymentMethodIntegrationMetadataStripeMetadata
   */
  customer: PaymentMethodIntegrationMetadataStripeMetadataCustomer;
  /**
   *
   * @type {PaymentMethodIntegrationMetadataStripeMetadataCustomer}
   * @memberof PaymentMethodIntegrationMetadataStripeMetadata
   */
  payment_method: PaymentMethodIntegrationMetadataStripeMetadataCustomer;
}
/**
 *
 * @export
 * @interface PaymentMethodIntegrationMetadataStripeMetadataCustomer
 */
export interface PaymentMethodIntegrationMetadataStripeMetadataCustomer {
  /**
   *
   * @type {string}
   * @memberof PaymentMethodIntegrationMetadataStripeMetadataCustomer
   */
  id: string;
}
/**
 *
 * @export
 * @interface PaymentMethodOverview
 */
export interface PaymentMethodOverview {
  /**
   * STRIPE, CYBERSOURCE, UOB, DBS (only shown when payment flows funds via a 3rd party gateway direct to the customer)
   * @type {string}
   * @memberof PaymentMethodOverview
   */
  external_gateway?: string;
  /**
   * It can be either REALTIME or DELAYED
   * @type {string}
   * @memberof PaymentMethodOverview
   */
  payment_confirmation_speed?: string;
  /**
   * The payment method type, possible values CARD, MANDATE and MANUAL
   * @type {string}
   * @memberof PaymentMethodOverview
   */
  payment_method_type?: string;
  /**
   * The payment method subtype, e.g., EDDA_HK, CARD_GENERIC etc
   * @type {string}
   * @memberof PaymentMethodOverview
   */
  payment_method_subtype?: string;
  /**
   * Only shown if funds flow via Finverse, possible values FINVERSE
   * @type {string}
   * @memberof PaymentMethodOverview
   */
  payment_processor?: string;
  /**
   * Whether the payment method can move real money or not
   * @type {boolean}
   * @memberof PaymentMethodOverview
   */
  live_mode: boolean;
  /**
   * Shows which currencies are supported
   * @type {Array<string>}
   * @memberof PaymentMethodOverview
   */
  supported_currencies?: Array<string>;
}
/**
 *
 * @export
 * @interface PaymentMethodResponse
 */
export interface PaymentMethodResponse {
  /**
   *
   * @type {string}
   * @memberof PaymentMethodResponse
   */
  payment_method_id?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentMethodResponse
   */
  payment_method_type?: string;
  /**
   *
   * @type {GetMandateResponse}
   * @memberof PaymentMethodResponse
   */
  mandate?: GetMandateResponse;
  /**
   *
   * @type {FVCard}
   * @memberof PaymentMethodResponse
   */
  card?: FVCard;
  /**
   *
   * @type {PaymentMethodIntegrationMetadata}
   * @memberof PaymentMethodResponse
   */
  integration_metadata?: PaymentMethodIntegrationMetadata;
}
/**
 *
 * @export
 * @interface PaymentProcessorDetails
 */
export interface PaymentProcessorDetails {
  /**
   *
   * @type {string}
   * @memberof PaymentProcessorDetails
   */
  auth_code?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentProcessorDetails
   */
  processor_id?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentProcessorDetails
   */
  processor_reference?: string;
  /**
   *
   * @type {PaymentProcessorResult}
   * @memberof PaymentProcessorDetails
   */
  result?: PaymentProcessorResult;
}
/**
 *
 * @export
 * @interface PaymentProcessorResult
 */
export interface PaymentProcessorResult {
  /**
   * Payment processor\'s decline code (e.g. \"2\")
   * @type {string}
   * @memberof PaymentProcessorResult
   */
  decline_code?: string;
  /**
   * Payment processor\'s decline explanation (e.g. \"Blocked card\")
   * @type {string}
   * @memberof PaymentProcessorResult
   */
  decline_reason?: string;
  /**
   * Payment processor\'s result code (e.g. \"Authorized\", \"Refused\").
   * @type {string}
   * @memberof PaymentProcessorResult
   */
  result_code?: string;
}
/**
 *
 * @export
 * @interface PaymentResponse
 */
export interface PaymentResponse {
  /**
   * Finverse Payment ID
   * @type {string}
   * @memberof PaymentResponse
   */
  payment_id?: string;
  /**
   * Amount to be paid, in currency\'s smallest unit or “minor unit”, as defined in ISO 4217. For example, HKD 100.01 is represented as amount = 10001 (minor unit = cents). For currencies without minor units (e.g. VND, JPY), the amount is represented as is, without modification. For example, VND 15101 is represented as amount = 15101.
   * @type {number}
   * @memberof PaymentResponse
   */
  amount: number;
  /**
   * Surcharge amount in minor
   * @type {number}
   * @memberof PaymentResponse
   */
  surcharge_amount: number;
  /**
   * Amount with all fees and surcharges applied in minor
   * @type {number}
   * @memberof PaymentResponse
   */
  amount_total_with_surcharge: number;
  /**
   * The currency code as defined in ISO 4217.
   * @type {string}
   * @memberof PaymentResponse
   */
  currency?: string;
  /**
   * Indicates whether this is a mandate-based payment or one-off direct payment to an account. Possible values - MANDATE, SINGLE
   * @type {string}
   * @memberof PaymentResponse
   */
  type?: PaymentResponseTypeEnum;
  /**
   * Timestamp in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
   * @type {string}
   * @memberof PaymentResponse
   */
  updated_at?: string;
  /**
   * Possible values - CREATED, AUTHORIZED, SUBMITTED, EXECUTED, FAILED, REJECTED, CANCELLED.
   * @type {string}
   * @memberof PaymentResponse
   */
  status?: PaymentResponseStatusEnum;
  /**
   * ID of the payment method this pament is referring to.
   * @type {string}
   * @memberof PaymentResponse
   */
  payment_method_id?: string;
  /**
   *
   * @type {PaymentDetails2}
   * @memberof PaymentResponse
   */
  payment_details?: PaymentDetails2;
  /**
   *
   * @type {MandateRecipient}
   * @memberof PaymentResponse
   */
  recipient?: MandateRecipient;
  /**
   *
   * @type {MandateRecipientAccount}
   * @memberof PaymentResponse
   */
  recipient_account?: MandateRecipientAccount;
  /**
   *
   * @type {GetMandateSender}
   * @memberof PaymentResponse
   */
  sender?: GetMandateSender;
  /**
   *
   * @type {MandateSenderAccount}
   * @memberof PaymentResponse
   */
  sender_account?: MandateSenderAccount;
  /**
   *
   * @type {Array<Fee>}
   * @memberof PaymentResponse
   */
  fees?: Array<Fee>;
  /**
   * Timestamp in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
   * @type {string}
   * @memberof PaymentResponse
   */
  created_at?: string;
  /**
   * Additional attributes of the payment in key:value format (e.g. payment_internal_id: 1234). It supports up to 10 key:value pairs, whereas the key and value supports up to 50 and 1000 characters respectively.
   * @type {{ [key: string]: string; }}
   * @memberof PaymentResponse
   */
  metadata?: { [key: string]: string };
  /**
   *
   * @type {FvEmbeddedErrorModel}
   * @memberof PaymentResponse
   */
  error?: FvEmbeddedErrorModel;
  /**
   *
   * @type {PaymentSnapshotPaymentMethod}
   * @memberof PaymentResponse
   */
  payment_method?: PaymentSnapshotPaymentMethod;
}

export const PaymentResponseTypeEnum = {
  Mandate: 'MANDATE',
  Single: 'SINGLE',
  Card: 'CARD',
  Manual: 'MANUAL',
} as const;

export type PaymentResponseTypeEnum = (typeof PaymentResponseTypeEnum)[keyof typeof PaymentResponseTypeEnum];
export const PaymentResponseStatusEnum = {
  AuthorizationRequired: 'AUTHORIZATION_REQUIRED',
  Authorizing: 'AUTHORIZING',
  Processing: 'PROCESSING',
  Submitted: 'SUBMITTED',
  Executed: 'EXECUTED',
  Failed: 'FAILED',
  Revoked: 'REVOKED',
  Cancelled: 'CANCELLED',
  Created: 'CREATED',
} as const;

export type PaymentResponseStatusEnum = (typeof PaymentResponseStatusEnum)[keyof typeof PaymentResponseStatusEnum];

/**
 *
 * @export
 * @interface PaymentSchedule
 */
export interface PaymentSchedule {
  /**
   * Amount to be paid, in currency’s smallest unit or “minor unit”, as defined in ISO 4217. For example, HKD 100.01 is represented as amount = 10001 (minor unit = cents). For currencies without minor units (e.g. VND, JPY), the amount is represented as is, without modification. For example, VND 15101 is represented as amount = 15101.
   * @type {number}
   * @memberof PaymentSchedule
   */
  amount: number;
  /**
   * Frequency of the payment. Possible values (DAILY, WEEKLY, MONTHLY, QUARTERLY, YEARLY)
   * @type {string}
   * @memberof PaymentSchedule
   */
  frequency: PaymentScheduleFrequencyEnum;
}

export const PaymentScheduleFrequencyEnum = {
  Daily: 'DAILY',
  Weekly: 'WEEKLY',
  Monthly: 'MONTHLY',
  Quarterly: 'QUARTERLY',
  Yearly: 'YEARLY',
} as const;

export type PaymentScheduleFrequencyEnum =
  (typeof PaymentScheduleFrequencyEnum)[keyof typeof PaymentScheduleFrequencyEnum];

/**
 *
 * @export
 * @interface PaymentSetupOptions
 */
export interface PaymentSetupOptions {
  /**
   * The type of future_payments that customer want to use. Possible values: AUTOPAY or CLICK_TO_PAY
   * @type {string}
   * @memberof PaymentSetupOptions
   */
  future_payments?: PaymentSetupOptionsFuturePaymentsEnum;
  /**
   *
   * @type {MandateDetailsForPaymentLink}
   * @memberof PaymentSetupOptions
   */
  mandate_details?: MandateDetailsForPaymentLink;
  /**
   *
   * @type {Array<string>}
   * @memberof PaymentSetupOptions
   */
  payment_method_types?: Array<PaymentSetupOptionsPaymentMethodTypesEnum>;
  /**
   *
   * @type {RecipientAccountFilters}
   * @memberof PaymentSetupOptions
   */
  recipient_account_filters?: RecipientAccountFilters;
  /**
   *
   * @type {AutopayEnrollmentConfiguration}
   * @memberof PaymentSetupOptions
   */
  autopay_enrollment_configuration?: AutopayEnrollmentConfiguration;
  /**
   * The recurring payment mode
   * @type {string}
   * @memberof PaymentSetupOptions
   */
  recurring_payment_mode?: string;
}

export const PaymentSetupOptionsFuturePaymentsEnum = {
  Autopay: 'AUTOPAY',
  ClickToPay: 'CLICK_TO_PAY',
} as const;

export type PaymentSetupOptionsFuturePaymentsEnum =
  (typeof PaymentSetupOptionsFuturePaymentsEnum)[keyof typeof PaymentSetupOptionsFuturePaymentsEnum];
export const PaymentSetupOptionsPaymentMethodTypesEnum = {
  Mandate: 'MANDATE',
  Single: 'SINGLE',
  Card: 'CARD',
  Manual: 'MANUAL',
} as const;

export type PaymentSetupOptionsPaymentMethodTypesEnum =
  (typeof PaymentSetupOptionsPaymentMethodTypesEnum)[keyof typeof PaymentSetupOptionsPaymentMethodTypesEnum];

/**
 *
 * @export
 * @interface PaymentSetupOptionsRequest
 */
export interface PaymentSetupOptionsRequest {
  /**
   * The type of future_payments that customer want to use. Possible values: AUTOPAY or CLICK_TO_PAY
   * @type {string}
   * @memberof PaymentSetupOptionsRequest
   */
  future_payments?: PaymentSetupOptionsRequestFuturePaymentsEnum;
  /**
   *
   * @type {MandateDetailsForPaymentLinkRequest}
   * @memberof PaymentSetupOptionsRequest
   */
  mandate_details?: MandateDetailsForPaymentLinkRequest;
  /**
   *
   * @type {Array<string>}
   * @memberof PaymentSetupOptionsRequest
   */
  payment_method_types?: Array<PaymentSetupOptionsRequestPaymentMethodTypesEnum>;
  /**
   *
   * @type {RecipientAccountFilters}
   * @memberof PaymentSetupOptionsRequest
   */
  recipient_account_filters?: RecipientAccountFilters;
  /**
   *
   * @type {AutopayEnrollmentConfiguration}
   * @memberof PaymentSetupOptionsRequest
   */
  autopay_enrollment_configuration?: AutopayEnrollmentConfiguration;
  /**
   * The recurring payment mode
   * @type {string}
   * @memberof PaymentSetupOptionsRequest
   */
  recurring_payment_mode?: string;
}

export const PaymentSetupOptionsRequestFuturePaymentsEnum = {
  Autopay: 'AUTOPAY',
  ClickToPay: 'CLICK_TO_PAY',
} as const;

export type PaymentSetupOptionsRequestFuturePaymentsEnum =
  (typeof PaymentSetupOptionsRequestFuturePaymentsEnum)[keyof typeof PaymentSetupOptionsRequestFuturePaymentsEnum];
export const PaymentSetupOptionsRequestPaymentMethodTypesEnum = {
  Mandate: 'MANDATE',
  Single: 'SINGLE',
  Card: 'CARD',
  Manual: 'MANUAL',
} as const;

export type PaymentSetupOptionsRequestPaymentMethodTypesEnum =
  (typeof PaymentSetupOptionsRequestPaymentMethodTypesEnum)[keyof typeof PaymentSetupOptionsRequestPaymentMethodTypesEnum];

/**
 *
 * @export
 * @interface PaymentSnapshotPaymentMethod
 */
export interface PaymentSnapshotPaymentMethod {
  /**
   *
   * @type {PaymentSnapshotPaymentMethodCard}
   * @memberof PaymentSnapshotPaymentMethod
   */
  card?: PaymentSnapshotPaymentMethodCard;
}
/**
 *
 * @export
 * @interface PaymentSnapshotPaymentMethodCard
 */
export interface PaymentSnapshotPaymentMethodCard {
  /**
   *
   * @type {FVCardDetails}
   * @memberof PaymentSnapshotPaymentMethodCard
   */
  card_details?: FVCardDetails;
}
/**
 *
 * @export
 * @interface PaymentUser
 */
export interface PaymentUser {
  /**
   *
   * @type {string}
   * @memberof PaymentUser
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentUser
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentUser
   */
  external_user_id?: string;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof PaymentUser
   */
  metadata?: { [key: string]: string };
  /**
   *
   * @type {string}
   * @memberof PaymentUser
   */
  name?: string;
  /**
   *
   * @type {Array<SenderDetail>}
   * @memberof PaymentUser
   */
  user_details?: Array<SenderDetail>;
  /**
   *
   * @type {string}
   * @memberof PaymentUser
   */
  updated_at?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentUser
   */
  next_bill_update?: string | null;
  /**
   *
   * @type {string}
   * @memberof PaymentUser
   */
  user_id?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentUser
   */
  user_type?: PaymentUserUserTypeEnum;
  /**
   * Whether the user has given consent for autopay
   * @type {boolean}
   * @memberof PaymentUser
   */
  autopay_consent: boolean;
  /**
   *
   * @type {IntegrationMetadataResponse}
   * @memberof PaymentUser
   */
  integration_metadata?: IntegrationMetadataResponse;
}

export const PaymentUserUserTypeEnum = {
  Individual: 'INDIVIDUAL',
  Business: 'BUSINESS',
} as const;

export type PaymentUserUserTypeEnum = (typeof PaymentUserUserTypeEnum)[keyof typeof PaymentUserUserTypeEnum];

/**
 *
 * @export
 * @interface PaymentUserWithoutEmail
 */
export interface PaymentUserWithoutEmail {
  /**
   *
   * @type {string}
   * @memberof PaymentUserWithoutEmail
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentUserWithoutEmail
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentUserWithoutEmail
   */
  external_user_id?: string;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof PaymentUserWithoutEmail
   */
  metadata?: { [key: string]: string };
  /**
   *
   * @type {string}
   * @memberof PaymentUserWithoutEmail
   */
  name?: string;
  /**
   *
   * @type {Array<SenderDetail>}
   * @memberof PaymentUserWithoutEmail
   */
  user_details?: Array<SenderDetail>;
  /**
   *
   * @type {string}
   * @memberof PaymentUserWithoutEmail
   */
  updated_at?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentUserWithoutEmail
   */
  next_bill_update?: string | null;
  /**
   *
   * @type {string}
   * @memberof PaymentUserWithoutEmail
   */
  user_id?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentUserWithoutEmail
   */
  user_type?: PaymentUserWithoutEmailUserTypeEnum;
  /**
   * Whether the user has given consent for autopay
   * @type {boolean}
   * @memberof PaymentUserWithoutEmail
   */
  autopay_consent: boolean;
  /**
   *
   * @type {IntegrationMetadataResponse}
   * @memberof PaymentUserWithoutEmail
   */
  integration_metadata?: IntegrationMetadataResponse;
}

export const PaymentUserWithoutEmailUserTypeEnum = {
  Individual: 'INDIVIDUAL',
  Business: 'BUSINESS',
} as const;

export type PaymentUserWithoutEmailUserTypeEnum =
  (typeof PaymentUserWithoutEmailUserTypeEnum)[keyof typeof PaymentUserWithoutEmailUserTypeEnum];

/**
 *
 * @export
 * @interface PayoutDetails
 */
export interface PayoutDetails {
  /**
   * The mandate used to execute payments for this payout instruction. Currency for the mandate must be supported by the recipient account
   * @type {string}
   * @memberof PayoutDetails
   */
  mandate_id: string;
  /**
   * A description for the payment (that will appear as the transaction description on bank statements)
   * @type {string}
   * @memberof PayoutDetails
   */
  description?: string;
  /**
   * YYYY-MM-DD, date (in UTC) to execute the payment, must be 1 day later than current date
   * @type {string}
   * @memberof PayoutDetails
   */
  scheduled_date: string;
}
/**
 *
 * @export
 * @interface PayoutProcessorDetails
 */
export interface PayoutProcessorDetails {
  /**
   *
   * @type {string}
   * @memberof PayoutProcessorDetails
   */
  processor_id?: string;
  /**
   *
   * @type {string}
   * @memberof PayoutProcessorDetails
   */
  processor_reference?: string;
}
/**
 *
 * @export
 * @interface PayoutReferences
 */
export interface PayoutReferences {
  /**
   *
   * @type {string}
   * @memberof PayoutReferences
   */
  recipient_reference?: string;
}
/**
 *
 * @export
 * @interface PayoutSnapshotDetails
 */
export interface PayoutSnapshotDetails {
  /**
   *
   * @type {string}
   * @memberof PayoutSnapshotDetails
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof PayoutSnapshotDetails
   */
  transaction_reference_id?: string;
  /**
   *
   * @type {string}
   * @memberof PayoutSnapshotDetails
   */
  mandate_id?: string;
  /**
   *
   * @type {string}
   * @memberof PayoutSnapshotDetails
   */
  scheduled_date?: string | null;
  /**
   *
   * @type {string}
   * @memberof PayoutSnapshotDetails
   */
  estimated_arrival_time?: string | null;
  /**
   *
   * @type {PayoutProcessorDetails}
   * @memberof PayoutSnapshotDetails
   */
  processor_details?: PayoutProcessorDetails;
  /**
   *
   * @type {PayoutReferences}
   * @memberof PayoutSnapshotDetails
   */
  references?: PayoutReferences;
}
/**
 *
 * @export
 * @interface PayoutSnapshotResponse
 */
export interface PayoutSnapshotResponse {
  /**
   *
   * @type {string}
   * @memberof PayoutSnapshotResponse
   */
  payout_id?: string;
  /**
   *
   * @type {string}
   * @memberof PayoutSnapshotResponse
   */
  status?: PayoutSnapshotResponseStatusEnum;
  /**
   *
   * @type {string}
   * @memberof PayoutSnapshotResponse
   */
  type?: PayoutSnapshotResponseTypeEnum;
  /**
   *
   * @type {string}
   * @memberof PayoutSnapshotResponse
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof PayoutSnapshotResponse
   */
  updated_at?: string;
  /**
   *
   * @type {string}
   * @memberof PayoutSnapshotResponse
   */
  transaction_date?: string;
  /**
   *
   * @type {string}
   * @memberof PayoutSnapshotResponse
   */
  transaction_time?: string | null;
  /**
   *
   * @type {PayoutSnapshotDetails}
   * @memberof PayoutSnapshotResponse
   */
  payment_details?: PayoutSnapshotDetails;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof PayoutSnapshotResponse
   */
  metadata?: { [key: string]: string };
  /**
   *
   * @type {number}
   * @memberof PayoutSnapshotResponse
   */
  amount?: number;
  /**
   *
   * @type {string}
   * @memberof PayoutSnapshotResponse
   */
  currency?: string;
  /**
   *
   * @type {MandateRecipient}
   * @memberof PayoutSnapshotResponse
   */
  sender?: MandateRecipient;
  /**
   *
   * @type {MandateRecipientAccount}
   * @memberof PayoutSnapshotResponse
   */
  sender_account?: MandateRecipientAccount;
  /**
   *
   * @type {GetMandateSender}
   * @memberof PayoutSnapshotResponse
   */
  recipient?: GetMandateSender;
  /**
   *
   * @type {MandateSenderAccount}
   * @memberof PayoutSnapshotResponse
   */
  recipient_account?: MandateSenderAccount;
  /**
   *
   * @type {Array<Fee>}
   * @memberof PayoutSnapshotResponse
   */
  fees?: Array<Fee>;
  /**
   * Whether this payout is live or not
   * @type {boolean}
   * @memberof PayoutSnapshotResponse
   */
  live: boolean;
  /**
   *
   * @type {FvEmbeddedErrorModel}
   * @memberof PayoutSnapshotResponse
   */
  error?: FvEmbeddedErrorModel;
}

export const PayoutSnapshotResponseStatusEnum = {
  Executed: 'EXECUTED',
  Created: 'CREATED',
  Processing: 'PROCESSING',
  ProcessingFunds: 'PROCESSING_FUNDS',
  Cancelled: 'CANCELLED',
  Failed: 'FAILED',
  Funded: 'FUNDED',
  Submitted: 'SUBMITTED',
} as const;

export type PayoutSnapshotResponseStatusEnum =
  (typeof PayoutSnapshotResponseStatusEnum)[keyof typeof PayoutSnapshotResponseStatusEnum];
export const PayoutSnapshotResponseTypeEnum = {
  Manual: 'MANUAL',
  Scheduled: 'SCHEDULED',
  Settlement: 'SETTLEMENT',
} as const;

export type PayoutSnapshotResponseTypeEnum =
  (typeof PayoutSnapshotResponseTypeEnum)[keyof typeof PayoutSnapshotResponseTypeEnum];

/**
 *
 * @export
 * @interface Principal
 */
export interface Principal {
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  subject: string;
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  token?: string;
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  client_id: string;
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  customer_app_id: string;
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  login_identity_id: string;
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  customization_id?: string;
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  mandate_id?: string;
  /**
   *
   * @type {number}
   * @memberof Principal
   */
  expires_in?: number;
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  payment_attempt_id?: string;
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  payment_id?: string;
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  payment_account_id?: string;
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  product_flow?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Principal
   */
  scopes?: Array<string>;
  /**
   *
   * @type {LinkTokenRequest}
   * @memberof Principal
   */
  link_token_request?: LinkTokenRequest;
  /**
   *
   * @type {GetMandateAuthLinkRequest}
   * @memberof Principal
   */
  get_mandate_auth_link_request?: GetMandateAuthLinkRequest;
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  currency?: string;
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  redirect_uri?: string;
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  payment_link_id?: string;
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  unique_reference_id?: string;
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  payment_method_id?: string;
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  tpp_name?: string;
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  retry_url?: string;
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  onboarding_flow?: string;
  /**
   * The qrCode text to be used to generate the image
   * @type {string}
   * @memberof Principal
   */
  qr_code_text?: string;
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  manual_payment_provider?: string;
}
/**
 *
 * @export
 * @interface ProductStatus
 */
export interface ProductStatus {
  /**
   * The current health of this product
   * @type {string}
   * @memberof ProductStatus
   */
  status?: string;
  /**
   * The detailed event name
   * @type {string}
   * @memberof ProductStatus
   */
  status_details?: string;
  /**
   *
   * @type {string}
   * @memberof ProductStatus
   */
  last_update?: string | null;
  /**
   *
   * @type {string}
   * @memberof ProductStatus
   */
  last_successful_update?: string | null;
}
/**
 *
 * @export
 * @interface RapidstorMetadataRequest
 */
export interface RapidstorMetadataRequest {
  /**
   *
   * @type {string}
   * @memberof RapidstorMetadataRequest
   */
  corp_code: string;
  /**
   *
   * @type {string}
   * @memberof RapidstorMetadataRequest
   */
  s_location_code: string;
  /**
   *
   * @type {string}
   * @memberof RapidstorMetadataRequest
   */
  tenant_id: string;
  /**
   *
   * @type {number}
   * @memberof RapidstorMetadataRequest
   */
  i_anniv_days?: number;
  /**
   *
   * @type {string}
   * @memberof RapidstorMetadataRequest
   */
  account_token: string;
  /**
   *
   * @type {string}
   * @memberof RapidstorMetadataRequest
   */
  unit_type_id?: string;
}
/**
 *
 * @export
 * @interface RapidstorMetadataResponse
 */
export interface RapidstorMetadataResponse {
  /**
   *
   * @type {string}
   * @memberof RapidstorMetadataResponse
   */
  corp_code?: string;
  /**
   *
   * @type {string}
   * @memberof RapidstorMetadataResponse
   */
  s_location_code?: string;
  /**
   *
   * @type {string}
   * @memberof RapidstorMetadataResponse
   */
  tenant_id?: string;
  /**
   *
   * @type {number}
   * @memberof RapidstorMetadataResponse
   */
  i_anniv_days?: number;
  /**
   *
   * @type {string}
   * @memberof RapidstorMetadataResponse
   */
  tenant_default_currency?: string;
  /**
   *
   * @type {string}
   * @memberof RapidstorMetadataResponse
   */
  account_token?: string;
  /**
   *
   * @type {string}
   * @memberof RapidstorMetadataResponse
   */
  unit_type_id?: string;
}
/**
 *
 * @export
 * @interface RecipientAccountFilters
 */
export interface RecipientAccountFilters {
  /**
   *
   * @type {string}
   * @memberof RecipientAccountFilters
   */
  business_unit: string;
}
/**
 *
 * @export
 * @interface RecipientAccountNumber
 */
export interface RecipientAccountNumber {
  /**
   * Type of account number. Possible values: LOCAL, IBAN
   * @type {string}
   * @memberof RecipientAccountNumber
   */
  type: RecipientAccountNumberTypeEnum;
  /**
   * Account number value
   * @type {string}
   * @memberof RecipientAccountNumber
   */
  number: string;
  /**
   * Account number value
   * @type {string}
   * @memberof RecipientAccountNumber
   */
  number_plaintext?: string | null;
}

export const RecipientAccountNumberTypeEnum = {
  Local: 'LOCAL',
  Iban: 'IBAN',
} as const;

export type RecipientAccountNumberTypeEnum =
  (typeof RecipientAccountNumberTypeEnum)[keyof typeof RecipientAccountNumberTypeEnum];

/**
 *
 * @export
 * @interface RecipientAccountResponse
 */
export interface RecipientAccountResponse {
  /**
   * A unique identifier generated after creating recipient
   * @type {string}
   * @memberof RecipientAccountResponse
   */
  recipient_account_id?: string;
  /**
   * Accountholder name of the recipient\'s account
   * @type {string}
   * @memberof RecipientAccountResponse
   */
  accountholder_name?: string;
  /**
   *
   * @type {RecipientAccountNumber}
   * @memberof RecipientAccountResponse
   */
  account_number?: RecipientAccountNumber;
  /**
   * Type of recipient account.
   * @type {string}
   * @memberof RecipientAccountResponse
   */
  account_type?: RecipientAccountResponseAccountTypeEnum;
  /**
   * List of currencies supported by the recipient account
   * @type {Array<string>}
   * @memberof RecipientAccountResponse
   */
  currencies?: Array<string>;
  /**
   * Finverse Institution ID for the recipient’s institution.
   * @type {string}
   * @memberof RecipientAccountResponse
   */
  institution_id?: string;
  /**
   * Institution Name for the sender’s institution.
   * @type {string}
   * @memberof RecipientAccountResponse
   */
  institution_name?: string;
  /**
   * 3-digit code associated with bank
   * @type {string}
   * @memberof RecipientAccountResponse
   */
  bank_code?: string;
  /**
   * 3-digit code used to identify specific bank branch
   * @type {string}
   * @memberof RecipientAccountResponse
   */
  branch_code?: string;
}

export const RecipientAccountResponseAccountTypeEnum = {
  ExternalAccount: 'EXTERNAL_ACCOUNT',
  SettlementAccount: 'SETTLEMENT_ACCOUNT',
} as const;

export type RecipientAccountResponseAccountTypeEnum =
  (typeof RecipientAccountResponseAccountTypeEnum)[keyof typeof RecipientAccountResponseAccountTypeEnum];

/**
 *
 * @export
 * @interface RedirectUriResponse
 */
export interface RedirectUriResponse {
  /**
   *
   * @type {string}
   * @memberof RedirectUriResponse
   */
  redirect_uri?: string;
}
/**
 *
 * @export
 * @interface RefreshData
 */
export interface RefreshData {
  /**
   *
   * @type {boolean}
   * @memberof RefreshData
   */
  credentials_stored: boolean;
  /**
   *
   * @type {boolean}
   * @memberof RefreshData
   */
  refresh_allowed: boolean;
}
/**
 *
 * @export
 * @interface RefreshLoginIdentityLinkCustomizations
 */
export interface RefreshLoginIdentityLinkCustomizations {
  /**
   * ISO639-1 language code. Language to display when user open the link, default to English (en) if not specified
   * @type {string}
   * @memberof RefreshLoginIdentityLinkCustomizations
   */
  language?: RefreshLoginIdentityLinkCustomizationsLanguageEnum;
  /**
   *
   * @type {string}
   * @memberof RefreshLoginIdentityLinkCustomizations
   */
  ui_mode?: RefreshLoginIdentityLinkCustomizationsUiModeEnum;
  /**
   * Required if ui_mode is redirect or auto_redirect
   * @type {string}
   * @memberof RefreshLoginIdentityLinkCustomizations
   */
  redirect_uri?: string;
  /**
   *
   * @type {string}
   * @memberof RefreshLoginIdentityLinkCustomizations
   */
  state?: string;
}

export const RefreshLoginIdentityLinkCustomizationsLanguageEnum = {
  En: 'en',
  Vi: 'vi',
  Zh: 'zh',
  Ko: 'ko',
} as const;

export type RefreshLoginIdentityLinkCustomizationsLanguageEnum =
  (typeof RefreshLoginIdentityLinkCustomizationsLanguageEnum)[keyof typeof RefreshLoginIdentityLinkCustomizationsLanguageEnum];
export const RefreshLoginIdentityLinkCustomizationsUiModeEnum = {
  Iframe: 'iframe',
  Redirect: 'redirect',
  AutoRedirect: 'auto_redirect',
  Standalone: 'standalone',
} as const;

export type RefreshLoginIdentityLinkCustomizationsUiModeEnum =
  (typeof RefreshLoginIdentityLinkCustomizationsUiModeEnum)[keyof typeof RefreshLoginIdentityLinkCustomizationsUiModeEnum];

/**
 *
 * @export
 * @interface RefreshLoginIdentityRequest
 */
export interface RefreshLoginIdentityRequest {
  /**
   * Indicate whether the user is present in this flow. If the user is not present, only institutions that do not require 2fa can be refreshed
   * @type {boolean}
   * @memberof RefreshLoginIdentityRequest
   */
  user_present?: boolean;
  /**
   *
   * @type {RefreshLoginIdentityLinkCustomizations}
   * @memberof RefreshLoginIdentityRequest
   */
  link_customizations?: RefreshLoginIdentityLinkCustomizations;
}
/**
 *
 * @export
 * @interface RefreshPaymentAttemptResponse
 */
export interface RefreshPaymentAttemptResponse {
  /**
   *
   * @type {string}
   * @memberof RefreshPaymentAttemptResponse
   */
  redirect_url?: string;
}
/**
 *
 * @export
 * @interface RefreshRequest
 */
export interface RefreshRequest {
  /**
   *
   * @type {string}
   * @memberof RefreshRequest
   */
  refresh_token: string;
}
/**
 *
 * @export
 * @interface RefreshTokenResponse
 */
export interface RefreshTokenResponse {
  /**
   *
   * @type {string}
   * @memberof RefreshTokenResponse
   */
  access_token: string;
  /**
   *
   * @type {string}
   * @memberof RefreshTokenResponse
   */
  token_type: string;
  /**
   * seconds
   * @type {number}
   * @memberof RefreshTokenResponse
   */
  expires_in: number;
  /**
   *
   * @type {string}
   * @memberof RefreshTokenResponse
   */
  issued_at: string;
  /**
   *
   * @type {string}
   * @memberof RefreshTokenResponse
   */
  link_url: string;
  /**
   *
   * @type {string}
   * @memberof RefreshTokenResponse
   */
  login_identity_id: string;
}
/**
 *
 * @export
 * @interface RelinkRequest
 */
export interface RelinkRequest {
  /**
   *
   * @type {boolean}
   * @memberof RelinkRequest
   */
  store_credential: boolean;
  /**
   * this is a mandatory field
   * @type {boolean}
   * @memberof RelinkRequest
   */
  consent?: boolean | null;
}
/**
 *
 * @export
 * @interface SelectPaymentMethodRequest
 */
export interface SelectPaymentMethodRequest {
  /**
   * The payment account ID of the selected payment method
   * @type {string}
   * @memberof SelectPaymentMethodRequest
   */
  payment_account_id: string;
  /**
   * The type of payment method to select
   * @type {string}
   * @memberof SelectPaymentMethodRequest
   */
  payment_method_type: SelectPaymentMethodRequestPaymentMethodTypeEnum;
  /**
   *
   * @type {string}
   * @memberof SelectPaymentMethodRequest
   */
  sender_type?: SelectPaymentMethodRequestSenderTypeEnum;
  /**
   * Whether the user is on mobile device (only makes a difference if payment_method_provider is KCP)
   * @type {boolean}
   * @memberof SelectPaymentMethodRequest
   */
  is_mobile?: boolean;
}

export const SelectPaymentMethodRequestPaymentMethodTypeEnum = {
  Mandate: 'MANDATE',
  Single: 'SINGLE',
  Card: 'CARD',
  Manual: 'MANUAL',
} as const;

export type SelectPaymentMethodRequestPaymentMethodTypeEnum =
  (typeof SelectPaymentMethodRequestPaymentMethodTypeEnum)[keyof typeof SelectPaymentMethodRequestPaymentMethodTypeEnum];
export const SelectPaymentMethodRequestSenderTypeEnum = {
  Individual: 'INDIVIDUAL',
  Business: 'BUSINESS',
} as const;

export type SelectPaymentMethodRequestSenderTypeEnum =
  (typeof SelectPaymentMethodRequestSenderTypeEnum)[keyof typeof SelectPaymentMethodRequestSenderTypeEnum];

/**
 *
 * @export
 * @interface SelectPaymentMethodResponse
 */
export interface SelectPaymentMethodResponse {
  /**
   *
   * @type {PaymentLinkTokenResponse}
   * @memberof SelectPaymentMethodResponse
   */
  token?: PaymentLinkTokenResponse;
  /**
   * URL to redirect to for making the card payment
   * @type {string}
   * @memberof SelectPaymentMethodResponse
   */
  card_processor_redirect_uri?: string;
}
/**
 *
 * @export
 * @interface SenderAccountFvLinkResponse
 */
export interface SenderAccountFvLinkResponse {
  /**
   *
   * @type {string}
   * @memberof SenderAccountFvLinkResponse
   */
  account_number_masked?: string;
  /**
   *
   * @type {string}
   * @memberof SenderAccountFvLinkResponse
   */
  institution_id?: string;
  /**
   *
   * @type {string}
   * @memberof SenderAccountFvLinkResponse
   */
  institution_name?: string;
}
/**
 *
 * @export
 * @interface SenderDetail
 */
export interface SenderDetail {
  /**
   * The type of the details. For e.g. HK_ID, PASSPORT etc
   * @type {string}
   * @memberof SenderDetail
   */
  details_type?: SenderDetailDetailsTypeEnum;
  /**
   * The possible values of the detail. For e.g. A123456 for HK_ID
   * @type {Array<string>}
   * @memberof SenderDetail
   */
  values?: Array<string>;
}

export const SenderDetailDetailsTypeEnum = {
  HkId: 'HK_ID',
  Passport: 'PASSPORT',
  HkBusinessRegistration: 'HK_BUSINESS_REGISTRATION',
  HkCertificateOfIncorporation: 'HK_CERTIFICATE_OF_INCORPORATION',
} as const;

export type SenderDetailDetailsTypeEnum =
  (typeof SenderDetailDetailsTypeEnum)[keyof typeof SenderDetailDetailsTypeEnum];

/**
 *
 * @export
 * @interface SetAutopayConsentRequest
 */
export interface SetAutopayConsentRequest {
  /**
   *
   * @type {boolean}
   * @memberof SetAutopayConsentRequest
   */
  autopay_consent: boolean;
}
/**
 *
 * @export
 * @interface SetMandateInstitutionRequest
 */
export interface SetMandateInstitutionRequest {
  /**
   * Finverse Institution ID
   * @type {string}
   * @memberof SetMandateInstitutionRequest
   */
  institution_id: string;
}
/**
 *
 * @export
 * @interface SetMandateInstitutionResponse
 */
export interface SetMandateInstitutionResponse {
  /**
   * Finverse Mandate ID
   * @type {string}
   * @memberof SetMandateInstitutionResponse
   */
  mandate_id: string;
}
/**
 *
 * @export
 * @interface SingleSourceIncome
 */
export interface SingleSourceIncome {
  /**
   *
   * @type {Array<IncomeStream>}
   * @memberof SingleSourceIncome
   */
  income_streams: Array<IncomeStream>;
  /**
   *
   * @type {IncomeTotal}
   * @memberof SingleSourceIncome
   */
  income_total: IncomeTotal;
  /**
   * Where the income estimate was sourced from
   * @type {string}
   * @memberof SingleSourceIncome
   */
  source: string;
  /**
   * Unknown
   * @type {string}
   * @memberof SingleSourceIncome
   */
  source_id: string;
}
/**
 *
 * @export
 * @interface Statement
 */
export interface Statement {
  /**
   *
   * @type {string}
   * @memberof Statement
   */
  id?: string;
  /**
   * YYYY-MM-DD
   * @type {string}
   * @memberof Statement
   */
  date?: string;
  /**
   *
   * @type {string}
   * @memberof Statement
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof Statement
   */
  created_at?: string;
}
/**
 *
 * @export
 * @interface StatementLink
 */
export interface StatementLink {
  /**
   * signedURL to download statement
   * @type {string}
   * @memberof StatementLink
   */
  url?: string;
  /**
   * expiry of the signedURL
   * @type {string}
   * @memberof StatementLink
   */
  expiry?: string;
  /**
   *
   * @type {string}
   * @memberof StatementLink
   */
  statement_id?: string;
}
/**
 *
 * @export
 * @interface SubmitAuthChecklistRequest
 */
export interface SubmitAuthChecklistRequest {
  /**
   * The key_id that was used to encrypt the envelope key
   * @type {string}
   * @memberof SubmitAuthChecklistRequest
   */
  key_id: string;
  /**
   * The encrypted envelope key
   * @type {string}
   * @memberof SubmitAuthChecklistRequest
   */
  envelope_encryption_key: string;
  /**
   * The initialization vector used for enncrypting the payload
   * @type {string}
   * @memberof SubmitAuthChecklistRequest
   */
  initialization_vector: string;
  /**
   * The authentication code is used to authenticate the origin of the message
   * @type {string}
   * @memberof SubmitAuthChecklistRequest
   */
  message_authentication_code: string;
  /**
   * The encrypted payload that contains auth checklist items
   * @type {string}
   * @memberof SubmitAuthChecklistRequest
   */
  ciphertext: string;
}
/**
 *
 * @export
 * @interface SubmitAuthChecklistResponse
 */
export interface SubmitAuthChecklistResponse {
  /**
   * Finverse Mandate ID
   * @type {string}
   * @memberof SubmitAuthChecklistResponse
   */
  mandate_id: string;
  /**
   * Checklist of the authorization factors needed to complete Mandate authorization
   * @type {Array<AuthChecklistFactor>}
   * @memberof SubmitAuthChecklistResponse
   */
  auth_checklist: Array<AuthChecklistFactor>;
  /**
   * Mandate status
   * @type {string}
   * @memberof SubmitAuthChecklistResponse
   */
  mandate_status: SubmitAuthChecklistResponseMandateStatusEnum;
  /**
   * Timestamp in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
   * @type {string}
   * @memberof SubmitAuthChecklistResponse
   */
  last_update: string;
}

export const SubmitAuthChecklistResponseMandateStatusEnum = {
  Created: 'CREATED',
  Processing: 'PROCESSING',
  Submitted: 'SUBMITTED',
  Error: 'ERROR',
} as const;

export type SubmitAuthChecklistResponseMandateStatusEnum =
  (typeof SubmitAuthChecklistResponseMandateStatusEnum)[keyof typeof SubmitAuthChecklistResponseMandateStatusEnum];

/**
 *
 * @export
 * @interface SwaggerErrBodyModel
 */
export interface SwaggerErrBodyModel {
  /**
   *
   * @type {number}
   * @memberof SwaggerErrBodyModel
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof SwaggerErrBodyModel
   */
  message?: string;
  /**
   *
   * @type {FvErrorModel}
   * @memberof SwaggerErrBodyModel
   */
  error?: FvErrorModel;
}
/**
 *
 * @export
 * @interface TokenRequest
 */
export interface TokenRequest {
  /**
   *
   * @type {string}
   * @memberof TokenRequest
   */
  client_id: string;
  /**
   *
   * @type {string}
   * @memberof TokenRequest
   */
  client_secret: string;
  /**
   * support only client_credentials
   * @type {string}
   * @memberof TokenRequest
   */
  grant_type: string;
}
/**
 *
 * @export
 * @interface TokenResponse
 */
export interface TokenResponse {
  /**
   *
   * @type {string}
   * @memberof TokenResponse
   */
  access_token: string;
  /**
   *
   * @type {string}
   * @memberof TokenResponse
   */
  token_type: string;
  /**
   * seconds
   * @type {number}
   * @memberof TokenResponse
   */
  expires_in: number;
  /**
   *
   * @type {string}
   * @memberof TokenResponse
   */
  issued_at: string;
}
/**
 *
 * @export
 * @interface Transaction
 */
export interface Transaction {
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  transaction_id?: string;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  account_id?: string;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  transaction_state?: string;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  transaction_type?: string;
  /**
   * (Deprecated)
   * @type {string}
   * @memberof Transaction
   */
  category?: string;
  /**
   * (Deprecated)
   * @type {string}
   * @memberof Transaction
   */
  category_id?: string;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  merchant_name?: string;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  location?: string;
  /**
   *
   * @type {boolean}
   * @memberof Transaction
   */
  is_pending: boolean;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  status?: string;
  /**
   * YYYY-MM-DD
   * @type {string}
   * @memberof Transaction
   */
  posted_date?: string;
  /**
   *
   * @type {CurrencyAmount}
   * @memberof Transaction
   */
  amount?: CurrencyAmount;
  /**
   *
   * @type {CurrencyAmount}
   * @memberof Transaction
   */
  running_balance?: CurrencyAmount;
  /**
   * Transaction Details
   * @type {object}
   * @memberof Transaction
   */
  transaction_details?: object;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  updated_at?: string;
  /**
   * Array of category labels
   * @type {Array<string>}
   * @memberof Transaction
   */
  categories?: Array<string>;
  /**
   * Optional field indicating when the transaction happened
   * @type {string}
   * @memberof Transaction
   */
  transaction_time?: string | null;
  /**
   * Transaction reference provided by the bank
   * @type {string}
   * @memberof Transaction
   */
  transaction_reference?: string;
  /**
   *
   * @type {Array<CategoryPredictions>}
   * @memberof Transaction
   */
  category_predictions?: Array<CategoryPredictions>;
}
/**
 *
 * @export
 * @interface TransactionLimitsRequest
 */
export interface TransactionLimitsRequest {
  /**
   * Maximum amount of money that can be paid during the reference period (across any number of transactions). Expressed in currency\'s smallest unit or “minor unit”, as defined in ISO 4217.
   * @type {number}
   * @memberof TransactionLimitsRequest
   */
  max_period_amount?: number;
  /**
   * Maximum number of transactions (of any amount) that can be executed during the reference period.
   * @type {number}
   * @memberof TransactionLimitsRequest
   */
  max_period_count?: number;
  /**
   * The maximum amount of money that can be transferred in a single transaction under this mandate. Expressed in currency\'s smallest unit or “minor unit”, as defined in ISO 4217.
   * @type {number}
   * @memberof TransactionLimitsRequest
   */
  max_transaction_amount: number;
  /**
   * Reference calendar periods for the payment limits. Possible values (DAILY, WEEKLY, MONTHLY, QUARTERLY, YEARLY)
   * @type {string}
   * @memberof TransactionLimitsRequest
   */
  period?: TransactionLimitsRequestPeriodEnum | null;
}

export const TransactionLimitsRequestPeriodEnum = {
  Daily: 'DAILY',
  Weekly: 'WEEKLY',
  Monthly: 'MONTHLY',
  Quarterly: 'QUARTERLY',
  Yearly: 'YEARLY',
} as const;

export type TransactionLimitsRequestPeriodEnum =
  (typeof TransactionLimitsRequestPeriodEnum)[keyof typeof TransactionLimitsRequestPeriodEnum];

/**
 *
 * @export
 * @interface TransactionLimitsResponse
 */
export interface TransactionLimitsResponse {
  /**
   * Maximum amount of money that can be paid during the reference period (across any number of transactions). Expressed in currency\'s smallest unit or “minor unit”, as defined in ISO 4217.
   * @type {number}
   * @memberof TransactionLimitsResponse
   */
  max_period_amount?: number;
  /**
   * Maximum number of transactions (of any amount) that can be executed during the reference period.
   * @type {number}
   * @memberof TransactionLimitsResponse
   */
  max_period_count?: number;
  /**
   * The maximum amount of money that can be transferred in a single transaction under this mandate. Expressed in currency\'s smallest unit or “minor unit”, as defined in ISO 4217.
   * @type {number}
   * @memberof TransactionLimitsResponse
   */
  max_transaction_amount?: number;
  /**
   * The maximum amount of money that can be transferred in a single transaction under this mandate set by the payer. Expressed in currency\'s smallest unit or “minor unit”, as defined in ISO 4217.
   * @type {number}
   * @memberof TransactionLimitsResponse
   */
  max_transaction_amount_set_by_payer_initial?: number | null;
  /**
   * Reference calendar periods for the payment limits. Possible values (DAILY, WEEKLY, MONTHLY, QUARTERLY, YEARLY)
   * @type {string}
   * @memberof TransactionLimitsResponse
   */
  period?: TransactionLimitsResponsePeriodEnum | null;
}

export const TransactionLimitsResponsePeriodEnum = {
  Daily: 'DAILY',
  Weekly: 'WEEKLY',
  Monthly: 'MONTHLY',
  Quarterly: 'QUARTERLY',
  Yearly: 'YEARLY',
} as const;

export type TransactionLimitsResponsePeriodEnum =
  (typeof TransactionLimitsResponsePeriodEnum)[keyof typeof TransactionLimitsResponsePeriodEnum];

/**
 *
 * @export
 * @interface UpdatePaymentRequest
 */
export interface UpdatePaymentRequest {
  [key: string]: any;

  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof UpdatePaymentRequest
   */
  metadata?: { [key: string]: string };
}
/**
 *
 * @export
 * @interface UpdatePaymentUserRequest
 */
export interface UpdatePaymentUserRequest {
  [key: string]: any;

  /**
   *
   * @type {boolean}
   * @memberof UpdatePaymentUserRequest
   */
  autopay_consent?: boolean | null;
  /**
   *
   * @type {string}
   * @memberof UpdatePaymentUserRequest
   */
  email?: string | null;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof UpdatePaymentUserRequest
   */
  metadata?: { [key: string]: string } | null;
  /**
   *
   * @type {string}
   * @memberof UpdatePaymentUserRequest
   */
  name?: string | null;
  /**
   *
   * @type {string}
   * @memberof UpdatePaymentUserRequest
   */
  next_bill_update?: string | null;
  /**
   *
   * @type {string}
   * @memberof UpdatePaymentUserRequest
   */
  user_type?: UpdatePaymentUserRequestUserTypeEnum | null;
}

export const UpdatePaymentUserRequestUserTypeEnum = {
  Individual: 'INDIVIDUAL',
  Business: 'BUSINESS',
} as const;

export type UpdatePaymentUserRequestUserTypeEnum =
  (typeof UpdatePaymentUserRequestUserTypeEnum)[keyof typeof UpdatePaymentUserRequestUserTypeEnum];

/**
 *
 * @export
 * @interface UpdateTestPaymentStatusRequest
 */
export interface UpdateTestPaymentStatusRequest {
  /**
   * The payment status
   * @type {string}
   * @memberof UpdateTestPaymentStatusRequest
   */
  status?: UpdateTestPaymentStatusRequestStatusEnum;
}

export const UpdateTestPaymentStatusRequestStatusEnum = {
  Executed: 'EXECUTED',
} as const;

export type UpdateTestPaymentStatusRequestStatusEnum =
  (typeof UpdateTestPaymentStatusRequestStatusEnum)[keyof typeof UpdateTestPaymentStatusRequestStatusEnum];

/**
 *
 * @export
 * @interface UserButton
 */
export interface UserButton {
  /**
   * The name of the button.
   * @type {string}
   * @memberof UserButton
   */
  name: string;
  /**
   * The text that will be displayed for this button
   * @type {string}
   * @memberof UserButton
   */
  value: string;
  /**
   * The type of button. Currently it can only be SUBMIT
   * @type {string}
   * @memberof UserButton
   */
  type: string;
}
/**
 *
 * @export
 * @interface UserField
 */
export interface UserField {
  /**
   * The name of the field. This will be used as the key when submitting response.
   * @type {string}
   * @memberof UserField
   */
  name: string;
  /**
   * The label for this field.
   * @type {string}
   * @memberof UserField
   */
  label?: string;
  /**
   * The placeholder for this field.
   * @type {string}
   * @memberof UserField
   */
  placeholder?: string;
  /**
   * The type of field. Currently it can only be SELECT, INPUT or PASSWORD
   * @type {string}
   * @memberof UserField
   */
  type: string;
  /**
   * This is only applicable when the field type is SELECT
   * @type {Array<UserFieldOption>}
   * @memberof UserField
   */
  options?: Array<UserFieldOption>;
}
/**
 *
 * @export
 * @interface UserFieldOption
 */
export interface UserFieldOption {
  /**
   * The value displayed in the select element.
   * @type {string}
   * @memberof UserFieldOption
   */
  label: string;
  /**
   * The value that will be submitted if this option was selected.
   * @type {string}
   * @memberof UserFieldOption
   */
  value: string;
}
/**
 *
 * @export
 * @interface UserMessage
 */
export interface UserMessage {
  /**
   * The name of the message
   * @type {string}
   * @memberof UserMessage
   */
  name: string;
  /**
   * The type of the message. This will help how the UI renders this text.
   * @type {string}
   * @memberof UserMessage
   */
  type: string;
  /**
   * The actual text value.
   * @type {string}
   * @memberof UserMessage
   */
  value: string;
}

/**
 * CustomerApi - axios parameter creator
 * @export
 */
export const CustomerApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Allows a customer to authorize a specific mandate
     * @param {string} mandateId The mandate_id that is being authorized
     * @param {AuthorizeMandateRequest} authorizeMandateRequest request body for authorizing a mandate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authorizeMandate: async (
      mandateId: string,
      authorizeMandateRequest: AuthorizeMandateRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'mandateId' is not null or undefined
      assertParamExists('authorizeMandate', 'mandateId', mandateId);
      // verify required parameter 'authorizeMandateRequest' is not null or undefined
      assertParamExists('authorizeMandate', 'authorizeMandateRequest', authorizeMandateRequest);
      const localVarPath = `/mandates/{mandateId}/authorize`.replace(
        `{${'mandateId'}}`,
        encodeURIComponent(String(mandateId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        authorizeMandateRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * CREATE Mandate
     * @param {CreateMandateRequest} createMandateRequest request body for creating mandate
     * @param {string} [idempotencyKey] A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMandate: async (
      createMandateRequest: CreateMandateRequest,
      idempotencyKey?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createMandateRequest' is not null or undefined
      assertParamExists('createMandate', 'createMandateRequest', createMandateRequest);
      const localVarPath = `/mandates`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      if (idempotencyKey != null) {
        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(createMandateRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create new Payment
     * @param {CreatePaymentRequest} createPaymentRequest request body for creating payment
     * @param {string} [idempotencyKey] A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPayment: async (
      createPaymentRequest: CreatePaymentRequest,
      idempotencyKey?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createPaymentRequest' is not null or undefined
      assertParamExists('createPayment', 'createPaymentRequest', createPaymentRequest);
      const localVarPath = `/payments`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      if (idempotencyKey != null) {
        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(createPaymentRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * create payment account
     * @param {CreatePaymentAccountRequest} createPaymentAccountRequest request body for creating payment account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentAccount: async (
      createPaymentAccountRequest: CreatePaymentAccountRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createPaymentAccountRequest' is not null or undefined
      assertParamExists('createPaymentAccount', 'createPaymentAccountRequest', createPaymentAccountRequest);
      const localVarPath = `/payment_accounts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createPaymentAccountRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a new payment instruction to be used when linking to perform new payment
     * @param {CustomerPaymentInstruction} paymentInstruction Request body for starting a new Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentInstruction: async (
      paymentInstruction: CustomerPaymentInstruction,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'paymentInstruction' is not null or undefined
      assertParamExists('createPaymentInstruction', 'paymentInstruction', paymentInstruction);
      const localVarPath = `/payments/instruction`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(paymentInstruction, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a payment user
     * @param {CreatePaymentUserRequest} createPaymentUserRequest request body for creating payment user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentUser: async (
      createPaymentUserRequest: CreatePaymentUserRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createPaymentUserRequest' is not null or undefined
      assertParamExists('createPaymentUser', 'createPaymentUserRequest', createPaymentUserRequest);
      const localVarPath = `/payment_users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createPaymentUserRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * delete payment account
     * @param {string} paymentAccountId The payment account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePaymentAccount: async (
      paymentAccountId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'paymentAccountId' is not null or undefined
      assertParamExists('deletePaymentAccount', 'paymentAccountId', paymentAccountId);
      const localVarPath = `/payment_accounts/{paymentAccountId}`.replace(
        `{${'paymentAccountId'}}`,
        encodeURIComponent(String(paymentAccountId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * generate a link token that can be used to create link
     * @param {LinkTokenRequest} linkTokenRequest token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateLinkToken: async (
      linkTokenRequest: LinkTokenRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'linkTokenRequest' is not null or undefined
      assertParamExists('generateLinkToken', 'linkTokenRequest', linkTokenRequest);
      const localVarPath = `/link/token`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(linkTokenRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a specific institution by institutionId
     * @param {string} institutionId The institution id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInstitution: async (institutionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'institutionId' is not null or undefined
      assertParamExists('getInstitution', 'institutionId', institutionId);
      const localVarPath = `/institutions/{institutionId}`.replace(
        `{${'institutionId'}}`,
        encodeURIComponent(String(institutionId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', ['institution'], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get line items for display
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLineItemsForDisplayV2: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/calculate/line_items_v2`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a specific loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoginIdentityById: async (
      loginIdentityId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'loginIdentityId' is not null or undefined
      assertParamExists('getLoginIdentityById', 'loginIdentityId', loginIdentityId);
      const localVarPath = `/login_identity/{loginIdentityId}`.replace(
        `{${'loginIdentityId'}}`,
        encodeURIComponent(String(loginIdentityId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a history of events for a specific loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoginIdentityHistory: async (
      loginIdentityId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'loginIdentityId' is not null or undefined
      assertParamExists('getLoginIdentityHistory', 'loginIdentityId', loginIdentityId);
      const localVarPath = `/login_identity/{loginIdentityId}/history`.replace(
        `{${'loginIdentityId'}}`,
        encodeURIComponent(String(loginIdentityId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get Mandate details by mandate_id
     * @param {string} mandateId mandate id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMandate: async (mandateId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'mandateId' is not null or undefined
      assertParamExists('getMandate', 'mandateId', mandateId);
      const localVarPath = `/mandates/{mandateId}`.replace(`{${'mandateId'}}`, encodeURIComponent(String(mandateId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get Mandate Authorization by mandate id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMandateAuth: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/mandates/auth`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get link to launch FV Link UI in mandate authorization mode
     * @param {GetMandateAuthLinkRequest} getMandateAuthLinkRequest request body for mandate authorization link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMandateAuthLink: async (
      getMandateAuthLinkRequest: GetMandateAuthLinkRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getMandateAuthLinkRequest' is not null or undefined
      assertParamExists('getMandateAuthLink', 'getMandateAuthLinkRequest', getMandateAuthLinkRequest);
      const localVarPath = `/mandates/link`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getMandateAuthLinkRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get Payment details by payment_id
     * @param {string} paymentId payment id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPayment: async (paymentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'paymentId' is not null or undefined
      assertParamExists('getPayment', 'paymentId', paymentId);
      const localVarPath = `/payments/{paymentId}`.replace(`{${'paymentId'}}`, encodeURIComponent(String(paymentId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get payment instructions by payment_instruction_id
     * @param {string} paymentInstructionId The id of a payment instruction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentInstruction: async (
      paymentInstructionId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'paymentInstructionId' is not null or undefined
      assertParamExists('getPaymentInstruction', 'paymentInstructionId', paymentInstructionId);
      const localVarPath = `/payments/instruction/{paymentInstructionId}`.replace(
        `{${'paymentInstructionId'}}`,
        encodeURIComponent(String(paymentInstructionId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a payment user
     * @param {string} paymentUserId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentUser: async (paymentUserId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'paymentUserId' is not null or undefined
      assertParamExists('getPaymentUser', 'paymentUserId', paymentUserId);
      const localVarPath = `/payment_users/{paymentUserId}`.replace(
        `{${'paymentUserId'}}`,
        encodeURIComponent(String(paymentUserId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of institutions
     * @param {string} [country] (Deprecated) The country the institution belongs to
     * @param {Array<string>} [countries] The countries the institution belongs to
     * @param {string} [productsSupported] The products that this institution supports
     * @param {ListInstitutionsInstitutionTypeEnum} [institutionType] The type of institution
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listInstitutions: async (
      country?: string,
      countries?: Array<string>,
      productsSupported?: string,
      institutionType?: ListInstitutionsInstitutionTypeEnum,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/institutions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', ['institution'], configuration);

      if (country !== undefined) {
        localVarQueryParameter['country'] = country;
      }

      if (countries) {
        localVarQueryParameter['countries'] = countries.join(COLLECTION_FORMATS.csv);
      }

      if (productsSupported !== undefined) {
        localVarQueryParameter['products_supported'] = productsSupported;
      }

      if (institutionType !== undefined) {
        localVarQueryParameter['institution_type'] = institutionType;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get payment account by user id
     * @param {string} paymentUserId The payment user id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPaymentAccounts: async (paymentUserId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'paymentUserId' is not null or undefined
      assertParamExists('listPaymentAccounts', 'paymentUserId', paymentUserId);
      const localVarPath = `/payment_users/{paymentUserId}/payment_accounts`.replace(
        `{${'paymentUserId'}}`,
        encodeURIComponent(String(paymentUserId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get payment account for customer app
     * @param {ListPaymentAccountsWithEnrichedDataAccountTypeEnum} [accountType] The account_type to filter for
     * @param {Array<string>} [currencies] The currencies to filter for
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPaymentAccountsWithEnrichedData: async (
      accountType?: ListPaymentAccountsWithEnrichedDataAccountTypeEnum,
      currencies?: Array<string>,
      offset?: number,
      limit?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/payment_accounts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      if (accountType !== undefined) {
        localVarQueryParameter['account_type'] = accountType;
      }

      if (currencies) {
        localVarQueryParameter['currencies'] = currencies.join(COLLECTION_FORMATS.csv);
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Refresh an access token
     * @param {RefreshRequest} refreshRequest The refresh token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshToken: async (refreshRequest: RefreshRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'refreshRequest' is not null or undefined
      assertParamExists('refreshToken', 'refreshRequest', refreshRequest);
      const localVarPath = `/auth/token/refresh`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(refreshRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update InstitutionID and SenderType for Mandate
     * @param {SetMandateInstitutionRequest} updateRequest request body for updating mandate institutionId and senderType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setMandateInstitution: async (
      updateRequest: SetMandateInstitutionRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'updateRequest' is not null or undefined
      assertParamExists('setMandateInstitution', 'updateRequest', updateRequest);
      const localVarPath = `/mandates/institution_selection`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(updateRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Submit authorization checklist items
     * @param {SubmitAuthChecklistRequest} submitAuthChecklistRequest request body for submitting auth checklist
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitAuthChecklist: async (
      submitAuthChecklistRequest: SubmitAuthChecklistRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'submitAuthChecklistRequest' is not null or undefined
      assertParamExists('submitAuthChecklist', 'submitAuthChecklistRequest', submitAuthChecklistRequest);
      const localVarPath = `/mandates/auth`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        submitAuthChecklistRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update payment
     * @param {string} paymentId payment id
     * @param {UpdatePaymentRequest} updatePaymentRequest request body for updating payment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePayment: async (
      paymentId: string,
      updatePaymentRequest: UpdatePaymentRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'paymentId' is not null or undefined
      assertParamExists('updatePayment', 'paymentId', paymentId);
      // verify required parameter 'updatePaymentRequest' is not null or undefined
      assertParamExists('updatePayment', 'updatePaymentRequest', updatePaymentRequest);
      const localVarPath = `/payments/{paymentId}`.replace(`{${'paymentId'}}`, encodeURIComponent(String(paymentId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(updatePaymentRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update the status of a test manual payment
     * @param {string} paymentId The test payment ID
     * @param {UpdateTestPaymentStatusRequest} paymentStatus Request body for updating the test manual payment status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTestPaymentStatus: async (
      paymentId: string,
      paymentStatus: UpdateTestPaymentStatusRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'paymentId' is not null or undefined
      assertParamExists('updateTestPaymentStatus', 'paymentId', paymentId);
      // verify required parameter 'paymentStatus' is not null or undefined
      assertParamExists('updateTestPaymentStatus', 'paymentStatus', paymentStatus);
      const localVarPath = `/testing/payments/{paymentId}/status`.replace(
        `{${'paymentId'}}`,
        encodeURIComponent(String(paymentId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(paymentStatus, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CustomerApi - functional programming interface
 * @export
 */
export const CustomerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = CustomerApiAxiosParamCreator(configuration);
  return {
    /**
     * Allows a customer to authorize a specific mandate
     * @param {string} mandateId The mandate_id that is being authorized
     * @param {AuthorizeMandateRequest} authorizeMandateRequest request body for authorizing a mandate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authorizeMandate(
      mandateId: string,
      authorizeMandateRequest: AuthorizeMandateRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMandateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.authorizeMandate(
        mandateId,
        authorizeMandateRequest,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['CustomerApi.authorizeMandate']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * CREATE Mandate
     * @param {CreateMandateRequest} createMandateRequest request body for creating mandate
     * @param {string} [idempotencyKey] A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createMandate(
      createMandateRequest: CreateMandateRequest,
      idempotencyKey?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMandateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createMandate(
        createMandateRequest,
        idempotencyKey,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['CustomerApi.createMandate']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Create new Payment
     * @param {CreatePaymentRequest} createPaymentRequest request body for creating payment
     * @param {string} [idempotencyKey] A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPayment(
      createPaymentRequest: CreatePaymentRequest,
      idempotencyKey?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createPayment(
        createPaymentRequest,
        idempotencyKey,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['CustomerApi.createPayment']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * create payment account
     * @param {CreatePaymentAccountRequest} createPaymentAccountRequest request body for creating payment account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPaymentAccount(
      createPaymentAccountRequest: CreatePaymentAccountRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentAccountDetails>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createPaymentAccount(
        createPaymentAccountRequest,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['CustomerApi.createPaymentAccount']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Create a new payment instruction to be used when linking to perform new payment
     * @param {CustomerPaymentInstruction} paymentInstruction Request body for starting a new Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPaymentInstruction(
      paymentInstruction: CustomerPaymentInstruction,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePaymentInstructionResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createPaymentInstruction(paymentInstruction, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['CustomerApi.createPaymentInstruction']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Create a payment user
     * @param {CreatePaymentUserRequest} createPaymentUserRequest request body for creating payment user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPaymentUser(
      createPaymentUserRequest: CreatePaymentUserRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentUser>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createPaymentUser(createPaymentUserRequest, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['CustomerApi.createPaymentUser']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * delete payment account
     * @param {string} paymentAccountId The payment account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletePaymentAccount(
      paymentAccountId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletePaymentAccount(paymentAccountId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['CustomerApi.deletePaymentAccount']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * generate a link token that can be used to create link
     * @param {LinkTokenRequest} linkTokenRequest token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async generateLinkToken(
      linkTokenRequest: LinkTokenRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkTokenResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.generateLinkToken(linkTokenRequest, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['CustomerApi.generateLinkToken']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get a specific institution by institutionId
     * @param {string} institutionId The institution id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getInstitution(
      institutionId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Institution>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getInstitution(institutionId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['CustomerApi.getInstitution']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get line items for display
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLineItemsForDisplayV2(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLineItemsForDisplayResponseV2>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLineItemsForDisplayV2(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['CustomerApi.getLineItemsForDisplayV2']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get a specific loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLoginIdentityById(
      loginIdentityId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLoginIdentityByIdResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLoginIdentityById(loginIdentityId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['CustomerApi.getLoginIdentityById']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get a history of events for a specific loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLoginIdentityHistory(
      loginIdentityId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLoginIdentityHistoryResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLoginIdentityHistory(loginIdentityId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['CustomerApi.getLoginIdentityHistory']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get Mandate details by mandate_id
     * @param {string} mandateId mandate id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMandate(
      mandateId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMandateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMandate(mandateId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['CustomerApi.getMandate']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get Mandate Authorization by mandate id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMandateAuth(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMandateAuthResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMandateAuth(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['CustomerApi.getMandateAuth']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get link to launch FV Link UI in mandate authorization mode
     * @param {GetMandateAuthLinkRequest} getMandateAuthLinkRequest request body for mandate authorization link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMandateAuthLink(
      getMandateAuthLinkRequest: GetMandateAuthLinkRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMandateAuthLinkResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMandateAuthLink(getMandateAuthLinkRequest, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['CustomerApi.getMandateAuthLink']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get Payment details by payment_id
     * @param {string} paymentId payment id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPayment(
      paymentId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPayment(paymentId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['CustomerApi.getPayment']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get payment instructions by payment_instruction_id
     * @param {string} paymentInstructionId The id of a payment instruction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPaymentInstruction(
      paymentInstructionId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPaymentInstructionsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentInstruction(paymentInstructionId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['CustomerApi.getPaymentInstruction']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get a payment user
     * @param {string} paymentUserId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPaymentUser(
      paymentUserId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentUser>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentUser(paymentUserId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['CustomerApi.getPaymentUser']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get a list of institutions
     * @param {string} [country] (Deprecated) The country the institution belongs to
     * @param {Array<string>} [countries] The countries the institution belongs to
     * @param {string} [productsSupported] The products that this institution supports
     * @param {ListInstitutionsInstitutionTypeEnum} [institutionType] The type of institution
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listInstitutions(
      country?: string,
      countries?: Array<string>,
      productsSupported?: string,
      institutionType?: ListInstitutionsInstitutionTypeEnum,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Institution>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listInstitutions(
        country,
        countries,
        productsSupported,
        institutionType,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['CustomerApi.listInstitutions']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get payment account by user id
     * @param {string} paymentUserId The payment user id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listPaymentAccounts(
      paymentUserId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPaymentAccountsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listPaymentAccounts(paymentUserId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['CustomerApi.listPaymentAccounts']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get payment account for customer app
     * @param {ListPaymentAccountsWithEnrichedDataAccountTypeEnum} [accountType] The account_type to filter for
     * @param {Array<string>} [currencies] The currencies to filter for
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listPaymentAccountsWithEnrichedData(
      accountType?: ListPaymentAccountsWithEnrichedDataAccountTypeEnum,
      currencies?: Array<string>,
      offset?: number,
      limit?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPaymentAccountsWithEnrichedDataResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listPaymentAccountsWithEnrichedData(
        accountType,
        currencies,
        offset,
        limit,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['CustomerApi.listPaymentAccountsWithEnrichedData']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Refresh an access token
     * @param {RefreshRequest} refreshRequest The refresh token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async refreshToken(
      refreshRequest: RefreshRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessTokenResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(refreshRequest, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['CustomerApi.refreshToken']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Update InstitutionID and SenderType for Mandate
     * @param {SetMandateInstitutionRequest} updateRequest request body for updating mandate institutionId and senderType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setMandateInstitution(
      updateRequest: SetMandateInstitutionRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetMandateInstitutionResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setMandateInstitution(updateRequest, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['CustomerApi.setMandateInstitution']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Submit authorization checklist items
     * @param {SubmitAuthChecklistRequest} submitAuthChecklistRequest request body for submitting auth checklist
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async submitAuthChecklist(
      submitAuthChecklistRequest: SubmitAuthChecklistRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmitAuthChecklistResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.submitAuthChecklist(
        submitAuthChecklistRequest,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['CustomerApi.submitAuthChecklist']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Update payment
     * @param {string} paymentId payment id
     * @param {UpdatePaymentRequest} updatePaymentRequest request body for updating payment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePayment(
      paymentId: string,
      updatePaymentRequest: UpdatePaymentRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatePayment(paymentId, updatePaymentRequest, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['CustomerApi.updatePayment']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Update the status of a test manual payment
     * @param {string} paymentId The test payment ID
     * @param {UpdateTestPaymentStatusRequest} paymentStatus Request body for updating the test manual payment status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateTestPaymentStatus(
      paymentId: string,
      paymentStatus: UpdateTestPaymentStatusRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateTestPaymentStatus(
        paymentId,
        paymentStatus,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['CustomerApi.updateTestPaymentStatus']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * CustomerApi - factory interface
 * @export
 */
export const CustomerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = CustomerApiFp(configuration);
  return {
    /**
     * Allows a customer to authorize a specific mandate
     * @param {string} mandateId The mandate_id that is being authorized
     * @param {AuthorizeMandateRequest} authorizeMandateRequest request body for authorizing a mandate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authorizeMandate(
      mandateId: string,
      authorizeMandateRequest: AuthorizeMandateRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GetMandateResponse> {
      return localVarFp
        .authorizeMandate(mandateId, authorizeMandateRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * CREATE Mandate
     * @param {CreateMandateRequest} createMandateRequest request body for creating mandate
     * @param {string} [idempotencyKey] A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMandate(
      createMandateRequest: CreateMandateRequest,
      idempotencyKey?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<CreateMandateResponse> {
      return localVarFp
        .createMandate(createMandateRequest, idempotencyKey, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create new Payment
     * @param {CreatePaymentRequest} createPaymentRequest request body for creating payment
     * @param {string} [idempotencyKey] A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPayment(
      createPaymentRequest: CreatePaymentRequest,
      idempotencyKey?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<PaymentResponse> {
      return localVarFp
        .createPayment(createPaymentRequest, idempotencyKey, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * create payment account
     * @param {CreatePaymentAccountRequest} createPaymentAccountRequest request body for creating payment account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentAccount(
      createPaymentAccountRequest: CreatePaymentAccountRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<PaymentAccountDetails> {
      return localVarFp
        .createPaymentAccount(createPaymentAccountRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a new payment instruction to be used when linking to perform new payment
     * @param {CustomerPaymentInstruction} paymentInstruction Request body for starting a new Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentInstruction(
      paymentInstruction: CustomerPaymentInstruction,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<CreatePaymentInstructionResponse> {
      return localVarFp
        .createPaymentInstruction(paymentInstruction, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a payment user
     * @param {CreatePaymentUserRequest} createPaymentUserRequest request body for creating payment user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentUser(
      createPaymentUserRequest: CreatePaymentUserRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<PaymentUser> {
      return localVarFp
        .createPaymentUser(createPaymentUserRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * delete payment account
     * @param {string} paymentAccountId The payment account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePaymentAccount(paymentAccountId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp.deletePaymentAccount(paymentAccountId, options).then((request) => request(axios, basePath));
    },
    /**
     * generate a link token that can be used to create link
     * @param {LinkTokenRequest} linkTokenRequest token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateLinkToken(
      linkTokenRequest: LinkTokenRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<LinkTokenResponse> {
      return localVarFp.generateLinkToken(linkTokenRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Get a specific institution by institutionId
     * @param {string} institutionId The institution id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInstitution(institutionId: string, options?: RawAxiosRequestConfig): AxiosPromise<Institution> {
      return localVarFp.getInstitution(institutionId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get line items for display
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLineItemsForDisplayV2(options?: RawAxiosRequestConfig): AxiosPromise<GetLineItemsForDisplayResponseV2> {
      return localVarFp.getLineItemsForDisplayV2(options).then((request) => request(axios, basePath));
    },
    /**
     * Get a specific loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoginIdentityById(
      loginIdentityId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GetLoginIdentityByIdResponse> {
      return localVarFp.getLoginIdentityById(loginIdentityId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get a history of events for a specific loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoginIdentityHistory(
      loginIdentityId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GetLoginIdentityHistoryResponse> {
      return localVarFp.getLoginIdentityHistory(loginIdentityId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get Mandate details by mandate_id
     * @param {string} mandateId mandate id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMandate(mandateId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetMandateResponse> {
      return localVarFp.getMandate(mandateId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get Mandate Authorization by mandate id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMandateAuth(options?: RawAxiosRequestConfig): AxiosPromise<GetMandateAuthResponse> {
      return localVarFp.getMandateAuth(options).then((request) => request(axios, basePath));
    },
    /**
     * Get link to launch FV Link UI in mandate authorization mode
     * @param {GetMandateAuthLinkRequest} getMandateAuthLinkRequest request body for mandate authorization link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMandateAuthLink(
      getMandateAuthLinkRequest: GetMandateAuthLinkRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GetMandateAuthLinkResponse> {
      return localVarFp
        .getMandateAuthLink(getMandateAuthLinkRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get Payment details by payment_id
     * @param {string} paymentId payment id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPayment(paymentId: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentResponse> {
      return localVarFp.getPayment(paymentId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get payment instructions by payment_instruction_id
     * @param {string} paymentInstructionId The id of a payment instruction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentInstruction(
      paymentInstructionId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GetPaymentInstructionsResponse> {
      return localVarFp
        .getPaymentInstruction(paymentInstructionId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a payment user
     * @param {string} paymentUserId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentUser(paymentUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentUser> {
      return localVarFp.getPaymentUser(paymentUserId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get a list of institutions
     * @param {string} [country] (Deprecated) The country the institution belongs to
     * @param {Array<string>} [countries] The countries the institution belongs to
     * @param {string} [productsSupported] The products that this institution supports
     * @param {ListInstitutionsInstitutionTypeEnum} [institutionType] The type of institution
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listInstitutions(
      country?: string,
      countries?: Array<string>,
      productsSupported?: string,
      institutionType?: ListInstitutionsInstitutionTypeEnum,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<Institution>> {
      return localVarFp
        .listInstitutions(country, countries, productsSupported, institutionType, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get payment account by user id
     * @param {string} paymentUserId The payment user id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPaymentAccounts(
      paymentUserId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ListPaymentAccountsResponse> {
      return localVarFp.listPaymentAccounts(paymentUserId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get payment account for customer app
     * @param {ListPaymentAccountsWithEnrichedDataAccountTypeEnum} [accountType] The account_type to filter for
     * @param {Array<string>} [currencies] The currencies to filter for
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPaymentAccountsWithEnrichedData(
      accountType?: ListPaymentAccountsWithEnrichedDataAccountTypeEnum,
      currencies?: Array<string>,
      offset?: number,
      limit?: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ListPaymentAccountsWithEnrichedDataResponse> {
      return localVarFp
        .listPaymentAccountsWithEnrichedData(accountType, currencies, offset, limit, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Refresh an access token
     * @param {RefreshRequest} refreshRequest The refresh token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshToken(refreshRequest: RefreshRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccessTokenResponse> {
      return localVarFp.refreshToken(refreshRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Update InstitutionID and SenderType for Mandate
     * @param {SetMandateInstitutionRequest} updateRequest request body for updating mandate institutionId and senderType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setMandateInstitution(
      updateRequest: SetMandateInstitutionRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SetMandateInstitutionResponse> {
      return localVarFp.setMandateInstitution(updateRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Submit authorization checklist items
     * @param {SubmitAuthChecklistRequest} submitAuthChecklistRequest request body for submitting auth checklist
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitAuthChecklist(
      submitAuthChecklistRequest: SubmitAuthChecklistRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SubmitAuthChecklistResponse> {
      return localVarFp
        .submitAuthChecklist(submitAuthChecklistRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update payment
     * @param {string} paymentId payment id
     * @param {UpdatePaymentRequest} updatePaymentRequest request body for updating payment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePayment(
      paymentId: string,
      updatePaymentRequest: UpdatePaymentRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<PaymentResponse> {
      return localVarFp
        .updatePayment(paymentId, updatePaymentRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update the status of a test manual payment
     * @param {string} paymentId The test payment ID
     * @param {UpdateTestPaymentStatusRequest} paymentStatus Request body for updating the test manual payment status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTestPaymentStatus(
      paymentId: string,
      paymentStatus: UpdateTestPaymentStatusRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .updateTestPaymentStatus(paymentId, paymentStatus, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * CustomerApi - interface
 * @export
 * @interface CustomerApi
 */
export interface CustomerApiInterface {
  /**
   * Allows a customer to authorize a specific mandate
   * @param {string} mandateId The mandate_id that is being authorized
   * @param {AuthorizeMandateRequest} authorizeMandateRequest request body for authorizing a mandate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  authorizeMandate(
    mandateId: string,
    authorizeMandateRequest: AuthorizeMandateRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<GetMandateResponse>;

  /**
   * CREATE Mandate
   * @param {CreateMandateRequest} createMandateRequest request body for creating mandate
   * @param {string} [idempotencyKey] A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  createMandate(
    createMandateRequest: CreateMandateRequest,
    idempotencyKey?: string,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<CreateMandateResponse>;

  /**
   * Create new Payment
   * @param {CreatePaymentRequest} createPaymentRequest request body for creating payment
   * @param {string} [idempotencyKey] A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  createPayment(
    createPaymentRequest: CreatePaymentRequest,
    idempotencyKey?: string,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<PaymentResponse>;

  /**
   * create payment account
   * @param {CreatePaymentAccountRequest} createPaymentAccountRequest request body for creating payment account
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  createPaymentAccount(
    createPaymentAccountRequest: CreatePaymentAccountRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<PaymentAccountDetails>;

  /**
   * Create a new payment instruction to be used when linking to perform new payment
   * @param {CustomerPaymentInstruction} paymentInstruction Request body for starting a new Link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  createPaymentInstruction(
    paymentInstruction: CustomerPaymentInstruction,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<CreatePaymentInstructionResponse>;

  /**
   * Create a payment user
   * @param {CreatePaymentUserRequest} createPaymentUserRequest request body for creating payment user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  createPaymentUser(
    createPaymentUserRequest: CreatePaymentUserRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<PaymentUser>;

  /**
   * delete payment account
   * @param {string} paymentAccountId The payment account id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  deletePaymentAccount(paymentAccountId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

  /**
   * generate a link token that can be used to create link
   * @param {LinkTokenRequest} linkTokenRequest token request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  generateLinkToken(
    linkTokenRequest: LinkTokenRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<LinkTokenResponse>;

  /**
   * Get a specific institution by institutionId
   * @param {string} institutionId The institution id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  getInstitution(institutionId: string, options?: RawAxiosRequestConfig): AxiosPromise<Institution>;

  /**
   * Get line items for display
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  getLineItemsForDisplayV2(options?: RawAxiosRequestConfig): AxiosPromise<GetLineItemsForDisplayResponseV2>;

  /**
   * Get a specific loginIdentity
   * @param {string} loginIdentityId The login identity id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  getLoginIdentityById(
    loginIdentityId: string,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<GetLoginIdentityByIdResponse>;

  /**
   * Get a history of events for a specific loginIdentity
   * @param {string} loginIdentityId The login identity id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  getLoginIdentityHistory(
    loginIdentityId: string,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<GetLoginIdentityHistoryResponse>;

  /**
   * Get Mandate details by mandate_id
   * @param {string} mandateId mandate id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  getMandate(mandateId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetMandateResponse>;

  /**
   * Get Mandate Authorization by mandate id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  getMandateAuth(options?: RawAxiosRequestConfig): AxiosPromise<GetMandateAuthResponse>;

  /**
   * Get link to launch FV Link UI in mandate authorization mode
   * @param {GetMandateAuthLinkRequest} getMandateAuthLinkRequest request body for mandate authorization link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  getMandateAuthLink(
    getMandateAuthLinkRequest: GetMandateAuthLinkRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<GetMandateAuthLinkResponse>;

  /**
   * Get Payment details by payment_id
   * @param {string} paymentId payment id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  getPayment(paymentId: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentResponse>;

  /**
   * Get payment instructions by payment_instruction_id
   * @param {string} paymentInstructionId The id of a payment instruction
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  getPaymentInstruction(
    paymentInstructionId: string,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<GetPaymentInstructionsResponse>;

  /**
   * Get a payment user
   * @param {string} paymentUserId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  getPaymentUser(paymentUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentUser>;

  /**
   * Get a list of institutions
   * @param {string} [country] (Deprecated) The country the institution belongs to
   * @param {Array<string>} [countries] The countries the institution belongs to
   * @param {string} [productsSupported] The products that this institution supports
   * @param {ListInstitutionsInstitutionTypeEnum} [institutionType] The type of institution
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  listInstitutions(
    country?: string,
    countries?: Array<string>,
    productsSupported?: string,
    institutionType?: ListInstitutionsInstitutionTypeEnum,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<Array<Institution>>;

  /**
   * Get payment account by user id
   * @param {string} paymentUserId The payment user id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  listPaymentAccounts(
    paymentUserId: string,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<ListPaymentAccountsResponse>;

  /**
   * Get payment account for customer app
   * @param {ListPaymentAccountsWithEnrichedDataAccountTypeEnum} [accountType] The account_type to filter for
   * @param {Array<string>} [currencies] The currencies to filter for
   * @param {number} [offset] default is 0
   * @param {number} [limit] default is 500, max is 1000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  listPaymentAccountsWithEnrichedData(
    accountType?: ListPaymentAccountsWithEnrichedDataAccountTypeEnum,
    currencies?: Array<string>,
    offset?: number,
    limit?: number,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<ListPaymentAccountsWithEnrichedDataResponse>;

  /**
   * Refresh an access token
   * @param {RefreshRequest} refreshRequest The refresh token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  refreshToken(refreshRequest: RefreshRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccessTokenResponse>;

  /**
   * Update InstitutionID and SenderType for Mandate
   * @param {SetMandateInstitutionRequest} updateRequest request body for updating mandate institutionId and senderType
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  setMandateInstitution(
    updateRequest: SetMandateInstitutionRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<SetMandateInstitutionResponse>;

  /**
   * Submit authorization checklist items
   * @param {SubmitAuthChecklistRequest} submitAuthChecklistRequest request body for submitting auth checklist
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  submitAuthChecklist(
    submitAuthChecklistRequest: SubmitAuthChecklistRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<SubmitAuthChecklistResponse>;

  /**
   * Update payment
   * @param {string} paymentId payment id
   * @param {UpdatePaymentRequest} updatePaymentRequest request body for updating payment
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  updatePayment(
    paymentId: string,
    updatePaymentRequest: UpdatePaymentRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<PaymentResponse>;

  /**
   * Update the status of a test manual payment
   * @param {string} paymentId The test payment ID
   * @param {UpdateTestPaymentStatusRequest} paymentStatus Request body for updating the test manual payment status
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  updateTestPaymentStatus(
    paymentId: string,
    paymentStatus: UpdateTestPaymentStatusRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<void>;
}

/**
 * CustomerApi - object-oriented interface
 * @export
 * @class CustomerApi
 * @extends {BaseAPI}
 */
export class CustomerApi extends BaseAPI implements CustomerApiInterface {
  /**
   * Allows a customer to authorize a specific mandate
   * @param {string} mandateId The mandate_id that is being authorized
   * @param {AuthorizeMandateRequest} authorizeMandateRequest request body for authorizing a mandate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public authorizeMandate(
    mandateId: string,
    authorizeMandateRequest: AuthorizeMandateRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return CustomerApiFp(this.configuration)
      .authorizeMandate(mandateId, authorizeMandateRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * CREATE Mandate
   * @param {CreateMandateRequest} createMandateRequest request body for creating mandate
   * @param {string} [idempotencyKey] A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public createMandate(
    createMandateRequest: CreateMandateRequest,
    idempotencyKey?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return CustomerApiFp(this.configuration)
      .createMandate(createMandateRequest, idempotencyKey, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create new Payment
   * @param {CreatePaymentRequest} createPaymentRequest request body for creating payment
   * @param {string} [idempotencyKey] A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public createPayment(
    createPaymentRequest: CreatePaymentRequest,
    idempotencyKey?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return CustomerApiFp(this.configuration)
      .createPayment(createPaymentRequest, idempotencyKey, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * create payment account
   * @param {CreatePaymentAccountRequest} createPaymentAccountRequest request body for creating payment account
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public createPaymentAccount(
    createPaymentAccountRequest: CreatePaymentAccountRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return CustomerApiFp(this.configuration)
      .createPaymentAccount(createPaymentAccountRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a new payment instruction to be used when linking to perform new payment
   * @param {CustomerPaymentInstruction} paymentInstruction Request body for starting a new Link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public createPaymentInstruction(paymentInstruction: CustomerPaymentInstruction, options?: RawAxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .createPaymentInstruction(paymentInstruction, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a payment user
   * @param {CreatePaymentUserRequest} createPaymentUserRequest request body for creating payment user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public createPaymentUser(createPaymentUserRequest: CreatePaymentUserRequest, options?: RawAxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .createPaymentUser(createPaymentUserRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * delete payment account
   * @param {string} paymentAccountId The payment account id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public deletePaymentAccount(paymentAccountId: string, options?: RawAxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .deletePaymentAccount(paymentAccountId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * generate a link token that can be used to create link
   * @param {LinkTokenRequest} linkTokenRequest token request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public generateLinkToken(linkTokenRequest: LinkTokenRequest, options?: RawAxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .generateLinkToken(linkTokenRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a specific institution by institutionId
   * @param {string} institutionId The institution id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public getInstitution(institutionId: string, options?: RawAxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .getInstitution(institutionId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get line items for display
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public getLineItemsForDisplayV2(options?: RawAxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .getLineItemsForDisplayV2(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a specific loginIdentity
   * @param {string} loginIdentityId The login identity id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public getLoginIdentityById(loginIdentityId: string, options?: RawAxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .getLoginIdentityById(loginIdentityId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a history of events for a specific loginIdentity
   * @param {string} loginIdentityId The login identity id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public getLoginIdentityHistory(loginIdentityId: string, options?: RawAxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .getLoginIdentityHistory(loginIdentityId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get Mandate details by mandate_id
   * @param {string} mandateId mandate id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public getMandate(mandateId: string, options?: RawAxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .getMandate(mandateId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get Mandate Authorization by mandate id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public getMandateAuth(options?: RawAxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .getMandateAuth(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get link to launch FV Link UI in mandate authorization mode
   * @param {GetMandateAuthLinkRequest} getMandateAuthLinkRequest request body for mandate authorization link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public getMandateAuthLink(getMandateAuthLinkRequest: GetMandateAuthLinkRequest, options?: RawAxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .getMandateAuthLink(getMandateAuthLinkRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get Payment details by payment_id
   * @param {string} paymentId payment id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public getPayment(paymentId: string, options?: RawAxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .getPayment(paymentId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get payment instructions by payment_instruction_id
   * @param {string} paymentInstructionId The id of a payment instruction
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public getPaymentInstruction(paymentInstructionId: string, options?: RawAxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .getPaymentInstruction(paymentInstructionId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a payment user
   * @param {string} paymentUserId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public getPaymentUser(paymentUserId: string, options?: RawAxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .getPaymentUser(paymentUserId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of institutions
   * @param {string} [country] (Deprecated) The country the institution belongs to
   * @param {Array<string>} [countries] The countries the institution belongs to
   * @param {string} [productsSupported] The products that this institution supports
   * @param {ListInstitutionsInstitutionTypeEnum} [institutionType] The type of institution
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public listInstitutions(
    country?: string,
    countries?: Array<string>,
    productsSupported?: string,
    institutionType?: ListInstitutionsInstitutionTypeEnum,
    options?: RawAxiosRequestConfig,
  ) {
    return CustomerApiFp(this.configuration)
      .listInstitutions(country, countries, productsSupported, institutionType, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get payment account by user id
   * @param {string} paymentUserId The payment user id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public listPaymentAccounts(paymentUserId: string, options?: RawAxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .listPaymentAccounts(paymentUserId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get payment account for customer app
   * @param {ListPaymentAccountsWithEnrichedDataAccountTypeEnum} [accountType] The account_type to filter for
   * @param {Array<string>} [currencies] The currencies to filter for
   * @param {number} [offset] default is 0
   * @param {number} [limit] default is 500, max is 1000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public listPaymentAccountsWithEnrichedData(
    accountType?: ListPaymentAccountsWithEnrichedDataAccountTypeEnum,
    currencies?: Array<string>,
    offset?: number,
    limit?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return CustomerApiFp(this.configuration)
      .listPaymentAccountsWithEnrichedData(accountType, currencies, offset, limit, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Refresh an access token
   * @param {RefreshRequest} refreshRequest The refresh token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public refreshToken(refreshRequest: RefreshRequest, options?: RawAxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .refreshToken(refreshRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update InstitutionID and SenderType for Mandate
   * @param {SetMandateInstitutionRequest} updateRequest request body for updating mandate institutionId and senderType
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public setMandateInstitution(updateRequest: SetMandateInstitutionRequest, options?: RawAxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .setMandateInstitution(updateRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Submit authorization checklist items
   * @param {SubmitAuthChecklistRequest} submitAuthChecklistRequest request body for submitting auth checklist
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public submitAuthChecklist(submitAuthChecklistRequest: SubmitAuthChecklistRequest, options?: RawAxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .submitAuthChecklist(submitAuthChecklistRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update payment
   * @param {string} paymentId payment id
   * @param {UpdatePaymentRequest} updatePaymentRequest request body for updating payment
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public updatePayment(paymentId: string, updatePaymentRequest: UpdatePaymentRequest, options?: RawAxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .updatePayment(paymentId, updatePaymentRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update the status of a test manual payment
   * @param {string} paymentId The test payment ID
   * @param {UpdateTestPaymentStatusRequest} paymentStatus Request body for updating the test manual payment status
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public updateTestPaymentStatus(
    paymentId: string,
    paymentStatus: UpdateTestPaymentStatusRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return CustomerApiFp(this.configuration)
      .updateTestPaymentStatus(paymentId, paymentStatus, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const ListInstitutionsInstitutionTypeEnum = {
  Bank: 'BANK',
  Wallet: 'WALLET',
  Test: 'TEST',
} as const;
export type ListInstitutionsInstitutionTypeEnum =
  (typeof ListInstitutionsInstitutionTypeEnum)[keyof typeof ListInstitutionsInstitutionTypeEnum];
/**
 * @export
 */
export const ListPaymentAccountsWithEnrichedDataAccountTypeEnum = {
  ExternalAccount: 'EXTERNAL_ACCOUNT',
  SettlementAccount: 'SETTLEMENT_ACCOUNT',
} as const;
export type ListPaymentAccountsWithEnrichedDataAccountTypeEnum =
  (typeof ListPaymentAccountsWithEnrichedDataAccountTypeEnum)[keyof typeof ListPaymentAccountsWithEnrichedDataAccountTypeEnum];

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Cancel a payment link
     * @param {string} paymentLinkId The payment link id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelPaymentLink: async (paymentLinkId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'paymentLinkId' is not null or undefined
      assertParamExists('cancelPaymentLink', 'paymentLinkId', paymentLinkId);
      const localVarPath = `/payment_links/{paymentLinkId}/cancel`.replace(
        `{${'paymentLinkId'}}`,
        encodeURIComponent(String(paymentLinkId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Cancel Payout by payout_id
     * @param {string} payoutId payout id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelPayout: async (payoutId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'payoutId' is not null or undefined
      assertParamExists('cancelPayout', 'payoutId', payoutId);
      const localVarPath = `/payouts/{payoutId}/cancel`.replace(
        `{${'payoutId'}}`,
        encodeURIComponent(String(payoutId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Initiate change payment method from payment link front-end
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePaymentMethodPaymentLink: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/payment_link/fvlink/payment_method/change`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Complete a KCP payment
     * @param {CompleteKcpPaymentRequest} completeKcpPaymentRequest Parameters from the KCP SDK callback to complete the payment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    completeKcpPayment: async (
      completeKcpPaymentRequest: CompleteKcpPaymentRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'completeKcpPaymentRequest' is not null or undefined
      assertParamExists('completeKcpPayment', 'completeKcpPaymentRequest', completeKcpPaymentRequest);
      const localVarPath = `/payment_links/kcp/payment`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        completeKcpPaymentRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Submit manual payment confirmation
     * @param {ManualPaymentConfirmationRequest} manualPaymentIdentifiers Request body containing information to identify manual payment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmManualPayment: async (
      manualPaymentIdentifiers: ManualPaymentConfirmationRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'manualPaymentIdentifiers' is not null or undefined
      assertParamExists('confirmManualPayment', 'manualPaymentIdentifiers', manualPaymentIdentifiers);
      const localVarPath = `/payments/manual_payment`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        manualPaymentIdentifiers,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Confirm a payment against a payment Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmPayment: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/payment_links/confirm`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create mandate for an existing sender account
     * @param {string} idempotencyKey A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {CreateMandateWithSenderAccountRequest} createMandateRequest request body for creating mandate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMandateForExistingSender: async (
      idempotencyKey: string,
      createMandateRequest: CreateMandateWithSenderAccountRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'idempotencyKey' is not null or undefined
      assertParamExists('createMandateForExistingSender', 'idempotencyKey', idempotencyKey);
      // verify required parameter 'createMandateRequest' is not null or undefined
      assertParamExists('createMandateForExistingSender', 'createMandateRequest', createMandateRequest);
      const localVarPath = `/mandates/sender_account`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      if (idempotencyKey != null) {
        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(createMandateRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create payment link
     * @param {CreatePaymentLinkRequest} createPaymentLinkRequest Parameters required to create a payment link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentLink: async (
      createPaymentLinkRequest: CreatePaymentLinkRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createPaymentLinkRequest' is not null or undefined
      assertParamExists('createPaymentLink', 'createPaymentLinkRequest', createPaymentLinkRequest);
      const localVarPath = `/payment_links`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createPaymentLinkRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a Payment Method for a user
     * @param {string} paymentUserId Payment User ID
     * @param {CreatePaymentMethodRequest} createPaymentMethodRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentMethod: async (
      paymentUserId: string,
      createPaymentMethodRequest: CreatePaymentMethodRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'paymentUserId' is not null or undefined
      assertParamExists('createPaymentMethod', 'paymentUserId', paymentUserId);
      // verify required parameter 'createPaymentMethodRequest' is not null or undefined
      assertParamExists('createPaymentMethod', 'createPaymentMethodRequest', createPaymentMethodRequest);
      const localVarPath = `/payment_users/{paymentUserId}/payment_methods`.replace(
        `{${'paymentUserId'}}`,
        encodeURIComponent(String(paymentUserId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createPaymentMethodRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a scheduled payout
     * @param {string} idempotencyKey A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {CreateScheduledPayoutRequest} createScheduledPayoutRequest Request body containing information to create scheduled payout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createScheduledPayout: async (
      idempotencyKey: string,
      createScheduledPayoutRequest: CreateScheduledPayoutRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'idempotencyKey' is not null or undefined
      assertParamExists('createScheduledPayout', 'idempotencyKey', idempotencyKey);
      // verify required parameter 'createScheduledPayoutRequest' is not null or undefined
      assertParamExists('createScheduledPayout', 'createScheduledPayoutRequest', createScheduledPayoutRequest);
      const localVarPath = `/payouts/scheduled`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      if (idempotencyKey != null) {
        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createScheduledPayoutRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Demote payment attempt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    demotePaymentAttempt: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/payment_link/fvlink/payment_attempt/demote`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Download the balance statement for the ledger (CSV)
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<string>} [currencies] The currencies to filter for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadBalanceStatement: async (
      dateFrom?: string,
      dateTo?: string,
      currencies?: Array<string>,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/ledger/statement`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      if (dateFrom !== undefined) {
        localVarQueryParameter['date_from'] =
          (dateFrom as any) instanceof Date ? (dateFrom as any).toISOString().substring(0, 10) : dateFrom;
      }

      if (dateTo !== undefined) {
        localVarQueryParameter['date_to'] =
          (dateTo as any) instanceof Date ? (dateTo as any).toISOString().substring(0, 10) : dateTo;
      }

      if (currencies) {
        localVarQueryParameter['currencies'] = currencies.join(COLLECTION_FORMATS.csv);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the FPS QR code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFpsQrCode: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/payment_links/fps/qr_code`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a customer-specific list of institutions for Finverse Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInstitutionsForCustomer: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/institutions/customer`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get payment link
     * @param {string} paymentLinkId The payment link id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentLink: async (paymentLinkId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'paymentLinkId' is not null or undefined
      assertParamExists('getPaymentLink', 'paymentLinkId', paymentLinkId);
      const localVarPath = `/payment_links/{paymentLinkId}`.replace(
        `{${'paymentLinkId'}}`,
        encodeURIComponent(String(paymentLinkId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a payment method
     * @param {string} paymentMethodId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentMethod: async (paymentMethodId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'paymentMethodId' is not null or undefined
      assertParamExists('getPaymentMethod', 'paymentMethodId', paymentMethodId);
      const localVarPath = `/payment_methods/{paymentMethodId}`.replace(
        `{${'paymentMethodId'}}`,
        encodeURIComponent(String(paymentMethodId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get payment method in payment link flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentMethodPaymentLink: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/payment_link/fvlink/payment_method`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get payment (if exists) on the payment link for front-end
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentPaymentLink: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/payment_link/fvlink/payment`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get payout by payout_id
     * @param {string} payoutId payout id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPayoutById: async (payoutId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'payoutId' is not null or undefined
      assertParamExists('getPayoutById', 'payoutId', payoutId);
      const localVarPath = `/payouts/{payoutId}`.replace(`{${'payoutId'}}`, encodeURIComponent(String(payoutId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get sender payment user in payment link flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSenderPaymentUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/payment_link/fvlink/payment_user/sender`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List available payment methods
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAvailablePaymentMethodsPaymentLink: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/payment_link/fvlink/available_payment_methods`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List mandates details
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListDetokenizedMandatesStatusesEnum>} [statuses] The mandate statuses to filter for, comma separated
     * @param {ListDetokenizedMandatesSenderTypeEnum} [senderType] The sender type of the mandate
     * @param {string} [userId] The user_id the mandate was setup for
     * @param {string} [institutionId] The institution the mandate was executed against
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listDetokenizedMandates: async (
      dateFrom?: string,
      dateTo?: string,
      statuses?: Array<ListDetokenizedMandatesStatusesEnum>,
      senderType?: ListDetokenizedMandatesSenderTypeEnum,
      userId?: string,
      institutionId?: string,
      offset?: number,
      limit?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/mandates/details`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      if (dateFrom !== undefined) {
        localVarQueryParameter['date_from'] =
          (dateFrom as any) instanceof Date ? (dateFrom as any).toISOString().substring(0, 10) : dateFrom;
      }

      if (dateTo !== undefined) {
        localVarQueryParameter['date_to'] =
          (dateTo as any) instanceof Date ? (dateTo as any).toISOString().substring(0, 10) : dateTo;
      }

      if (statuses) {
        localVarQueryParameter['statuses'] = statuses.join(COLLECTION_FORMATS.csv);
      }

      if (senderType !== undefined) {
        localVarQueryParameter['sender_type'] = senderType;
      }

      if (userId !== undefined) {
        localVarQueryParameter['user_id'] = userId;
      }

      if (institutionId !== undefined) {
        localVarQueryParameter['institution_id'] = institutionId;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List Disputes
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListDisputesStatusesEnum>} [statuses] The dispute statuses to filter for, comma separated
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listDisputes: async (
      dateFrom?: string,
      dateTo?: string,
      statuses?: Array<ListDisputesStatusesEnum>,
      offset?: number,
      limit?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/disputes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      if (dateFrom !== undefined) {
        localVarQueryParameter['date_from'] =
          (dateFrom as any) instanceof Date ? (dateFrom as any).toISOString().substring(0, 10) : dateFrom;
      }

      if (dateTo !== undefined) {
        localVarQueryParameter['date_to'] =
          (dateTo as any) instanceof Date ? (dateTo as any).toISOString().substring(0, 10) : dateTo;
      }

      if (statuses) {
        localVarQueryParameter['statuses'] = statuses.join(COLLECTION_FORMATS.csv);
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List mandates
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListMandatesStatusesEnum>} [statuses] The mandate statuses to filter for, comma separated
     * @param {ListMandatesSenderTypeEnum} [senderType] The sender type of the mandate
     * @param {string} [userId] The user_id the mandate was setup for
     * @param {string} [institutionId] The institution the mandate was executed against
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMandates: async (
      dateFrom?: string,
      dateTo?: string,
      statuses?: Array<ListMandatesStatusesEnum>,
      senderType?: ListMandatesSenderTypeEnum,
      userId?: string,
      institutionId?: string,
      offset?: number,
      limit?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/mandates`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      if (dateFrom !== undefined) {
        localVarQueryParameter['date_from'] =
          (dateFrom as any) instanceof Date ? (dateFrom as any).toISOString().substring(0, 10) : dateFrom;
      }

      if (dateTo !== undefined) {
        localVarQueryParameter['date_to'] =
          (dateTo as any) instanceof Date ? (dateTo as any).toISOString().substring(0, 10) : dateTo;
      }

      if (statuses) {
        localVarQueryParameter['statuses'] = statuses.join(COLLECTION_FORMATS.csv);
      }

      if (senderType !== undefined) {
        localVarQueryParameter['sender_type'] = senderType;
      }

      if (userId !== undefined) {
        localVarQueryParameter['user_id'] = userId;
      }

      if (institutionId !== undefined) {
        localVarQueryParameter['institution_id'] = institutionId;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List Payment Methods for a User
     * @param {string} paymentUserId Payment User Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPaymentMethods: async (paymentUserId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'paymentUserId' is not null or undefined
      assertParamExists('listPaymentMethods', 'paymentUserId', paymentUserId);
      const localVarPath = `/payment_users/{paymentUserId}/payment_methods`.replace(
        `{${'paymentUserId'}}`,
        encodeURIComponent(String(paymentUserId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List Payments
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListPaymentsStatusesEnum>} [statuses] The payment statuses to filter for, comma separated
     * @param {ListPaymentsSenderTypeEnum} [senderType] The sender type of the mandate
     * @param {string} [userId] The user_id the mandate was setup for
     * @param {string} [institutionId] The institution the mandate was executed against
     * @param {ListPaymentsPaymentTypeEnum} [paymentType] Deprecated - The type of payment
     * @param {Array<ListPaymentsPaymentTypesEnum>} [paymentTypes]
     * @param {string} [mandateId] The mandate the payment belongs to
     * @param {string} [currency] Deprecated - The currency the payment is made in
     * @param {Array<string>} [currencies]
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPayments: async (
      dateFrom?: string,
      dateTo?: string,
      statuses?: Array<ListPaymentsStatusesEnum>,
      senderType?: ListPaymentsSenderTypeEnum,
      userId?: string,
      institutionId?: string,
      paymentType?: ListPaymentsPaymentTypeEnum,
      paymentTypes?: Array<ListPaymentsPaymentTypesEnum>,
      mandateId?: string,
      currency?: string,
      currencies?: Array<string>,
      offset?: number,
      limit?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/payments`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      if (dateFrom !== undefined) {
        localVarQueryParameter['date_from'] =
          (dateFrom as any) instanceof Date ? (dateFrom as any).toISOString().substring(0, 10) : dateFrom;
      }

      if (dateTo !== undefined) {
        localVarQueryParameter['date_to'] =
          (dateTo as any) instanceof Date ? (dateTo as any).toISOString().substring(0, 10) : dateTo;
      }

      if (statuses) {
        localVarQueryParameter['statuses'] = statuses.join(COLLECTION_FORMATS.csv);
      }

      if (senderType !== undefined) {
        localVarQueryParameter['sender_type'] = senderType;
      }

      if (userId !== undefined) {
        localVarQueryParameter['user_id'] = userId;
      }

      if (institutionId !== undefined) {
        localVarQueryParameter['institution_id'] = institutionId;
      }

      if (paymentType !== undefined) {
        localVarQueryParameter['payment_type'] = paymentType;
      }

      if (paymentTypes) {
        localVarQueryParameter['payment_types'] = paymentTypes.join(COLLECTION_FORMATS.csv);
      }

      if (mandateId !== undefined) {
        localVarQueryParameter['mandate_id'] = mandateId;
      }

      if (currency !== undefined) {
        localVarQueryParameter['currency'] = currency;
      }

      if (currencies) {
        localVarQueryParameter['currencies'] = currencies.join(COLLECTION_FORMATS.csv);
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List payouts
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListPayoutsStatusesEnum>} [statuses] The payout statuses to filter for, comma separated
     * @param {Array<string>} [currencies]
     * @param {Array<ListPayoutsPayoutTypesEnum>} [payoutTypes]
     * @param {string} [mandateId]
     * @param {string} [senderAccountId]
     * @param {string} [recipientAccountId]
     * @param {string} [recipientUserId]
     * @param {string} [recipientExternalUserId]
     * @param {number} [offset] Default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPayouts: async (
      dateFrom?: string,
      dateTo?: string,
      statuses?: Array<ListPayoutsStatusesEnum>,
      currencies?: Array<string>,
      payoutTypes?: Array<ListPayoutsPayoutTypesEnum>,
      mandateId?: string,
      senderAccountId?: string,
      recipientAccountId?: string,
      recipientUserId?: string,
      recipientExternalUserId?: string,
      offset?: number,
      limit?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/payouts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      if (dateFrom !== undefined) {
        localVarQueryParameter['date_from'] =
          (dateFrom as any) instanceof Date ? (dateFrom as any).toISOString().substring(0, 10) : dateFrom;
      }

      if (dateTo !== undefined) {
        localVarQueryParameter['date_to'] =
          (dateTo as any) instanceof Date ? (dateTo as any).toISOString().substring(0, 10) : dateTo;
      }

      if (statuses) {
        localVarQueryParameter['statuses'] = statuses.join(COLLECTION_FORMATS.csv);
      }

      if (currencies) {
        localVarQueryParameter['currencies'] = currencies.join(COLLECTION_FORMATS.csv);
      }

      if (payoutTypes) {
        localVarQueryParameter['payout_types'] = payoutTypes.join(COLLECTION_FORMATS.csv);
      }

      if (mandateId !== undefined) {
        localVarQueryParameter['mandate_id'] = mandateId;
      }

      if (senderAccountId !== undefined) {
        localVarQueryParameter['sender_account_id'] = senderAccountId;
      }

      if (recipientAccountId !== undefined) {
        localVarQueryParameter['recipient_account_id'] = recipientAccountId;
      }

      if (recipientUserId !== undefined) {
        localVarQueryParameter['recipient_user_id'] = recipientUserId;
      }

      if (recipientExternalUserId !== undefined) {
        localVarQueryParameter['recipient_external_user_id'] = recipientExternalUserId;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Refresh payment attempt from payment link front-end
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshPaymentAttempt: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/payment_link/fvlink/payment_attempt/refresh`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Select a payment method for payment link
     * @param {SelectPaymentMethodRequest} selectPaymentMethodRequest request body for selecting a payment method
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    selectPaymentMethodPaymentLink: async (
      selectPaymentMethodRequest: SelectPaymentMethodRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'selectPaymentMethodRequest' is not null or undefined
      assertParamExists('selectPaymentMethodPaymentLink', 'selectPaymentMethodRequest', selectPaymentMethodRequest);
      const localVarPath = `/payment_links/fvlink/select_payment_method`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        selectPaymentMethodRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Set autopay consent for payment user
     * @param {SetAutopayConsentRequest} setAutopayConsentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setAutopayConsent: async (
      setAutopayConsentRequest: SetAutopayConsentRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'setAutopayConsentRequest' is not null or undefined
      assertParamExists('setAutopayConsent', 'setAutopayConsentRequest', setAutopayConsentRequest);
      const localVarPath = `/payment_link/fvlink/payment_user/autopay`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        setAutopayConsentRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update a payment user
     * @param {string} paymentUserId
     * @param {UpdatePaymentUserRequest} updatePaymentUserRequest request body for updating payment user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePaymentUser: async (
      paymentUserId: string,
      updatePaymentUserRequest: UpdatePaymentUserRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'paymentUserId' is not null or undefined
      assertParamExists('updatePaymentUser', 'paymentUserId', paymentUserId);
      // verify required parameter 'updatePaymentUserRequest' is not null or undefined
      assertParamExists('updatePaymentUser', 'updatePaymentUserRequest', updatePaymentUserRequest);
      const localVarPath = `/payment_users/{paymentUserId}`.replace(
        `{${'paymentUserId'}}`,
        encodeURIComponent(String(paymentUserId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updatePaymentUserRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration);
  return {
    /**
     * Cancel a payment link
     * @param {string} paymentLinkId The payment link id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cancelPaymentLink(
      paymentLinkId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentLinkResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.cancelPaymentLink(paymentLinkId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.cancelPaymentLink']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Cancel Payout by payout_id
     * @param {string} payoutId payout id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cancelPayout(
      payoutId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayoutSnapshotResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.cancelPayout(payoutId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.cancelPayout']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Initiate change payment method from payment link front-end
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async changePaymentMethodPaymentLink(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChangePaymentMethodFvLinkResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.changePaymentMethodPaymentLink(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.changePaymentMethodPaymentLink']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Complete a KCP payment
     * @param {CompleteKcpPaymentRequest} completeKcpPaymentRequest Parameters from the KCP SDK callback to complete the payment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async completeKcpPayment(
      completeKcpPaymentRequest: CompleteKcpPaymentRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompleteKcpPaymentResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.completeKcpPayment(completeKcpPaymentRequest, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.completeKcpPayment']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Submit manual payment confirmation
     * @param {ManualPaymentConfirmationRequest} manualPaymentIdentifiers Request body containing information to identify manual payment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async confirmManualPayment(
      manualPaymentIdentifiers: ManualPaymentConfirmationRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManualPaymentConfirmationResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.confirmManualPayment(manualPaymentIdentifiers, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.confirmManualPayment']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Confirm a payment against a payment Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async confirmPayment(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfirmPaymentResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.confirmPayment(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.confirmPayment']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Create mandate for an existing sender account
     * @param {string} idempotencyKey A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {CreateMandateWithSenderAccountRequest} createMandateRequest request body for creating mandate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createMandateForExistingSender(
      idempotencyKey: string,
      createMandateRequest: CreateMandateWithSenderAccountRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMandateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createMandateForExistingSender(
        idempotencyKey,
        createMandateRequest,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.createMandateForExistingSender']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Create payment link
     * @param {CreatePaymentLinkRequest} createPaymentLinkRequest Parameters required to create a payment link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPaymentLink(
      createPaymentLinkRequest: CreatePaymentLinkRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentLinkResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createPaymentLink(createPaymentLinkRequest, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.createPaymentLink']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Create a Payment Method for a user
     * @param {string} paymentUserId Payment User ID
     * @param {CreatePaymentMethodRequest} createPaymentMethodRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPaymentMethod(
      paymentUserId: string,
      createPaymentMethodRequest: CreatePaymentMethodRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentMethodResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createPaymentMethod(
        paymentUserId,
        createPaymentMethodRequest,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.createPaymentMethod']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Create a scheduled payout
     * @param {string} idempotencyKey A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {CreateScheduledPayoutRequest} createScheduledPayoutRequest Request body containing information to create scheduled payout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createScheduledPayout(
      idempotencyKey: string,
      createScheduledPayoutRequest: CreateScheduledPayoutRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayoutSnapshotResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createScheduledPayout(
        idempotencyKey,
        createScheduledPayoutRequest,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.createScheduledPayout']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Demote payment attempt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async demotePaymentAttempt(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.demotePaymentAttempt(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.demotePaymentAttempt']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Download the balance statement for the ledger (CSV)
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<string>} [currencies] The currencies to filter for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async downloadBalanceStatement(
      dateFrom?: string,
      dateTo?: string,
      currencies?: Array<string>,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DownloadBalanceStatementResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.downloadBalanceStatement(
        dateFrom,
        dateTo,
        currencies,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.downloadBalanceStatement']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get the FPS QR code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFpsQrCode(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FpsQrCodeResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFpsQrCode(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.getFpsQrCode']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get a customer-specific list of institutions for Finverse Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getInstitutionsForCustomer(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Institution>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getInstitutionsForCustomer(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.getInstitutionsForCustomer']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get payment link
     * @param {string} paymentLinkId The payment link id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPaymentLink(
      paymentLinkId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentLinkResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentLink(paymentLinkId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.getPaymentLink']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get a payment method
     * @param {string} paymentMethodId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPaymentMethod(
      paymentMethodId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentMethodResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentMethod(paymentMethodId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.getPaymentMethod']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get payment method in payment link flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPaymentMethodPaymentLink(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentMethodFvLinkResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentMethodPaymentLink(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.getPaymentMethodPaymentLink']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get payment (if exists) on the payment link for front-end
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPaymentPaymentLink(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentFvLinkResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentPaymentLink(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.getPaymentPaymentLink']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get payout by payout_id
     * @param {string} payoutId payout id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPayoutById(
      payoutId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayoutSnapshotResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPayoutById(payoutId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.getPayoutById']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get sender payment user in payment link flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSenderPaymentUser(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPaymentUserResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSenderPaymentUser(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.getSenderPaymentUser']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * List available payment methods
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listAvailablePaymentMethodsPaymentLink(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailablePaymentMethodsFvLinkResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listAvailablePaymentMethodsPaymentLink(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.listAvailablePaymentMethodsPaymentLink']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * List mandates details
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListDetokenizedMandatesStatusesEnum>} [statuses] The mandate statuses to filter for, comma separated
     * @param {ListDetokenizedMandatesSenderTypeEnum} [senderType] The sender type of the mandate
     * @param {string} [userId] The user_id the mandate was setup for
     * @param {string} [institutionId] The institution the mandate was executed against
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listDetokenizedMandates(
      dateFrom?: string,
      dateTo?: string,
      statuses?: Array<ListDetokenizedMandatesStatusesEnum>,
      senderType?: ListDetokenizedMandatesSenderTypeEnum,
      userId?: string,
      institutionId?: string,
      offset?: number,
      limit?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMandatesResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listDetokenizedMandates(
        dateFrom,
        dateTo,
        statuses,
        senderType,
        userId,
        institutionId,
        offset,
        limit,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.listDetokenizedMandates']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * List Disputes
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListDisputesStatusesEnum>} [statuses] The dispute statuses to filter for, comma separated
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listDisputes(
      dateFrom?: string,
      dateTo?: string,
      statuses?: Array<ListDisputesStatusesEnum>,
      offset?: number,
      limit?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListDisputesResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listDisputes(
        dateFrom,
        dateTo,
        statuses,
        offset,
        limit,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.listDisputes']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * List mandates
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListMandatesStatusesEnum>} [statuses] The mandate statuses to filter for, comma separated
     * @param {ListMandatesSenderTypeEnum} [senderType] The sender type of the mandate
     * @param {string} [userId] The user_id the mandate was setup for
     * @param {string} [institutionId] The institution the mandate was executed against
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listMandates(
      dateFrom?: string,
      dateTo?: string,
      statuses?: Array<ListMandatesStatusesEnum>,
      senderType?: ListMandatesSenderTypeEnum,
      userId?: string,
      institutionId?: string,
      offset?: number,
      limit?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMandatesResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listMandates(
        dateFrom,
        dateTo,
        statuses,
        senderType,
        userId,
        institutionId,
        offset,
        limit,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.listMandates']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * List Payment Methods for a User
     * @param {string} paymentUserId Payment User Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listPaymentMethods(
      paymentUserId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPaymentMethodsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listPaymentMethods(paymentUserId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.listPaymentMethods']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * List Payments
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListPaymentsStatusesEnum>} [statuses] The payment statuses to filter for, comma separated
     * @param {ListPaymentsSenderTypeEnum} [senderType] The sender type of the mandate
     * @param {string} [userId] The user_id the mandate was setup for
     * @param {string} [institutionId] The institution the mandate was executed against
     * @param {ListPaymentsPaymentTypeEnum} [paymentType] Deprecated - The type of payment
     * @param {Array<ListPaymentsPaymentTypesEnum>} [paymentTypes]
     * @param {string} [mandateId] The mandate the payment belongs to
     * @param {string} [currency] Deprecated - The currency the payment is made in
     * @param {Array<string>} [currencies]
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listPayments(
      dateFrom?: string,
      dateTo?: string,
      statuses?: Array<ListPaymentsStatusesEnum>,
      senderType?: ListPaymentsSenderTypeEnum,
      userId?: string,
      institutionId?: string,
      paymentType?: ListPaymentsPaymentTypeEnum,
      paymentTypes?: Array<ListPaymentsPaymentTypesEnum>,
      mandateId?: string,
      currency?: string,
      currencies?: Array<string>,
      offset?: number,
      limit?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPaymentsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listPayments(
        dateFrom,
        dateTo,
        statuses,
        senderType,
        userId,
        institutionId,
        paymentType,
        paymentTypes,
        mandateId,
        currency,
        currencies,
        offset,
        limit,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.listPayments']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * List payouts
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListPayoutsStatusesEnum>} [statuses] The payout statuses to filter for, comma separated
     * @param {Array<string>} [currencies]
     * @param {Array<ListPayoutsPayoutTypesEnum>} [payoutTypes]
     * @param {string} [mandateId]
     * @param {string} [senderAccountId]
     * @param {string} [recipientAccountId]
     * @param {string} [recipientUserId]
     * @param {string} [recipientExternalUserId]
     * @param {number} [offset] Default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listPayouts(
      dateFrom?: string,
      dateTo?: string,
      statuses?: Array<ListPayoutsStatusesEnum>,
      currencies?: Array<string>,
      payoutTypes?: Array<ListPayoutsPayoutTypesEnum>,
      mandateId?: string,
      senderAccountId?: string,
      recipientAccountId?: string,
      recipientUserId?: string,
      recipientExternalUserId?: string,
      offset?: number,
      limit?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPayoutsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listPayouts(
        dateFrom,
        dateTo,
        statuses,
        currencies,
        payoutTypes,
        mandateId,
        senderAccountId,
        recipientAccountId,
        recipientUserId,
        recipientExternalUserId,
        offset,
        limit,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.listPayouts']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Refresh payment attempt from payment link front-end
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async refreshPaymentAttempt(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshPaymentAttemptResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.refreshPaymentAttempt(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.refreshPaymentAttempt']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Select a payment method for payment link
     * @param {SelectPaymentMethodRequest} selectPaymentMethodRequest request body for selecting a payment method
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async selectPaymentMethodPaymentLink(
      selectPaymentMethodRequest: SelectPaymentMethodRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SelectPaymentMethodResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.selectPaymentMethodPaymentLink(
        selectPaymentMethodRequest,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.selectPaymentMethodPaymentLink']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Set autopay consent for payment user
     * @param {SetAutopayConsentRequest} setAutopayConsentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setAutopayConsent(
      setAutopayConsentRequest: SetAutopayConsentRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setAutopayConsent(setAutopayConsentRequest, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.setAutopayConsent']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Update a payment user
     * @param {string} paymentUserId
     * @param {UpdatePaymentUserRequest} updatePaymentUserRequest request body for updating payment user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePaymentUser(
      paymentUserId: string,
      updatePaymentUserRequest: UpdatePaymentUserRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentUser>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatePaymentUser(
        paymentUserId,
        updatePaymentUserRequest,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.updatePaymentUser']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = DefaultApiFp(configuration);
  return {
    /**
     * Cancel a payment link
     * @param {string} paymentLinkId The payment link id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelPaymentLink(paymentLinkId: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentLinkResponse> {
      return localVarFp.cancelPaymentLink(paymentLinkId, options).then((request) => request(axios, basePath));
    },
    /**
     * Cancel Payout by payout_id
     * @param {string} payoutId payout id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelPayout(payoutId: string, options?: RawAxiosRequestConfig): AxiosPromise<PayoutSnapshotResponse> {
      return localVarFp.cancelPayout(payoutId, options).then((request) => request(axios, basePath));
    },
    /**
     * Initiate change payment method from payment link front-end
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePaymentMethodPaymentLink(options?: RawAxiosRequestConfig): AxiosPromise<ChangePaymentMethodFvLinkResponse> {
      return localVarFp.changePaymentMethodPaymentLink(options).then((request) => request(axios, basePath));
    },
    /**
     * Complete a KCP payment
     * @param {CompleteKcpPaymentRequest} completeKcpPaymentRequest Parameters from the KCP SDK callback to complete the payment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    completeKcpPayment(
      completeKcpPaymentRequest: CompleteKcpPaymentRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<CompleteKcpPaymentResponse> {
      return localVarFp
        .completeKcpPayment(completeKcpPaymentRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Submit manual payment confirmation
     * @param {ManualPaymentConfirmationRequest} manualPaymentIdentifiers Request body containing information to identify manual payment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmManualPayment(
      manualPaymentIdentifiers: ManualPaymentConfirmationRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ManualPaymentConfirmationResponse> {
      return localVarFp
        .confirmManualPayment(manualPaymentIdentifiers, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Confirm a payment against a payment Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmPayment(options?: RawAxiosRequestConfig): AxiosPromise<ConfirmPaymentResponse> {
      return localVarFp.confirmPayment(options).then((request) => request(axios, basePath));
    },
    /**
     * Create mandate for an existing sender account
     * @param {string} idempotencyKey A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {CreateMandateWithSenderAccountRequest} createMandateRequest request body for creating mandate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMandateForExistingSender(
      idempotencyKey: string,
      createMandateRequest: CreateMandateWithSenderAccountRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<CreateMandateResponse> {
      return localVarFp
        .createMandateForExistingSender(idempotencyKey, createMandateRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create payment link
     * @param {CreatePaymentLinkRequest} createPaymentLinkRequest Parameters required to create a payment link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentLink(
      createPaymentLinkRequest: CreatePaymentLinkRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<PaymentLinkResponse> {
      return localVarFp
        .createPaymentLink(createPaymentLinkRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a Payment Method for a user
     * @param {string} paymentUserId Payment User ID
     * @param {CreatePaymentMethodRequest} createPaymentMethodRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentMethod(
      paymentUserId: string,
      createPaymentMethodRequest: CreatePaymentMethodRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<PaymentMethodResponse> {
      return localVarFp
        .createPaymentMethod(paymentUserId, createPaymentMethodRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a scheduled payout
     * @param {string} idempotencyKey A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {CreateScheduledPayoutRequest} createScheduledPayoutRequest Request body containing information to create scheduled payout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createScheduledPayout(
      idempotencyKey: string,
      createScheduledPayoutRequest: CreateScheduledPayoutRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<PayoutSnapshotResponse> {
      return localVarFp
        .createScheduledPayout(idempotencyKey, createScheduledPayoutRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Demote payment attempt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    demotePaymentAttempt(options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp.demotePaymentAttempt(options).then((request) => request(axios, basePath));
    },
    /**
     * Download the balance statement for the ledger (CSV)
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<string>} [currencies] The currencies to filter for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadBalanceStatement(
      dateFrom?: string,
      dateTo?: string,
      currencies?: Array<string>,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<DownloadBalanceStatementResponse> {
      return localVarFp
        .downloadBalanceStatement(dateFrom, dateTo, currencies, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get the FPS QR code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFpsQrCode(options?: RawAxiosRequestConfig): AxiosPromise<FpsQrCodeResponse> {
      return localVarFp.getFpsQrCode(options).then((request) => request(axios, basePath));
    },
    /**
     * Get a customer-specific list of institutions for Finverse Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInstitutionsForCustomer(options?: RawAxiosRequestConfig): AxiosPromise<Array<Institution>> {
      return localVarFp.getInstitutionsForCustomer(options).then((request) => request(axios, basePath));
    },
    /**
     * Get payment link
     * @param {string} paymentLinkId The payment link id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentLink(paymentLinkId: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentLinkResponse> {
      return localVarFp.getPaymentLink(paymentLinkId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get a payment method
     * @param {string} paymentMethodId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentMethod(paymentMethodId: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentMethodResponse> {
      return localVarFp.getPaymentMethod(paymentMethodId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get payment method in payment link flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentMethodPaymentLink(options?: RawAxiosRequestConfig): AxiosPromise<PaymentMethodFvLinkResponse> {
      return localVarFp.getPaymentMethodPaymentLink(options).then((request) => request(axios, basePath));
    },
    /**
     * Get payment (if exists) on the payment link for front-end
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentPaymentLink(options?: RawAxiosRequestConfig): AxiosPromise<PaymentFvLinkResponse> {
      return localVarFp.getPaymentPaymentLink(options).then((request) => request(axios, basePath));
    },
    /**
     * Get payout by payout_id
     * @param {string} payoutId payout id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPayoutById(payoutId: string, options?: RawAxiosRequestConfig): AxiosPromise<PayoutSnapshotResponse> {
      return localVarFp.getPayoutById(payoutId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get sender payment user in payment link flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSenderPaymentUser(options?: RawAxiosRequestConfig): AxiosPromise<GetPaymentUserResponse> {
      return localVarFp.getSenderPaymentUser(options).then((request) => request(axios, basePath));
    },
    /**
     * List available payment methods
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAvailablePaymentMethodsPaymentLink(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<AvailablePaymentMethodsFvLinkResponse> {
      return localVarFp.listAvailablePaymentMethodsPaymentLink(options).then((request) => request(axios, basePath));
    },
    /**
     * List mandates details
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListDetokenizedMandatesStatusesEnum>} [statuses] The mandate statuses to filter for, comma separated
     * @param {ListDetokenizedMandatesSenderTypeEnum} [senderType] The sender type of the mandate
     * @param {string} [userId] The user_id the mandate was setup for
     * @param {string} [institutionId] The institution the mandate was executed against
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listDetokenizedMandates(
      dateFrom?: string,
      dateTo?: string,
      statuses?: Array<ListDetokenizedMandatesStatusesEnum>,
      senderType?: ListDetokenizedMandatesSenderTypeEnum,
      userId?: string,
      institutionId?: string,
      offset?: number,
      limit?: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ListMandatesResponse> {
      return localVarFp
        .listDetokenizedMandates(dateFrom, dateTo, statuses, senderType, userId, institutionId, offset, limit, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * List Disputes
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListDisputesStatusesEnum>} [statuses] The dispute statuses to filter for, comma separated
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listDisputes(
      dateFrom?: string,
      dateTo?: string,
      statuses?: Array<ListDisputesStatusesEnum>,
      offset?: number,
      limit?: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ListDisputesResponse> {
      return localVarFp
        .listDisputes(dateFrom, dateTo, statuses, offset, limit, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * List mandates
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListMandatesStatusesEnum>} [statuses] The mandate statuses to filter for, comma separated
     * @param {ListMandatesSenderTypeEnum} [senderType] The sender type of the mandate
     * @param {string} [userId] The user_id the mandate was setup for
     * @param {string} [institutionId] The institution the mandate was executed against
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMandates(
      dateFrom?: string,
      dateTo?: string,
      statuses?: Array<ListMandatesStatusesEnum>,
      senderType?: ListMandatesSenderTypeEnum,
      userId?: string,
      institutionId?: string,
      offset?: number,
      limit?: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ListMandatesResponse> {
      return localVarFp
        .listMandates(dateFrom, dateTo, statuses, senderType, userId, institutionId, offset, limit, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * List Payment Methods for a User
     * @param {string} paymentUserId Payment User Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPaymentMethods(
      paymentUserId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ListPaymentMethodsResponse> {
      return localVarFp.listPaymentMethods(paymentUserId, options).then((request) => request(axios, basePath));
    },
    /**
     * List Payments
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListPaymentsStatusesEnum>} [statuses] The payment statuses to filter for, comma separated
     * @param {ListPaymentsSenderTypeEnum} [senderType] The sender type of the mandate
     * @param {string} [userId] The user_id the mandate was setup for
     * @param {string} [institutionId] The institution the mandate was executed against
     * @param {ListPaymentsPaymentTypeEnum} [paymentType] Deprecated - The type of payment
     * @param {Array<ListPaymentsPaymentTypesEnum>} [paymentTypes]
     * @param {string} [mandateId] The mandate the payment belongs to
     * @param {string} [currency] Deprecated - The currency the payment is made in
     * @param {Array<string>} [currencies]
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPayments(
      dateFrom?: string,
      dateTo?: string,
      statuses?: Array<ListPaymentsStatusesEnum>,
      senderType?: ListPaymentsSenderTypeEnum,
      userId?: string,
      institutionId?: string,
      paymentType?: ListPaymentsPaymentTypeEnum,
      paymentTypes?: Array<ListPaymentsPaymentTypesEnum>,
      mandateId?: string,
      currency?: string,
      currencies?: Array<string>,
      offset?: number,
      limit?: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ListPaymentsResponse> {
      return localVarFp
        .listPayments(
          dateFrom,
          dateTo,
          statuses,
          senderType,
          userId,
          institutionId,
          paymentType,
          paymentTypes,
          mandateId,
          currency,
          currencies,
          offset,
          limit,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * List payouts
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<ListPayoutsStatusesEnum>} [statuses] The payout statuses to filter for, comma separated
     * @param {Array<string>} [currencies]
     * @param {Array<ListPayoutsPayoutTypesEnum>} [payoutTypes]
     * @param {string} [mandateId]
     * @param {string} [senderAccountId]
     * @param {string} [recipientAccountId]
     * @param {string} [recipientUserId]
     * @param {string} [recipientExternalUserId]
     * @param {number} [offset] Default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPayouts(
      dateFrom?: string,
      dateTo?: string,
      statuses?: Array<ListPayoutsStatusesEnum>,
      currencies?: Array<string>,
      payoutTypes?: Array<ListPayoutsPayoutTypesEnum>,
      mandateId?: string,
      senderAccountId?: string,
      recipientAccountId?: string,
      recipientUserId?: string,
      recipientExternalUserId?: string,
      offset?: number,
      limit?: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ListPayoutsResponse> {
      return localVarFp
        .listPayouts(
          dateFrom,
          dateTo,
          statuses,
          currencies,
          payoutTypes,
          mandateId,
          senderAccountId,
          recipientAccountId,
          recipientUserId,
          recipientExternalUserId,
          offset,
          limit,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Refresh payment attempt from payment link front-end
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshPaymentAttempt(options?: RawAxiosRequestConfig): AxiosPromise<RefreshPaymentAttemptResponse> {
      return localVarFp.refreshPaymentAttempt(options).then((request) => request(axios, basePath));
    },
    /**
     * Select a payment method for payment link
     * @param {SelectPaymentMethodRequest} selectPaymentMethodRequest request body for selecting a payment method
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    selectPaymentMethodPaymentLink(
      selectPaymentMethodRequest: SelectPaymentMethodRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SelectPaymentMethodResponse> {
      return localVarFp
        .selectPaymentMethodPaymentLink(selectPaymentMethodRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Set autopay consent for payment user
     * @param {SetAutopayConsentRequest} setAutopayConsentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setAutopayConsent(
      setAutopayConsentRequest: SetAutopayConsentRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .setAutopayConsent(setAutopayConsentRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update a payment user
     * @param {string} paymentUserId
     * @param {UpdatePaymentUserRequest} updatePaymentUserRequest request body for updating payment user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePaymentUser(
      paymentUserId: string,
      updatePaymentUserRequest: UpdatePaymentUserRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<PaymentUser> {
      return localVarFp
        .updatePaymentUser(paymentUserId, updatePaymentUserRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * DefaultApi - interface
 * @export
 * @interface DefaultApi
 */
export interface DefaultApiInterface {
  /**
   * Cancel a payment link
   * @param {string} paymentLinkId The payment link id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  cancelPaymentLink(paymentLinkId: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentLinkResponse>;

  /**
   * Cancel Payout by payout_id
   * @param {string} payoutId payout id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  cancelPayout(payoutId: string, options?: RawAxiosRequestConfig): AxiosPromise<PayoutSnapshotResponse>;

  /**
   * Initiate change payment method from payment link front-end
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  changePaymentMethodPaymentLink(options?: RawAxiosRequestConfig): AxiosPromise<ChangePaymentMethodFvLinkResponse>;

  /**
   * Complete a KCP payment
   * @param {CompleteKcpPaymentRequest} completeKcpPaymentRequest Parameters from the KCP SDK callback to complete the payment
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  completeKcpPayment(
    completeKcpPaymentRequest: CompleteKcpPaymentRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<CompleteKcpPaymentResponse>;

  /**
   * Submit manual payment confirmation
   * @param {ManualPaymentConfirmationRequest} manualPaymentIdentifiers Request body containing information to identify manual payment
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  confirmManualPayment(
    manualPaymentIdentifiers: ManualPaymentConfirmationRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<ManualPaymentConfirmationResponse>;

  /**
   * Confirm a payment against a payment Link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  confirmPayment(options?: RawAxiosRequestConfig): AxiosPromise<ConfirmPaymentResponse>;

  /**
   * Create mandate for an existing sender account
   * @param {string} idempotencyKey A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
   * @param {CreateMandateWithSenderAccountRequest} createMandateRequest request body for creating mandate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  createMandateForExistingSender(
    idempotencyKey: string,
    createMandateRequest: CreateMandateWithSenderAccountRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<CreateMandateResponse>;

  /**
   * Create payment link
   * @param {CreatePaymentLinkRequest} createPaymentLinkRequest Parameters required to create a payment link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  createPaymentLink(
    createPaymentLinkRequest: CreatePaymentLinkRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<PaymentLinkResponse>;

  /**
   * Create a Payment Method for a user
   * @param {string} paymentUserId Payment User ID
   * @param {CreatePaymentMethodRequest} createPaymentMethodRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  createPaymentMethod(
    paymentUserId: string,
    createPaymentMethodRequest: CreatePaymentMethodRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<PaymentMethodResponse>;

  /**
   * Create a scheduled payout
   * @param {string} idempotencyKey A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
   * @param {CreateScheduledPayoutRequest} createScheduledPayoutRequest Request body containing information to create scheduled payout
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  createScheduledPayout(
    idempotencyKey: string,
    createScheduledPayoutRequest: CreateScheduledPayoutRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<PayoutSnapshotResponse>;

  /**
   * Demote payment attempt
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  demotePaymentAttempt(options?: RawAxiosRequestConfig): AxiosPromise<void>;

  /**
   * Download the balance statement for the ledger (CSV)
   * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
   * @param {string} [dateTo] ISO format (YYYY-MM-DD)
   * @param {Array<string>} [currencies] The currencies to filter for
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  downloadBalanceStatement(
    dateFrom?: string,
    dateTo?: string,
    currencies?: Array<string>,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<DownloadBalanceStatementResponse>;

  /**
   * Get the FPS QR code
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getFpsQrCode(options?: RawAxiosRequestConfig): AxiosPromise<FpsQrCodeResponse>;

  /**
   * Get a customer-specific list of institutions for Finverse Link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getInstitutionsForCustomer(options?: RawAxiosRequestConfig): AxiosPromise<Array<Institution>>;

  /**
   * Get payment link
   * @param {string} paymentLinkId The payment link id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getPaymentLink(paymentLinkId: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentLinkResponse>;

  /**
   * Get a payment method
   * @param {string} paymentMethodId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getPaymentMethod(paymentMethodId: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentMethodResponse>;

  /**
   * Get payment method in payment link flow
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getPaymentMethodPaymentLink(options?: RawAxiosRequestConfig): AxiosPromise<PaymentMethodFvLinkResponse>;

  /**
   * Get payment (if exists) on the payment link for front-end
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getPaymentPaymentLink(options?: RawAxiosRequestConfig): AxiosPromise<PaymentFvLinkResponse>;

  /**
   * Get payout by payout_id
   * @param {string} payoutId payout id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getPayoutById(payoutId: string, options?: RawAxiosRequestConfig): AxiosPromise<PayoutSnapshotResponse>;

  /**
   * Get sender payment user in payment link flow
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getSenderPaymentUser(options?: RawAxiosRequestConfig): AxiosPromise<GetPaymentUserResponse>;

  /**
   * List available payment methods
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  listAvailablePaymentMethodsPaymentLink(
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<AvailablePaymentMethodsFvLinkResponse>;

  /**
   * List mandates details
   * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
   * @param {string} [dateTo] ISO format (YYYY-MM-DD)
   * @param {Array<ListDetokenizedMandatesStatusesEnum>} [statuses] The mandate statuses to filter for, comma separated
   * @param {ListDetokenizedMandatesSenderTypeEnum} [senderType] The sender type of the mandate
   * @param {string} [userId] The user_id the mandate was setup for
   * @param {string} [institutionId] The institution the mandate was executed against
   * @param {number} [offset] default is 0
   * @param {number} [limit] default is 500, max is 1000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  listDetokenizedMandates(
    dateFrom?: string,
    dateTo?: string,
    statuses?: Array<ListDetokenizedMandatesStatusesEnum>,
    senderType?: ListDetokenizedMandatesSenderTypeEnum,
    userId?: string,
    institutionId?: string,
    offset?: number,
    limit?: number,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<ListMandatesResponse>;

  /**
   * List Disputes
   * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
   * @param {string} [dateTo] ISO format (YYYY-MM-DD)
   * @param {Array<ListDisputesStatusesEnum>} [statuses] The dispute statuses to filter for, comma separated
   * @param {number} [offset] default is 0
   * @param {number} [limit] default is 500, max is 1000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  listDisputes(
    dateFrom?: string,
    dateTo?: string,
    statuses?: Array<ListDisputesStatusesEnum>,
    offset?: number,
    limit?: number,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<ListDisputesResponse>;

  /**
   * List mandates
   * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
   * @param {string} [dateTo] ISO format (YYYY-MM-DD)
   * @param {Array<ListMandatesStatusesEnum>} [statuses] The mandate statuses to filter for, comma separated
   * @param {ListMandatesSenderTypeEnum} [senderType] The sender type of the mandate
   * @param {string} [userId] The user_id the mandate was setup for
   * @param {string} [institutionId] The institution the mandate was executed against
   * @param {number} [offset] default is 0
   * @param {number} [limit] default is 500, max is 1000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  listMandates(
    dateFrom?: string,
    dateTo?: string,
    statuses?: Array<ListMandatesStatusesEnum>,
    senderType?: ListMandatesSenderTypeEnum,
    userId?: string,
    institutionId?: string,
    offset?: number,
    limit?: number,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<ListMandatesResponse>;

  /**
   * List Payment Methods for a User
   * @param {string} paymentUserId Payment User Id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  listPaymentMethods(paymentUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<ListPaymentMethodsResponse>;

  /**
   * List Payments
   * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
   * @param {string} [dateTo] ISO format (YYYY-MM-DD)
   * @param {Array<ListPaymentsStatusesEnum>} [statuses] The payment statuses to filter for, comma separated
   * @param {ListPaymentsSenderTypeEnum} [senderType] The sender type of the mandate
   * @param {string} [userId] The user_id the mandate was setup for
   * @param {string} [institutionId] The institution the mandate was executed against
   * @param {ListPaymentsPaymentTypeEnum} [paymentType] Deprecated - The type of payment
   * @param {Array<ListPaymentsPaymentTypesEnum>} [paymentTypes]
   * @param {string} [mandateId] The mandate the payment belongs to
   * @param {string} [currency] Deprecated - The currency the payment is made in
   * @param {Array<string>} [currencies]
   * @param {number} [offset] default is 0
   * @param {number} [limit] default is 500, max is 1000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  listPayments(
    dateFrom?: string,
    dateTo?: string,
    statuses?: Array<ListPaymentsStatusesEnum>,
    senderType?: ListPaymentsSenderTypeEnum,
    userId?: string,
    institutionId?: string,
    paymentType?: ListPaymentsPaymentTypeEnum,
    paymentTypes?: Array<ListPaymentsPaymentTypesEnum>,
    mandateId?: string,
    currency?: string,
    currencies?: Array<string>,
    offset?: number,
    limit?: number,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<ListPaymentsResponse>;

  /**
   * List payouts
   * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
   * @param {string} [dateTo] ISO format (YYYY-MM-DD)
   * @param {Array<ListPayoutsStatusesEnum>} [statuses] The payout statuses to filter for, comma separated
   * @param {Array<string>} [currencies]
   * @param {Array<ListPayoutsPayoutTypesEnum>} [payoutTypes]
   * @param {string} [mandateId]
   * @param {string} [senderAccountId]
   * @param {string} [recipientAccountId]
   * @param {string} [recipientUserId]
   * @param {string} [recipientExternalUserId]
   * @param {number} [offset] Default is 0
   * @param {number} [limit] default is 500, max is 1000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  listPayouts(
    dateFrom?: string,
    dateTo?: string,
    statuses?: Array<ListPayoutsStatusesEnum>,
    currencies?: Array<string>,
    payoutTypes?: Array<ListPayoutsPayoutTypesEnum>,
    mandateId?: string,
    senderAccountId?: string,
    recipientAccountId?: string,
    recipientUserId?: string,
    recipientExternalUserId?: string,
    offset?: number,
    limit?: number,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<ListPayoutsResponse>;

  /**
   * Refresh payment attempt from payment link front-end
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  refreshPaymentAttempt(options?: RawAxiosRequestConfig): AxiosPromise<RefreshPaymentAttemptResponse>;

  /**
   * Select a payment method for payment link
   * @param {SelectPaymentMethodRequest} selectPaymentMethodRequest request body for selecting a payment method
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  selectPaymentMethodPaymentLink(
    selectPaymentMethodRequest: SelectPaymentMethodRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<SelectPaymentMethodResponse>;

  /**
   * Set autopay consent for payment user
   * @param {SetAutopayConsentRequest} setAutopayConsentRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  setAutopayConsent(
    setAutopayConsentRequest: SetAutopayConsentRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<void>;

  /**
   * Update a payment user
   * @param {string} paymentUserId
   * @param {UpdatePaymentUserRequest} updatePaymentUserRequest request body for updating payment user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  updatePaymentUser(
    paymentUserId: string,
    updatePaymentUserRequest: UpdatePaymentUserRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<PaymentUser>;
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI implements DefaultApiInterface {
  /**
   * Cancel a payment link
   * @param {string} paymentLinkId The payment link id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public cancelPaymentLink(paymentLinkId: string, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .cancelPaymentLink(paymentLinkId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Cancel Payout by payout_id
   * @param {string} payoutId payout id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public cancelPayout(payoutId: string, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .cancelPayout(payoutId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Initiate change payment method from payment link front-end
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public changePaymentMethodPaymentLink(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .changePaymentMethodPaymentLink(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Complete a KCP payment
   * @param {CompleteKcpPaymentRequest} completeKcpPaymentRequest Parameters from the KCP SDK callback to complete the payment
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public completeKcpPayment(completeKcpPaymentRequest: CompleteKcpPaymentRequest, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .completeKcpPayment(completeKcpPaymentRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Submit manual payment confirmation
   * @param {ManualPaymentConfirmationRequest} manualPaymentIdentifiers Request body containing information to identify manual payment
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public confirmManualPayment(
    manualPaymentIdentifiers: ManualPaymentConfirmationRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .confirmManualPayment(manualPaymentIdentifiers, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Confirm a payment against a payment Link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public confirmPayment(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .confirmPayment(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create mandate for an existing sender account
   * @param {string} idempotencyKey A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
   * @param {CreateMandateWithSenderAccountRequest} createMandateRequest request body for creating mandate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createMandateForExistingSender(
    idempotencyKey: string,
    createMandateRequest: CreateMandateWithSenderAccountRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .createMandateForExistingSender(idempotencyKey, createMandateRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create payment link
   * @param {CreatePaymentLinkRequest} createPaymentLinkRequest Parameters required to create a payment link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createPaymentLink(createPaymentLinkRequest: CreatePaymentLinkRequest, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .createPaymentLink(createPaymentLinkRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a Payment Method for a user
   * @param {string} paymentUserId Payment User ID
   * @param {CreatePaymentMethodRequest} createPaymentMethodRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createPaymentMethod(
    paymentUserId: string,
    createPaymentMethodRequest: CreatePaymentMethodRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .createPaymentMethod(paymentUserId, createPaymentMethodRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a scheduled payout
   * @param {string} idempotencyKey A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
   * @param {CreateScheduledPayoutRequest} createScheduledPayoutRequest Request body containing information to create scheduled payout
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createScheduledPayout(
    idempotencyKey: string,
    createScheduledPayoutRequest: CreateScheduledPayoutRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .createScheduledPayout(idempotencyKey, createScheduledPayoutRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Demote payment attempt
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public demotePaymentAttempt(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .demotePaymentAttempt(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Download the balance statement for the ledger (CSV)
   * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
   * @param {string} [dateTo] ISO format (YYYY-MM-DD)
   * @param {Array<string>} [currencies] The currencies to filter for
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public downloadBalanceStatement(
    dateFrom?: string,
    dateTo?: string,
    currencies?: Array<string>,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .downloadBalanceStatement(dateFrom, dateTo, currencies, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get the FPS QR code
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getFpsQrCode(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getFpsQrCode(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a customer-specific list of institutions for Finverse Link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getInstitutionsForCustomer(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getInstitutionsForCustomer(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get payment link
   * @param {string} paymentLinkId The payment link id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPaymentLink(paymentLinkId: string, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getPaymentLink(paymentLinkId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a payment method
   * @param {string} paymentMethodId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPaymentMethod(paymentMethodId: string, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getPaymentMethod(paymentMethodId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get payment method in payment link flow
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPaymentMethodPaymentLink(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getPaymentMethodPaymentLink(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get payment (if exists) on the payment link for front-end
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPaymentPaymentLink(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getPaymentPaymentLink(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get payout by payout_id
   * @param {string} payoutId payout id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPayoutById(payoutId: string, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getPayoutById(payoutId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get sender payment user in payment link flow
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getSenderPaymentUser(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getSenderPaymentUser(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List available payment methods
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public listAvailablePaymentMethodsPaymentLink(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .listAvailablePaymentMethodsPaymentLink(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List mandates details
   * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
   * @param {string} [dateTo] ISO format (YYYY-MM-DD)
   * @param {Array<ListDetokenizedMandatesStatusesEnum>} [statuses] The mandate statuses to filter for, comma separated
   * @param {ListDetokenizedMandatesSenderTypeEnum} [senderType] The sender type of the mandate
   * @param {string} [userId] The user_id the mandate was setup for
   * @param {string} [institutionId] The institution the mandate was executed against
   * @param {number} [offset] default is 0
   * @param {number} [limit] default is 500, max is 1000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public listDetokenizedMandates(
    dateFrom?: string,
    dateTo?: string,
    statuses?: Array<ListDetokenizedMandatesStatusesEnum>,
    senderType?: ListDetokenizedMandatesSenderTypeEnum,
    userId?: string,
    institutionId?: string,
    offset?: number,
    limit?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .listDetokenizedMandates(dateFrom, dateTo, statuses, senderType, userId, institutionId, offset, limit, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List Disputes
   * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
   * @param {string} [dateTo] ISO format (YYYY-MM-DD)
   * @param {Array<ListDisputesStatusesEnum>} [statuses] The dispute statuses to filter for, comma separated
   * @param {number} [offset] default is 0
   * @param {number} [limit] default is 500, max is 1000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public listDisputes(
    dateFrom?: string,
    dateTo?: string,
    statuses?: Array<ListDisputesStatusesEnum>,
    offset?: number,
    limit?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .listDisputes(dateFrom, dateTo, statuses, offset, limit, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List mandates
   * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
   * @param {string} [dateTo] ISO format (YYYY-MM-DD)
   * @param {Array<ListMandatesStatusesEnum>} [statuses] The mandate statuses to filter for, comma separated
   * @param {ListMandatesSenderTypeEnum} [senderType] The sender type of the mandate
   * @param {string} [userId] The user_id the mandate was setup for
   * @param {string} [institutionId] The institution the mandate was executed against
   * @param {number} [offset] default is 0
   * @param {number} [limit] default is 500, max is 1000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public listMandates(
    dateFrom?: string,
    dateTo?: string,
    statuses?: Array<ListMandatesStatusesEnum>,
    senderType?: ListMandatesSenderTypeEnum,
    userId?: string,
    institutionId?: string,
    offset?: number,
    limit?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .listMandates(dateFrom, dateTo, statuses, senderType, userId, institutionId, offset, limit, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List Payment Methods for a User
   * @param {string} paymentUserId Payment User Id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public listPaymentMethods(paymentUserId: string, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .listPaymentMethods(paymentUserId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List Payments
   * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
   * @param {string} [dateTo] ISO format (YYYY-MM-DD)
   * @param {Array<ListPaymentsStatusesEnum>} [statuses] The payment statuses to filter for, comma separated
   * @param {ListPaymentsSenderTypeEnum} [senderType] The sender type of the mandate
   * @param {string} [userId] The user_id the mandate was setup for
   * @param {string} [institutionId] The institution the mandate was executed against
   * @param {ListPaymentsPaymentTypeEnum} [paymentType] Deprecated - The type of payment
   * @param {Array<ListPaymentsPaymentTypesEnum>} [paymentTypes]
   * @param {string} [mandateId] The mandate the payment belongs to
   * @param {string} [currency] Deprecated - The currency the payment is made in
   * @param {Array<string>} [currencies]
   * @param {number} [offset] default is 0
   * @param {number} [limit] default is 500, max is 1000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public listPayments(
    dateFrom?: string,
    dateTo?: string,
    statuses?: Array<ListPaymentsStatusesEnum>,
    senderType?: ListPaymentsSenderTypeEnum,
    userId?: string,
    institutionId?: string,
    paymentType?: ListPaymentsPaymentTypeEnum,
    paymentTypes?: Array<ListPaymentsPaymentTypesEnum>,
    mandateId?: string,
    currency?: string,
    currencies?: Array<string>,
    offset?: number,
    limit?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .listPayments(
        dateFrom,
        dateTo,
        statuses,
        senderType,
        userId,
        institutionId,
        paymentType,
        paymentTypes,
        mandateId,
        currency,
        currencies,
        offset,
        limit,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List payouts
   * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
   * @param {string} [dateTo] ISO format (YYYY-MM-DD)
   * @param {Array<ListPayoutsStatusesEnum>} [statuses] The payout statuses to filter for, comma separated
   * @param {Array<string>} [currencies]
   * @param {Array<ListPayoutsPayoutTypesEnum>} [payoutTypes]
   * @param {string} [mandateId]
   * @param {string} [senderAccountId]
   * @param {string} [recipientAccountId]
   * @param {string} [recipientUserId]
   * @param {string} [recipientExternalUserId]
   * @param {number} [offset] Default is 0
   * @param {number} [limit] default is 500, max is 1000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public listPayouts(
    dateFrom?: string,
    dateTo?: string,
    statuses?: Array<ListPayoutsStatusesEnum>,
    currencies?: Array<string>,
    payoutTypes?: Array<ListPayoutsPayoutTypesEnum>,
    mandateId?: string,
    senderAccountId?: string,
    recipientAccountId?: string,
    recipientUserId?: string,
    recipientExternalUserId?: string,
    offset?: number,
    limit?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .listPayouts(
        dateFrom,
        dateTo,
        statuses,
        currencies,
        payoutTypes,
        mandateId,
        senderAccountId,
        recipientAccountId,
        recipientUserId,
        recipientExternalUserId,
        offset,
        limit,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Refresh payment attempt from payment link front-end
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public refreshPaymentAttempt(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .refreshPaymentAttempt(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Select a payment method for payment link
   * @param {SelectPaymentMethodRequest} selectPaymentMethodRequest request body for selecting a payment method
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public selectPaymentMethodPaymentLink(
    selectPaymentMethodRequest: SelectPaymentMethodRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .selectPaymentMethodPaymentLink(selectPaymentMethodRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Set autopay consent for payment user
   * @param {SetAutopayConsentRequest} setAutopayConsentRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public setAutopayConsent(setAutopayConsentRequest: SetAutopayConsentRequest, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .setAutopayConsent(setAutopayConsentRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update a payment user
   * @param {string} paymentUserId
   * @param {UpdatePaymentUserRequest} updatePaymentUserRequest request body for updating payment user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updatePaymentUser(
    paymentUserId: string,
    updatePaymentUserRequest: UpdatePaymentUserRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .updatePaymentUser(paymentUserId, updatePaymentUserRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const ListDetokenizedMandatesStatusesEnum = {
  AuthorizationRequired: 'AUTHORIZATION_REQUIRED',
  Authorizing: 'AUTHORIZING',
  Processing: 'PROCESSING',
  Submitted: 'SUBMITTED',
  Succeeded: 'SUCCEEDED',
  Failed: 'FAILED',
  Revoked: 'REVOKED',
  ReadyToSubmit: 'READY_TO_SUBMIT',
  Closed: 'CLOSED',
  Cancelled: 'CANCELLED',
} as const;
export type ListDetokenizedMandatesStatusesEnum =
  (typeof ListDetokenizedMandatesStatusesEnum)[keyof typeof ListDetokenizedMandatesStatusesEnum];
/**
 * @export
 */
export const ListDetokenizedMandatesSenderTypeEnum = {
  Individual: 'INDIVIDUAL',
  Business: 'BUSINESS',
} as const;
export type ListDetokenizedMandatesSenderTypeEnum =
  (typeof ListDetokenizedMandatesSenderTypeEnum)[keyof typeof ListDetokenizedMandatesSenderTypeEnum];
/**
 * @export
 */
export const ListDisputesStatusesEnum = {
  Unknown: 'UNKNOWN',
  Undefended: 'UNDEFENDED',
  ActionRequired: 'ACTION_REQUIRED',
  Processing: 'PROCESSING',
  Accepted: 'ACCEPTED',
  Lost: 'LOST',
  Won: 'WON',
} as const;
export type ListDisputesStatusesEnum = (typeof ListDisputesStatusesEnum)[keyof typeof ListDisputesStatusesEnum];
/**
 * @export
 */
export const ListMandatesStatusesEnum = {
  AuthorizationRequired: 'AUTHORIZATION_REQUIRED',
  Authorizing: 'AUTHORIZING',
  Processing: 'PROCESSING',
  Submitted: 'SUBMITTED',
  Succeeded: 'SUCCEEDED',
  Failed: 'FAILED',
  Revoked: 'REVOKED',
  ReadyToSubmit: 'READY_TO_SUBMIT',
  Closed: 'CLOSED',
  Cancelled: 'CANCELLED',
} as const;
export type ListMandatesStatusesEnum = (typeof ListMandatesStatusesEnum)[keyof typeof ListMandatesStatusesEnum];
/**
 * @export
 */
export const ListMandatesSenderTypeEnum = {
  Individual: 'INDIVIDUAL',
  Business: 'BUSINESS',
} as const;
export type ListMandatesSenderTypeEnum = (typeof ListMandatesSenderTypeEnum)[keyof typeof ListMandatesSenderTypeEnum];
/**
 * @export
 */
export const ListPaymentsStatusesEnum = {
  AuthorizationRequired: 'AUTHORIZATION_REQUIRED',
  Authorizing: 'AUTHORIZING',
  Processing: 'PROCESSING',
  Submitted: 'SUBMITTED',
  Executed: 'EXECUTED',
  Failed: 'FAILED',
  Revoked: 'REVOKED',
  Cancelled: 'CANCELLED',
  Created: 'CREATED',
} as const;
export type ListPaymentsStatusesEnum = (typeof ListPaymentsStatusesEnum)[keyof typeof ListPaymentsStatusesEnum];
/**
 * @export
 */
export const ListPaymentsSenderTypeEnum = {
  Individual: 'INDIVIDUAL',
  Business: 'BUSINESS',
} as const;
export type ListPaymentsSenderTypeEnum = (typeof ListPaymentsSenderTypeEnum)[keyof typeof ListPaymentsSenderTypeEnum];
/**
 * @export
 */
export const ListPaymentsPaymentTypeEnum = {
  Mandate: 'MANDATE',
  Single: 'SINGLE',
  Card: 'CARD',
  Manual: 'MANUAL',
} as const;
export type ListPaymentsPaymentTypeEnum =
  (typeof ListPaymentsPaymentTypeEnum)[keyof typeof ListPaymentsPaymentTypeEnum];
/**
 * @export
 */
export const ListPaymentsPaymentTypesEnum = {
  Mandate: 'MANDATE',
  Single: 'SINGLE',
  Card: 'CARD',
  Manual: 'MANUAL',
} as const;
export type ListPaymentsPaymentTypesEnum =
  (typeof ListPaymentsPaymentTypesEnum)[keyof typeof ListPaymentsPaymentTypesEnum];
/**
 * @export
 */
export const ListPayoutsStatusesEnum = {
  Executed: 'EXECUTED',
  Created: 'CREATED',
  Processing: 'PROCESSING',
  ProcessingFunds: 'PROCESSING_FUNDS',
  Cancelled: 'CANCELLED',
  Failed: 'FAILED',
  Funded: 'FUNDED',
  Submitted: 'SUBMITTED',
} as const;
export type ListPayoutsStatusesEnum = (typeof ListPayoutsStatusesEnum)[keyof typeof ListPayoutsStatusesEnum];
/**
 * @export
 */
export const ListPayoutsPayoutTypesEnum = {
  Manual: 'MANUAL',
  Scheduled: 'SCHEDULED',
  Settlement: 'SETTLEMENT',
} as const;
export type ListPayoutsPayoutTypesEnum = (typeof ListPayoutsPayoutTypesEnum)[keyof typeof ListPayoutsPayoutTypesEnum];

/**
 * LinkApi - axios parameter creator
 * @export
 */
export const LinkApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create a new link and submit credentials
     * @param {ApiLinkRequest} apiLinkRequest Request body for creating a new link and submitting credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLink: async (apiLinkRequest: ApiLinkRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'apiLinkRequest' is not null or undefined
      assertParamExists('createLink', 'apiLinkRequest', apiLinkRequest);
      const localVarPath = `/link`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(apiLinkRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates a new link
     * @param {LinkRequest} linkRequest Request body for starting a new Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLinkWoauth: async (linkRequest: LinkRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'linkRequest' is not null or undefined
      assertParamExists('createLinkWoauth', 'linkRequest', linkRequest);
      const localVarPath = `/link/woauth`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', ['link'], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(linkRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Post the user action value
     * @param {string} loginIdentityId The login identity id
     * @param {ActionRequest} actionRequest Request body for post link action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkAction: async (
      loginIdentityId: string,
      actionRequest: ActionRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'loginIdentityId' is not null or undefined
      assertParamExists('linkAction', 'loginIdentityId', loginIdentityId);
      // verify required parameter 'actionRequest' is not null or undefined
      assertParamExists('linkAction', 'actionRequest', actionRequest);
      const localVarPath = `/link/action/{loginIdentityId}`.replace(
        `{${'loginIdentityId'}}`,
        encodeURIComponent(String(loginIdentityId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(actionRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Check the status of a given loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkStatus: async (loginIdentityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'loginIdentityId' is not null or undefined
      assertParamExists('linkStatus', 'loginIdentityId', loginIdentityId);
      const localVarPath = `/link/status/{loginIdentityId}`.replace(
        `{${'loginIdentityId'}}`,
        encodeURIComponent(String(loginIdentityId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Check the status of a given login identity via FVLink
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkStatusNonSensitive: async (
      loginIdentityId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'loginIdentityId' is not null or undefined
      assertParamExists('linkStatusNonSensitive', 'loginIdentityId', loginIdentityId);
      const localVarPath = `/link/fvlink/status/{loginIdentityId}`.replace(
        `{${'loginIdentityId'}}`,
        encodeURIComponent(String(loginIdentityId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update an existing link
     * @param {RelinkRequest} relinkRequest Request body for updating Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    relink: async (relinkRequest: RelinkRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'relinkRequest' is not null or undefined
      assertParamExists('relink', 'relinkRequest', relinkRequest);
      const localVarPath = `/link/relink`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(relinkRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a new link using an existing LIID
     * @param {string} loginIdentityId The login identity id
     * @param {ApiRelinkRequest} apiRelinkRequest Request body for relinking and submitting credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    relinkV2: async (
      loginIdentityId: string,
      apiRelinkRequest: ApiRelinkRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'loginIdentityId' is not null or undefined
      assertParamExists('relinkV2', 'loginIdentityId', loginIdentityId);
      // verify required parameter 'apiRelinkRequest' is not null or undefined
      assertParamExists('relinkV2', 'apiRelinkRequest', apiRelinkRequest);
      const localVarPath = `/link/relink/{loginIdentityId}`.replace(
        `{${'loginIdentityId'}}`,
        encodeURIComponent(String(loginIdentityId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(apiRelinkRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Exchange authorization code for token
     * @param {TokenGrantTypeEnum} grantType
     * @param {string} code
     * @param {string} clientId
     * @param {string} redirectUri
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    token: async (
      grantType: TokenGrantTypeEnum,
      code: string,
      clientId: string,
      redirectUri: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'grantType' is not null or undefined
      assertParamExists('token', 'grantType', grantType);
      // verify required parameter 'code' is not null or undefined
      assertParamExists('token', 'code', code);
      // verify required parameter 'clientId' is not null or undefined
      assertParamExists('token', 'clientId', clientId);
      // verify required parameter 'redirectUri' is not null or undefined
      assertParamExists('token', 'redirectUri', redirectUri);
      const localVarPath = `/auth/token`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new URLSearchParams();

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      if (grantType !== undefined) {
        localVarFormParams.set('grant_type', grantType as any);
      }

      if (code !== undefined) {
        localVarFormParams.set('code', code as any);
      }

      if (clientId !== undefined) {
        localVarFormParams.set('client_id', clientId as any);
      }

      if (redirectUri !== undefined) {
        localVarFormParams.set('redirect_uri', redirectUri as any);
      }

      localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = localVarFormParams.toString();

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LinkApi - functional programming interface
 * @export
 */
export const LinkApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = LinkApiAxiosParamCreator(configuration);
  return {
    /**
     * Create a new link and submit credentials
     * @param {ApiLinkRequest} apiLinkRequest Request body for creating a new link and submitting credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createLink(
      apiLinkRequest: ApiLinkRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLoginIdentityByIdResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createLink(apiLinkRequest, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['LinkApi.createLink']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Creates a new link
     * @param {LinkRequest} linkRequest Request body for starting a new Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createLinkWoauth(
      linkRequest: LinkRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createLinkWoauth(linkRequest, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['LinkApi.createLinkWoauth']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Post the user action value
     * @param {string} loginIdentityId The login identity id
     * @param {ActionRequest} actionRequest Request body for post link action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async linkAction(
      loginIdentityId: string,
      actionRequest: ActionRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLoginIdentityByIdResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.linkAction(loginIdentityId, actionRequest, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['LinkApi.linkAction']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Check the status of a given loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async linkStatus(
      loginIdentityId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkStatusResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.linkStatus(loginIdentityId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['LinkApi.linkStatus']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Check the status of a given login identity via FVLink
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async linkStatusNonSensitive(
      loginIdentityId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonSensitiveLinkStatusResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.linkStatusNonSensitive(loginIdentityId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['LinkApi.linkStatusNonSensitive']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Update an existing link
     * @param {RelinkRequest} relinkRequest Request body for updating Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async relink(
      relinkRequest: RelinkRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.relink(relinkRequest, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap['LinkApi.relink']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Create a new link using an existing LIID
     * @param {string} loginIdentityId The login identity id
     * @param {ApiRelinkRequest} apiRelinkRequest Request body for relinking and submitting credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async relinkV2(
      loginIdentityId: string,
      apiRelinkRequest: ApiRelinkRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLoginIdentityByIdResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.relinkV2(loginIdentityId, apiRelinkRequest, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['LinkApi.relinkV2']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Exchange authorization code for token
     * @param {TokenGrantTypeEnum} grantType
     * @param {string} code
     * @param {string} clientId
     * @param {string} redirectUri
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async token(
      grantType: TokenGrantTypeEnum,
      code: string,
      clientId: string,
      redirectUri: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessTokenResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.token(grantType, code, clientId, redirectUri, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap['LinkApi.token']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * LinkApi - factory interface
 * @export
 */
export const LinkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = LinkApiFp(configuration);
  return {
    /**
     * Create a new link and submit credentials
     * @param {ApiLinkRequest} apiLinkRequest Request body for creating a new link and submitting credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLink(
      apiLinkRequest: ApiLinkRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GetLoginIdentityByIdResponse> {
      return localVarFp.createLink(apiLinkRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Creates a new link
     * @param {LinkRequest} linkRequest Request body for starting a new Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLinkWoauth(linkRequest: LinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<LinkResponse> {
      return localVarFp.createLinkWoauth(linkRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Post the user action value
     * @param {string} loginIdentityId The login identity id
     * @param {ActionRequest} actionRequest Request body for post link action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkAction(
      loginIdentityId: string,
      actionRequest: ActionRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GetLoginIdentityByIdResponse> {
      return localVarFp.linkAction(loginIdentityId, actionRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Check the status of a given loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkStatus(loginIdentityId: string, options?: RawAxiosRequestConfig): AxiosPromise<LinkStatusResponse> {
      return localVarFp.linkStatus(loginIdentityId, options).then((request) => request(axios, basePath));
    },
    /**
     * Check the status of a given login identity via FVLink
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkStatusNonSensitive(
      loginIdentityId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<NonSensitiveLinkStatusResponse> {
      return localVarFp.linkStatusNonSensitive(loginIdentityId, options).then((request) => request(axios, basePath));
    },
    /**
     * Update an existing link
     * @param {RelinkRequest} relinkRequest Request body for updating Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    relink(relinkRequest: RelinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<LinkResponse> {
      return localVarFp.relink(relinkRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Create a new link using an existing LIID
     * @param {string} loginIdentityId The login identity id
     * @param {ApiRelinkRequest} apiRelinkRequest Request body for relinking and submitting credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    relinkV2(
      loginIdentityId: string,
      apiRelinkRequest: ApiRelinkRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GetLoginIdentityByIdResponse> {
      return localVarFp
        .relinkV2(loginIdentityId, apiRelinkRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Exchange authorization code for token
     * @param {TokenGrantTypeEnum} grantType
     * @param {string} code
     * @param {string} clientId
     * @param {string} redirectUri
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    token(
      grantType: TokenGrantTypeEnum,
      code: string,
      clientId: string,
      redirectUri: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<AccessTokenResponse> {
      return localVarFp
        .token(grantType, code, clientId, redirectUri, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * LinkApi - interface
 * @export
 * @interface LinkApi
 */
export interface LinkApiInterface {
  /**
   * Create a new link and submit credentials
   * @param {ApiLinkRequest} apiLinkRequest Request body for creating a new link and submitting credentials
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApiInterface
   */
  createLink(
    apiLinkRequest: ApiLinkRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<GetLoginIdentityByIdResponse>;

  /**
   * Creates a new link
   * @param {LinkRequest} linkRequest Request body for starting a new Link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApiInterface
   */
  createLinkWoauth(linkRequest: LinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<LinkResponse>;

  /**
   * Post the user action value
   * @param {string} loginIdentityId The login identity id
   * @param {ActionRequest} actionRequest Request body for post link action
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApiInterface
   */
  linkAction(
    loginIdentityId: string,
    actionRequest: ActionRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<GetLoginIdentityByIdResponse>;

  /**
   * Check the status of a given loginIdentity
   * @param {string} loginIdentityId The login identity id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApiInterface
   */
  linkStatus(loginIdentityId: string, options?: RawAxiosRequestConfig): AxiosPromise<LinkStatusResponse>;

  /**
   * Check the status of a given login identity via FVLink
   * @param {string} loginIdentityId The login identity id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApiInterface
   */
  linkStatusNonSensitive(
    loginIdentityId: string,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<NonSensitiveLinkStatusResponse>;

  /**
   * Update an existing link
   * @param {RelinkRequest} relinkRequest Request body for updating Link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApiInterface
   */
  relink(relinkRequest: RelinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<LinkResponse>;

  /**
   * Create a new link using an existing LIID
   * @param {string} loginIdentityId The login identity id
   * @param {ApiRelinkRequest} apiRelinkRequest Request body for relinking and submitting credentials
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApiInterface
   */
  relinkV2(
    loginIdentityId: string,
    apiRelinkRequest: ApiRelinkRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<GetLoginIdentityByIdResponse>;

  /**
   * Exchange authorization code for token
   * @param {TokenGrantTypeEnum} grantType
   * @param {string} code
   * @param {string} clientId
   * @param {string} redirectUri
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApiInterface
   */
  token(
    grantType: TokenGrantTypeEnum,
    code: string,
    clientId: string,
    redirectUri: string,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<AccessTokenResponse>;
}

/**
 * LinkApi - object-oriented interface
 * @export
 * @class LinkApi
 * @extends {BaseAPI}
 */
export class LinkApi extends BaseAPI implements LinkApiInterface {
  /**
   * Create a new link and submit credentials
   * @param {ApiLinkRequest} apiLinkRequest Request body for creating a new link and submitting credentials
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApi
   */
  public createLink(apiLinkRequest: ApiLinkRequest, options?: RawAxiosRequestConfig) {
    return LinkApiFp(this.configuration)
      .createLink(apiLinkRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates a new link
   * @param {LinkRequest} linkRequest Request body for starting a new Link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApi
   */
  public createLinkWoauth(linkRequest: LinkRequest, options?: RawAxiosRequestConfig) {
    return LinkApiFp(this.configuration)
      .createLinkWoauth(linkRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Post the user action value
   * @param {string} loginIdentityId The login identity id
   * @param {ActionRequest} actionRequest Request body for post link action
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApi
   */
  public linkAction(loginIdentityId: string, actionRequest: ActionRequest, options?: RawAxiosRequestConfig) {
    return LinkApiFp(this.configuration)
      .linkAction(loginIdentityId, actionRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Check the status of a given loginIdentity
   * @param {string} loginIdentityId The login identity id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApi
   */
  public linkStatus(loginIdentityId: string, options?: RawAxiosRequestConfig) {
    return LinkApiFp(this.configuration)
      .linkStatus(loginIdentityId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Check the status of a given login identity via FVLink
   * @param {string} loginIdentityId The login identity id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApi
   */
  public linkStatusNonSensitive(loginIdentityId: string, options?: RawAxiosRequestConfig) {
    return LinkApiFp(this.configuration)
      .linkStatusNonSensitive(loginIdentityId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update an existing link
   * @param {RelinkRequest} relinkRequest Request body for updating Link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApi
   */
  public relink(relinkRequest: RelinkRequest, options?: RawAxiosRequestConfig) {
    return LinkApiFp(this.configuration)
      .relink(relinkRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a new link using an existing LIID
   * @param {string} loginIdentityId The login identity id
   * @param {ApiRelinkRequest} apiRelinkRequest Request body for relinking and submitting credentials
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApi
   */
  public relinkV2(loginIdentityId: string, apiRelinkRequest: ApiRelinkRequest, options?: RawAxiosRequestConfig) {
    return LinkApiFp(this.configuration)
      .relinkV2(loginIdentityId, apiRelinkRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Exchange authorization code for token
   * @param {TokenGrantTypeEnum} grantType
   * @param {string} code
   * @param {string} clientId
   * @param {string} redirectUri
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApi
   */
  public token(
    grantType: TokenGrantTypeEnum,
    code: string,
    clientId: string,
    redirectUri: string,
    options?: RawAxiosRequestConfig,
  ) {
    return LinkApiFp(this.configuration)
      .token(grantType, code, clientId, redirectUri, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const TokenGrantTypeEnum = {
  AuthorizationCode: 'authorization_code',
} as const;
export type TokenGrantTypeEnum = (typeof TokenGrantTypeEnum)[keyof typeof TokenGrantTypeEnum];

/**
 * LoginIdentityApi - axios parameter creator
 * @export
 */
export const LoginIdentityApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Delete a specific loginIdentity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLoginIdentity: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/login_identity`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * generate a link token that can be used to create link
     * @param {LinkTokenRequest} linkTokenRequest token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateLinkToken: async (
      linkTokenRequest: LinkTokenRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'linkTokenRequest' is not null or undefined
      assertParamExists('generateLinkToken', 'linkTokenRequest', linkTokenRequest);
      const localVarPath = `/link/token`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(linkTokenRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a specific account\'s information
     * @param {string} accountId The account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccount: async (accountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('getAccount', 'accountId', accountId);
      const localVarPath = `/accounts/{accountId}`.replace(`{${'accountId'}}`, encodeURIComponent(String(accountId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', ['account'], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the account number for a specific account
     * @param {string} accountId The account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccountNumber: async (accountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('getAccountNumber', 'accountId', accountId);
      const localVarPath = `/account_numbers/{accountId}`.replace(
        `{${'accountId'}}`,
        encodeURIComponent(String(accountId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the balance history for a specific account
     * @param {string} accountId The account id
     * @param {GetBalanceHistorySourceEnum} [source] The source will determine what type of balance history will be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBalanceHistory: async (
      accountId: string,
      source?: GetBalanceHistorySourceEnum,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('getBalanceHistory', 'accountId', accountId);
      const localVarPath = `/balance_history/{accountId}`.replace(
        `{${'accountId'}}`,
        encodeURIComponent(String(accountId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      if (source !== undefined) {
        localVarQueryParameter['source'] = source;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Download composite statement
     * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCompositeStatement: async (redirect?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/composite_statement`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      if (redirect !== undefined) {
        localVarQueryParameter['redirect'] = redirect;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * \\[BETA] Get a list of identity data for a given login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentity: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/identity`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get income figures for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIncomeEstimateByLoginIdentityId: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/income`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a specific loginIdentity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoginIdentity: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/login_identity`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Download statement
     * @param {string} statementId The statement id
     * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatement: async (
      statementId: string,
      redirect?: boolean,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'statementId' is not null or undefined
      assertParamExists('getStatement', 'statementId', statementId);
      const localVarPath = `/statements/{statementId}`.replace(
        `{${'statementId'}}`,
        encodeURIComponent(String(statementId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      if (redirect !== undefined) {
        localVarQueryParameter['redirect'] = redirect;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get list of available statements
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatements: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/statements`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of accounts for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAccounts: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/accounts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', ['account'], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of card details for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCardDetails: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/card_details`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of transactions for a particular account. The transactions are returned in sorted order, with the most recent one appearing first.
     * @param {string} accountId The account id (ULID, example - 01EP4A1MZDHKETZFRPF0K62S6S)
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {boolean} [enrichments] when true, response will be enriched transactions; otherwise it will be raw transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTransactionsByAccountId: async (
      accountId: string,
      offset?: number,
      limit?: number,
      enrichments?: boolean,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('listTransactionsByAccountId', 'accountId', accountId);
      const localVarPath = `/transactions/{accountId}`.replace(
        `{${'accountId'}}`,
        encodeURIComponent(String(accountId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', ['transaction'], configuration);

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (enrichments !== undefined) {
        localVarQueryParameter['enrichments'] = enrichments;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of transactions for a login identity. The transactions are returned in sorted order, with the most recent one appearing first.
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {boolean} [enrichments] when true, response will be enriched transactions; otherwise it will be raw transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTransactionsByLoginIdentityId: async (
      offset?: number,
      limit?: number,
      enrichments?: boolean,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/transactions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', ['transaction'], configuration);

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (enrichments !== undefined) {
        localVarQueryParameter['enrichments'] = enrichments;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a refresh job for a login identity
     * @param {RefreshLoginIdentityRequest} [refreshLoginIdentityReq]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshLoginIdentity: async (
      refreshLoginIdentityReq?: RefreshLoginIdentityRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/login_identity/refresh`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        refreshLoginIdentityReq,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LoginIdentityApi - functional programming interface
 * @export
 */
export const LoginIdentityApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = LoginIdentityApiAxiosParamCreator(configuration);
  return {
    /**
     * Delete a specific loginIdentity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteLoginIdentity(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteLoginIdentityResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLoginIdentity(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['LoginIdentityApi.deleteLoginIdentity']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * generate a link token that can be used to create link
     * @param {LinkTokenRequest} linkTokenRequest token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async generateLinkToken(
      linkTokenRequest: LinkTokenRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkTokenResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.generateLinkToken(linkTokenRequest, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['LoginIdentityApi.generateLinkToken']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get a specific account\'s information
     * @param {string} accountId The account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAccount(
      accountId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAccountResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(accountId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['LoginIdentityApi.getAccount']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get the account number for a specific account
     * @param {string} accountId The account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAccountNumber(
      accountId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAccountNumberResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountNumber(accountId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['LoginIdentityApi.getAccountNumber']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get the balance history for a specific account
     * @param {string} accountId The account id
     * @param {GetBalanceHistorySourceEnum} [source] The source will determine what type of balance history will be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBalanceHistory(
      accountId: string,
      source?: GetBalanceHistorySourceEnum,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBalanceHistoryResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBalanceHistory(accountId, source, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['LoginIdentityApi.getBalanceHistory']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Download composite statement
     * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCompositeStatement(
      redirect?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompositeStatementLink>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCompositeStatement(redirect, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['LoginIdentityApi.getCompositeStatement']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * \\[BETA] Get a list of identity data for a given login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getIdentity(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetIdentityResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentity(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['LoginIdentityApi.getIdentity']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get income figures for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getIncomeEstimateByLoginIdentityId(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IncomeResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getIncomeEstimateByLoginIdentityId(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['LoginIdentityApi.getIncomeEstimateByLoginIdentityId']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get a specific loginIdentity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLoginIdentity(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLoginIdentityByIdResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLoginIdentity(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['LoginIdentityApi.getLoginIdentity']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Download statement
     * @param {string} statementId The statement id
     * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStatement(
      statementId: string,
      redirect?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStatementLinkResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStatement(statementId, redirect, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['LoginIdentityApi.getStatement']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get list of available statements
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStatements(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStatementsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStatements(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['LoginIdentityApi.getStatements']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get a list of accounts for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listAccounts(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAccountsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listAccounts(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['LoginIdentityApi.listAccounts']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get a list of card details for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listCardDetails(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCardsDetailsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listCardDetails(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['LoginIdentityApi.listCardDetails']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get a list of transactions for a particular account. The transactions are returned in sorted order, with the most recent one appearing first.
     * @param {string} accountId The account id (ULID, example - 01EP4A1MZDHKETZFRPF0K62S6S)
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {boolean} [enrichments] when true, response will be enriched transactions; otherwise it will be raw transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listTransactionsByAccountId(
      accountId: string,
      offset?: number,
      limit?: number,
      enrichments?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListTransactionsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listTransactionsByAccountId(
        accountId,
        offset,
        limit,
        enrichments,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['LoginIdentityApi.listTransactionsByAccountId']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get a list of transactions for a login identity. The transactions are returned in sorted order, with the most recent one appearing first.
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {boolean} [enrichments] when true, response will be enriched transactions; otherwise it will be raw transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listTransactionsByLoginIdentityId(
      offset?: number,
      limit?: number,
      enrichments?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListTransactionsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listTransactionsByLoginIdentityId(
        offset,
        limit,
        enrichments,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['LoginIdentityApi.listTransactionsByLoginIdentityId']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Create a refresh job for a login identity
     * @param {RefreshLoginIdentityRequest} [refreshLoginIdentityReq]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async refreshLoginIdentity(
      refreshLoginIdentityReq?: RefreshLoginIdentityRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshTokenResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.refreshLoginIdentity(refreshLoginIdentityReq, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['LoginIdentityApi.refreshLoginIdentity']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * LoginIdentityApi - factory interface
 * @export
 */
export const LoginIdentityApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = LoginIdentityApiFp(configuration);
  return {
    /**
     * Delete a specific loginIdentity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLoginIdentity(options?: RawAxiosRequestConfig): AxiosPromise<DeleteLoginIdentityResponse> {
      return localVarFp.deleteLoginIdentity(options).then((request) => request(axios, basePath));
    },
    /**
     * generate a link token that can be used to create link
     * @param {LinkTokenRequest} linkTokenRequest token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateLinkToken(
      linkTokenRequest: LinkTokenRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<LinkTokenResponse> {
      return localVarFp.generateLinkToken(linkTokenRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Get a specific account\'s information
     * @param {string} accountId The account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccount(accountId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetAccountResponse> {
      return localVarFp.getAccount(accountId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get the account number for a specific account
     * @param {string} accountId The account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccountNumber(accountId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetAccountNumberResponse> {
      return localVarFp.getAccountNumber(accountId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get the balance history for a specific account
     * @param {string} accountId The account id
     * @param {GetBalanceHistorySourceEnum} [source] The source will determine what type of balance history will be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBalanceHistory(
      accountId: string,
      source?: GetBalanceHistorySourceEnum,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GetBalanceHistoryResponse> {
      return localVarFp.getBalanceHistory(accountId, source, options).then((request) => request(axios, basePath));
    },
    /**
     * Download composite statement
     * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCompositeStatement(redirect?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<CompositeStatementLink> {
      return localVarFp.getCompositeStatement(redirect, options).then((request) => request(axios, basePath));
    },
    /**
     * \\[BETA] Get a list of identity data for a given login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentity(options?: RawAxiosRequestConfig): AxiosPromise<GetIdentityResponse> {
      return localVarFp.getIdentity(options).then((request) => request(axios, basePath));
    },
    /**
     * Get income figures for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIncomeEstimateByLoginIdentityId(options?: RawAxiosRequestConfig): AxiosPromise<IncomeResponse> {
      return localVarFp.getIncomeEstimateByLoginIdentityId(options).then((request) => request(axios, basePath));
    },
    /**
     * Get a specific loginIdentity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoginIdentity(options?: RawAxiosRequestConfig): AxiosPromise<GetLoginIdentityByIdResponse> {
      return localVarFp.getLoginIdentity(options).then((request) => request(axios, basePath));
    },
    /**
     * Download statement
     * @param {string} statementId The statement id
     * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatement(
      statementId: string,
      redirect?: boolean,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GetStatementLinkResponse> {
      return localVarFp.getStatement(statementId, redirect, options).then((request) => request(axios, basePath));
    },
    /**
     * Get list of available statements
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatements(options?: RawAxiosRequestConfig): AxiosPromise<GetStatementsResponse> {
      return localVarFp.getStatements(options).then((request) => request(axios, basePath));
    },
    /**
     * Get a list of accounts for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAccounts(options?: RawAxiosRequestConfig): AxiosPromise<ListAccountsResponse> {
      return localVarFp.listAccounts(options).then((request) => request(axios, basePath));
    },
    /**
     * Get a list of card details for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCardDetails(options?: RawAxiosRequestConfig): AxiosPromise<ListCardsDetailsResponse> {
      return localVarFp.listCardDetails(options).then((request) => request(axios, basePath));
    },
    /**
     * Get a list of transactions for a particular account. The transactions are returned in sorted order, with the most recent one appearing first.
     * @param {string} accountId The account id (ULID, example - 01EP4A1MZDHKETZFRPF0K62S6S)
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {boolean} [enrichments] when true, response will be enriched transactions; otherwise it will be raw transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTransactionsByAccountId(
      accountId: string,
      offset?: number,
      limit?: number,
      enrichments?: boolean,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ListTransactionsResponse> {
      return localVarFp
        .listTransactionsByAccountId(accountId, offset, limit, enrichments, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a list of transactions for a login identity. The transactions are returned in sorted order, with the most recent one appearing first.
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {boolean} [enrichments] when true, response will be enriched transactions; otherwise it will be raw transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTransactionsByLoginIdentityId(
      offset?: number,
      limit?: number,
      enrichments?: boolean,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ListTransactionsResponse> {
      return localVarFp
        .listTransactionsByLoginIdentityId(offset, limit, enrichments, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a refresh job for a login identity
     * @param {RefreshLoginIdentityRequest} [refreshLoginIdentityReq]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshLoginIdentity(
      refreshLoginIdentityReq?: RefreshLoginIdentityRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<RefreshTokenResponse> {
      return localVarFp
        .refreshLoginIdentity(refreshLoginIdentityReq, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * LoginIdentityApi - interface
 * @export
 * @interface LoginIdentityApi
 */
export interface LoginIdentityApiInterface {
  /**
   * Delete a specific loginIdentity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  deleteLoginIdentity(options?: RawAxiosRequestConfig): AxiosPromise<DeleteLoginIdentityResponse>;

  /**
   * generate a link token that can be used to create link
   * @param {LinkTokenRequest} linkTokenRequest token request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  generateLinkToken(
    linkTokenRequest: LinkTokenRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<LinkTokenResponse>;

  /**
   * Get a specific account\'s information
   * @param {string} accountId The account id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  getAccount(accountId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetAccountResponse>;

  /**
   * Get the account number for a specific account
   * @param {string} accountId The account id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  getAccountNumber(accountId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetAccountNumberResponse>;

  /**
   * Get the balance history for a specific account
   * @param {string} accountId The account id
   * @param {GetBalanceHistorySourceEnum} [source] The source will determine what type of balance history will be returned
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  getBalanceHistory(
    accountId: string,
    source?: GetBalanceHistorySourceEnum,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<GetBalanceHistoryResponse>;

  /**
   * Download composite statement
   * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  getCompositeStatement(redirect?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<CompositeStatementLink>;

  /**
   * \\[BETA] Get a list of identity data for a given login identity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  getIdentity(options?: RawAxiosRequestConfig): AxiosPromise<GetIdentityResponse>;

  /**
   * Get income figures for a login identity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  getIncomeEstimateByLoginIdentityId(options?: RawAxiosRequestConfig): AxiosPromise<IncomeResponse>;

  /**
   * Get a specific loginIdentity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  getLoginIdentity(options?: RawAxiosRequestConfig): AxiosPromise<GetLoginIdentityByIdResponse>;

  /**
   * Download statement
   * @param {string} statementId The statement id
   * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  getStatement(
    statementId: string,
    redirect?: boolean,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<GetStatementLinkResponse>;

  /**
   * Get list of available statements
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  getStatements(options?: RawAxiosRequestConfig): AxiosPromise<GetStatementsResponse>;

  /**
   * Get a list of accounts for a login identity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  listAccounts(options?: RawAxiosRequestConfig): AxiosPromise<ListAccountsResponse>;

  /**
   * Get a list of card details for a login identity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  listCardDetails(options?: RawAxiosRequestConfig): AxiosPromise<ListCardsDetailsResponse>;

  /**
   * Get a list of transactions for a particular account. The transactions are returned in sorted order, with the most recent one appearing first.
   * @param {string} accountId The account id (ULID, example - 01EP4A1MZDHKETZFRPF0K62S6S)
   * @param {number} [offset] default is 0
   * @param {number} [limit] default is 500, max is 1000
   * @param {boolean} [enrichments] when true, response will be enriched transactions; otherwise it will be raw transactions
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  listTransactionsByAccountId(
    accountId: string,
    offset?: number,
    limit?: number,
    enrichments?: boolean,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<ListTransactionsResponse>;

  /**
   * Get a list of transactions for a login identity. The transactions are returned in sorted order, with the most recent one appearing first.
   * @param {number} [offset] default is 0
   * @param {number} [limit] default is 500, max is 1000
   * @param {boolean} [enrichments] when true, response will be enriched transactions; otherwise it will be raw transactions
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  listTransactionsByLoginIdentityId(
    offset?: number,
    limit?: number,
    enrichments?: boolean,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<ListTransactionsResponse>;

  /**
   * Create a refresh job for a login identity
   * @param {RefreshLoginIdentityRequest} [refreshLoginIdentityReq]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  refreshLoginIdentity(
    refreshLoginIdentityReq?: RefreshLoginIdentityRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<RefreshTokenResponse>;
}

/**
 * LoginIdentityApi - object-oriented interface
 * @export
 * @class LoginIdentityApi
 * @extends {BaseAPI}
 */
export class LoginIdentityApi extends BaseAPI implements LoginIdentityApiInterface {
  /**
   * Delete a specific loginIdentity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public deleteLoginIdentity(options?: RawAxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .deleteLoginIdentity(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * generate a link token that can be used to create link
   * @param {LinkTokenRequest} linkTokenRequest token request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public generateLinkToken(linkTokenRequest: LinkTokenRequest, options?: RawAxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .generateLinkToken(linkTokenRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a specific account\'s information
   * @param {string} accountId The account id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public getAccount(accountId: string, options?: RawAxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .getAccount(accountId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get the account number for a specific account
   * @param {string} accountId The account id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public getAccountNumber(accountId: string, options?: RawAxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .getAccountNumber(accountId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get the balance history for a specific account
   * @param {string} accountId The account id
   * @param {GetBalanceHistorySourceEnum} [source] The source will determine what type of balance history will be returned
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public getBalanceHistory(accountId: string, source?: GetBalanceHistorySourceEnum, options?: RawAxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .getBalanceHistory(accountId, source, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Download composite statement
   * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public getCompositeStatement(redirect?: boolean, options?: RawAxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .getCompositeStatement(redirect, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * \\[BETA] Get a list of identity data for a given login identity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public getIdentity(options?: RawAxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .getIdentity(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get income figures for a login identity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public getIncomeEstimateByLoginIdentityId(options?: RawAxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .getIncomeEstimateByLoginIdentityId(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a specific loginIdentity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public getLoginIdentity(options?: RawAxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .getLoginIdentity(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Download statement
   * @param {string} statementId The statement id
   * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public getStatement(statementId: string, redirect?: boolean, options?: RawAxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .getStatement(statementId, redirect, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get list of available statements
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public getStatements(options?: RawAxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .getStatements(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of accounts for a login identity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public listAccounts(options?: RawAxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .listAccounts(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of card details for a login identity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public listCardDetails(options?: RawAxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .listCardDetails(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of transactions for a particular account. The transactions are returned in sorted order, with the most recent one appearing first.
   * @param {string} accountId The account id (ULID, example - 01EP4A1MZDHKETZFRPF0K62S6S)
   * @param {number} [offset] default is 0
   * @param {number} [limit] default is 500, max is 1000
   * @param {boolean} [enrichments] when true, response will be enriched transactions; otherwise it will be raw transactions
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public listTransactionsByAccountId(
    accountId: string,
    offset?: number,
    limit?: number,
    enrichments?: boolean,
    options?: RawAxiosRequestConfig,
  ) {
    return LoginIdentityApiFp(this.configuration)
      .listTransactionsByAccountId(accountId, offset, limit, enrichments, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of transactions for a login identity. The transactions are returned in sorted order, with the most recent one appearing first.
   * @param {number} [offset] default is 0
   * @param {number} [limit] default is 500, max is 1000
   * @param {boolean} [enrichments] when true, response will be enriched transactions; otherwise it will be raw transactions
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public listTransactionsByLoginIdentityId(
    offset?: number,
    limit?: number,
    enrichments?: boolean,
    options?: RawAxiosRequestConfig,
  ) {
    return LoginIdentityApiFp(this.configuration)
      .listTransactionsByLoginIdentityId(offset, limit, enrichments, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a refresh job for a login identity
   * @param {RefreshLoginIdentityRequest} [refreshLoginIdentityReq]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public refreshLoginIdentity(refreshLoginIdentityReq?: RefreshLoginIdentityRequest, options?: RawAxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .refreshLoginIdentity(refreshLoginIdentityReq, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const GetBalanceHistorySourceEnum = {
  Institution: 'INSTITUTION',
  Computed: 'COMPUTED',
} as const;
export type GetBalanceHistorySourceEnum =
  (typeof GetBalanceHistorySourceEnum)[keyof typeof GetBalanceHistorySourceEnum];

/**
 * PublicApi - axios parameter creator
 * @export
 */
export const PublicApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Callback url to get the oauth authorization token
     * @param {string} state The state of the client when oauth was initialized
     * @param {string} [code] The authorization code generated by the Oauth provider
     * @param {string} [error] error
     * @param {string} [errorDescription] error description
     * @param {string} [errorDetails] error details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authCallback: async (
      state: string,
      code?: string,
      error?: string,
      errorDescription?: string,
      errorDetails?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'state' is not null or undefined
      assertParamExists('authCallback', 'state', state);
      const localVarPath = `/auth/callback`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (state !== undefined) {
        localVarQueryParameter['state'] = state;
      }

      if (code !== undefined) {
        localVarQueryParameter['code'] = code;
      }

      if (error !== undefined) {
        localVarQueryParameter['error'] = error;
      }

      if (errorDescription !== undefined) {
        localVarQueryParameter['error_description'] = errorDescription;
      }

      if (errorDetails !== undefined) {
        localVarQueryParameter['error_details'] = errorDetails;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * generate an access_token
     * @param {TokenRequest} [tokenRequest] token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateCustomerAccessToken: async (
      tokenRequest?: TokenRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/auth/customer/token`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(tokenRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * get jwks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCredSubmitJwks: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/jwks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * get payment jwks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentsJwks: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/payments/jwks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PublicApi - functional programming interface
 * @export
 */
export const PublicApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PublicApiAxiosParamCreator(configuration);
  return {
    /**
     * Callback url to get the oauth authorization token
     * @param {string} state The state of the client when oauth was initialized
     * @param {string} [code] The authorization code generated by the Oauth provider
     * @param {string} [error] error
     * @param {string} [errorDescription] error description
     * @param {string} [errorDetails] error details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authCallback(
      state: string,
      code?: string,
      error?: string,
      errorDescription?: string,
      errorDetails?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RedirectUriResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.authCallback(
        state,
        code,
        error,
        errorDescription,
        errorDetails,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['PublicApi.authCallback']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * generate an access_token
     * @param {TokenRequest} [tokenRequest] token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async generateCustomerAccessToken(
      tokenRequest?: TokenRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.generateCustomerAccessToken(tokenRequest, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['PublicApi.generateCustomerAccessToken']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * get jwks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCredSubmitJwks(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCredSubmitJwks(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['PublicApi.getCredSubmitJwks']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * get payment jwks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPaymentsJwks(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetJWKSResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentsJwks(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['PublicApi.getPaymentsJwks']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * PublicApi - factory interface
 * @export
 */
export const PublicApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = PublicApiFp(configuration);
  return {
    /**
     * Callback url to get the oauth authorization token
     * @param {string} state The state of the client when oauth was initialized
     * @param {string} [code] The authorization code generated by the Oauth provider
     * @param {string} [error] error
     * @param {string} [errorDescription] error description
     * @param {string} [errorDetails] error details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authCallback(
      state: string,
      code?: string,
      error?: string,
      errorDescription?: string,
      errorDetails?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<RedirectUriResponse> {
      return localVarFp
        .authCallback(state, code, error, errorDescription, errorDetails, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * generate an access_token
     * @param {TokenRequest} [tokenRequest] token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateCustomerAccessToken(
      tokenRequest?: TokenRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<TokenResponse> {
      return localVarFp.generateCustomerAccessToken(tokenRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * get jwks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCredSubmitJwks(options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp.getCredSubmitJwks(options).then((request) => request(axios, basePath));
    },
    /**
     * get payment jwks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentsJwks(options?: RawAxiosRequestConfig): AxiosPromise<GetJWKSResponse> {
      return localVarFp.getPaymentsJwks(options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * PublicApi - interface
 * @export
 * @interface PublicApi
 */
export interface PublicApiInterface {
  /**
   * Callback url to get the oauth authorization token
   * @param {string} state The state of the client when oauth was initialized
   * @param {string} [code] The authorization code generated by the Oauth provider
   * @param {string} [error] error
   * @param {string} [errorDescription] error description
   * @param {string} [errorDetails] error details
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PublicApiInterface
   */
  authCallback(
    state: string,
    code?: string,
    error?: string,
    errorDescription?: string,
    errorDetails?: string,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<RedirectUriResponse>;

  /**
   * generate an access_token
   * @param {TokenRequest} [tokenRequest] token request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PublicApiInterface
   */
  generateCustomerAccessToken(
    tokenRequest?: TokenRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<TokenResponse>;

  /**
   * get jwks
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PublicApiInterface
   */
  getCredSubmitJwks(options?: RawAxiosRequestConfig): AxiosPromise<void>;

  /**
   * get payment jwks
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PublicApiInterface
   */
  getPaymentsJwks(options?: RawAxiosRequestConfig): AxiosPromise<GetJWKSResponse>;
}

/**
 * PublicApi - object-oriented interface
 * @export
 * @class PublicApi
 * @extends {BaseAPI}
 */
export class PublicApi extends BaseAPI implements PublicApiInterface {
  /**
   * Callback url to get the oauth authorization token
   * @param {string} state The state of the client when oauth was initialized
   * @param {string} [code] The authorization code generated by the Oauth provider
   * @param {string} [error] error
   * @param {string} [errorDescription] error description
   * @param {string} [errorDetails] error details
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PublicApi
   */
  public authCallback(
    state: string,
    code?: string,
    error?: string,
    errorDescription?: string,
    errorDetails?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return PublicApiFp(this.configuration)
      .authCallback(state, code, error, errorDescription, errorDetails, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * generate an access_token
   * @param {TokenRequest} [tokenRequest] token request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PublicApi
   */
  public generateCustomerAccessToken(tokenRequest?: TokenRequest, options?: RawAxiosRequestConfig) {
    return PublicApiFp(this.configuration)
      .generateCustomerAccessToken(tokenRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * get jwks
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PublicApi
   */
  public getCredSubmitJwks(options?: RawAxiosRequestConfig) {
    return PublicApiFp(this.configuration)
      .getCredSubmitJwks(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * get payment jwks
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PublicApi
   */
  public getPaymentsJwks(options?: RawAxiosRequestConfig) {
    return PublicApiFp(this.configuration)
      .getPaymentsJwks(options)
      .then((request) => request(this.axios, this.basePath));
  }
}
