/* tslint:disable */
/* eslint-disable */
/**
 * Finverse Public
 * Documentation of the early finverse services
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: devs@finverse.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface AccessTokenResponse
 */
export interface AccessTokenResponse {
  /**
   *
   * @type {string}
   * @memberof AccessTokenResponse
   */
  access_token: string;
  /**
   *
   * @type {string}
   * @memberof AccessTokenResponse
   */
  login_identity_id: string;
  /**
   *
   * @type {string}
   * @memberof AccessTokenResponse
   */
  token_type: string;
  /**
   * seconds
   * @type {number}
   * @memberof AccessTokenResponse
   */
  expires_in: number;
  /**
   *
   * @type {string}
   * @memberof AccessTokenResponse
   */
  refresh_token: string;
}
/**
 *
 * @export
 * @interface Account
 */
export interface Account {
  /**
   *
   * @type {string}
   * @memberof Account
   */
  account_id: string;
  /**
   * The SHA3-256 hash of the account number, salted with the loginIdentityId
   * @type {string}
   * @memberof Account
   */
  group_id: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  account_holder_name?: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  account_name: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  account_nickname?: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  account_type?: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  account_sub_type?: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  country?: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  updated_at?: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  account_currency?: string;
  /**
   *
   * @type {CurrencyAmount}
   * @memberof Account
   */
  balance?: CurrencyAmount;
  /**
   *
   * @type {CurrencyAmount}
   * @memberof Account
   */
  statement_balance?: CurrencyAmount;
  /**
   *
   * @type {boolean}
   * @memberof Account
   */
  is_parent: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Account
   */
  is_closed: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Account
   */
  is_excluded: boolean;
}
/**
 *
 * @export
 * @interface AccountNumber
 */
export interface AccountNumber {
  /**
   *
   * @type {string}
   * @memberof AccountNumber
   */
  account_id: string;
  /**
   *
   * @type {string}
   * @memberof AccountNumber
   */
  number?: string;
  /**
   *
   * @type {string}
   * @memberof AccountNumber
   */
  raw: string;
}
/**
 *
 * @export
 * @interface AllProductStatus
 */
export interface AllProductStatus {
  /**
   *
   * @type {ProductStatus}
   * @memberof AllProductStatus
   */
  accounts?: ProductStatus;
  /**
   *
   * @type {ProductStatus}
   * @memberof AllProductStatus
   */
  online_transactions?: ProductStatus;
  /**
   *
   * @type {ProductStatus}
   * @memberof AllProductStatus
   */
  statements?: ProductStatus;
  /**
   *
   * @type {ProductStatus}
   * @memberof AllProductStatus
   */
  historical_transactions?: ProductStatus;
  /**
   *
   * @type {ProductStatus}
   * @memberof AllProductStatus
   */
  account_numbers?: ProductStatus;
  /**
   *
   * @type {ProductStatus}
   * @memberof AllProductStatus
   */
  identity?: ProductStatus;
  /**
   *
   * @type {ProductStatus}
   * @memberof AllProductStatus
   */
  balance_history?: ProductStatus;
}
/**
 *
 * @export
 * @interface BadRequestModel
 */
export interface BadRequestModel {
  /**
   *
   * @type {BadRequestModelError}
   * @memberof BadRequestModel
   */
  error?: BadRequestModelError;
}
/**
 *
 * @export
 * @interface BadRequestModelError
 */
export interface BadRequestModelError {
  /**
   *
   * @type {number}
   * @memberof BadRequestModelError
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof BadRequestModelError
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof BadRequestModelError
   */
  message?: string;
  /**
   * A link to visit for further action
   * @type {string}
   * @memberof BadRequestModelError
   */
  link?: string;
}
/**
 *
 * @export
 * @interface BalanceHistory
 */
export interface BalanceHistory {
  /**
   * The date the balance was recorded
   * @type {string}
   * @memberof BalanceHistory
   */
  date: string;
  /**
   * The end of day balance for this account on this specific date
   * @type {number}
   * @memberof BalanceHistory
   */
  amount: number;
  /**
   * The currency the balance
   * @type {string}
   * @memberof BalanceHistory
   */
  currency: string;
}
/**
 *
 * @export
 * @interface CreateCustomerRequest
 */
export interface CreateCustomerRequest {
  /**
   * The email of the customer. This has to be unique.
   * @type {string}
   * @memberof CreateCustomerRequest
   */
  name: string;
  /**
   * The email of the customer. This has to be unique.
   * @type {string}
   * @memberof CreateCustomerRequest
   */
  email: string;
  /**
   * Primary key to identity the customer
   * @type {string}
   * @memberof CreateCustomerRequest
   */
  customer_app_id: string;
  /**
   * The redirect callback
   * @type {Array<string>}
   * @memberof CreateCustomerRequest
   */
  redirect_uris: Array<string>;
  /**
   * The webhook uris
   * @type {Array<string>}
   * @memberof CreateCustomerRequest
   */
  webhook_uris?: Array<string>;
}
/**
 *
 * @export
 * @interface CreateCustomerResponse
 */
export interface CreateCustomerResponse {
  /**
   * The email of the customer. This has to be unique.
   * @type {string}
   * @memberof CreateCustomerResponse
   */
  name: string;
  /**
   * The email of the customer. This has to be unique.
   * @type {string}
   * @memberof CreateCustomerResponse
   */
  email: string;
  /**
   * Primary key to identity the customer
   * @type {string}
   * @memberof CreateCustomerResponse
   */
  customer_app_id: string;
  /**
   * The redirect callback
   * @type {Array<string>}
   * @memberof CreateCustomerResponse
   */
  redirect_uris: Array<string>;
  /**
   *
   * @type {string}
   * @memberof CreateCustomerResponse
   */
  client_id: string;
  /**
   *
   * @type {string}
   * @memberof CreateCustomerResponse
   */
  client_secret: string;
  /**
   * The webhook uris
   * @type {Array<string>}
   * @memberof CreateCustomerResponse
   */
  webhook_uris?: Array<string>;
}
/**
 *
 * @export
 * @interface CurrencyAmount
 */
export interface CurrencyAmount {
  /**
   *
   * @type {string}
   * @memberof CurrencyAmount
   */
  currency?: string;
  /**
   *
   * @type {number}
   * @memberof CurrencyAmount
   */
  value: number;
  /**
   *
   * @type {string}
   * @memberof CurrencyAmount
   */
  raw?: string;
}
/**
 *
 * @export
 * @interface CustomizationDetails
 */
export interface CustomizationDetails {
  /**
   *
   * @type {string}
   * @memberof CustomizationDetails
   */
  logo_id?: string;
  /**
   *
   * @type {string}
   * @memberof CustomizationDetails
   */
  display_name?: string;
  /**
   *
   * @type {string}
   * @memberof CustomizationDetails
   */
  customer_app_name?: string;
}
/**
 *
 * @export
 * @interface DeleteInstitutionResponse
 */
export interface DeleteInstitutionResponse {
  /**
   *
   * @type {boolean}
   * @memberof DeleteInstitutionResponse
   */
  success?: boolean;
}
/**
 *
 * @export
 * @interface DeleteLoginIdentityResponse
 */
export interface DeleteLoginIdentityResponse {
  /**
   *
   * @type {boolean}
   * @memberof DeleteLoginIdentityResponse
   */
  success?: boolean;
}
/**
 *
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
  /**
   *
   * @type {string}
   * @memberof ErrorResponse
   */
  err?: string;
  /**
   *
   * @type {number}
   * @memberof ErrorResponse
   */
  http_status_code?: number;
  /**
   *
   * @type {string}
   * @memberof ErrorResponse
   */
  status_text?: string;
  /**
   *
   * @type {number}
   * @memberof ErrorResponse
   */
  app_code?: number;
  /**
   *
   * @type {string}
   * @memberof ErrorResponse
   */
  error_category?: string;
  /**
   *
   * @type {string}
   * @memberof ErrorResponse
   */
  error_text?: string;
  /**
   *
   * @type {string}
   * @memberof ErrorResponse
   */
  request_id?: string;
}
/**
 *
 * @export
 * @interface GetAccountNumberResponse
 */
export interface GetAccountNumberResponse {
  /**
   *
   * @type {AccountNumber}
   * @memberof GetAccountNumberResponse
   */
  account_number?: AccountNumber;
  /**
   *
   * @type {Account}
   * @memberof GetAccountNumberResponse
   */
  account?: Account;
  /**
   *
   * @type {LoginIdentityShort}
   * @memberof GetAccountNumberResponse
   */
  login_identity?: LoginIdentityShort;
  /**
   *
   * @type {InstitutionShort}
   * @memberof GetAccountNumberResponse
   */
  institution?: InstitutionShort;
  /**
   *
   * @type {Array<PaymentDetails>}
   * @memberof GetAccountNumberResponse
   */
  payment_details?: Array<PaymentDetails>;
}
/**
 *
 * @export
 * @interface GetAccountResponse
 */
export interface GetAccountResponse {
  /**
   *
   * @type {Account}
   * @memberof GetAccountResponse
   */
  account?: Account;
  /**
   *
   * @type {LoginIdentityShort}
   * @memberof GetAccountResponse
   */
  login_identity?: LoginIdentityShort;
  /**
   *
   * @type {InstitutionShort}
   * @memberof GetAccountResponse
   */
  institution?: InstitutionShort;
}
/**
 *
 * @export
 * @interface GetBalanceHistoryResponse
 */
export interface GetBalanceHistoryResponse {
  /**
   *
   * @type {Account}
   * @memberof GetBalanceHistoryResponse
   */
  account?: Account;
  /**
   *
   * @type {LoginIdentityShort}
   * @memberof GetBalanceHistoryResponse
   */
  login_identity?: LoginIdentityShort;
  /**
   *
   * @type {InstitutionShort}
   * @memberof GetBalanceHistoryResponse
   */
  institution?: InstitutionShort;
  /**
   *
   * @type {Array<BalanceHistory>}
   * @memberof GetBalanceHistoryResponse
   */
  balance_history?: Array<BalanceHistory>;
}
/**
 *
 * @export
 * @interface GetIdentityResponse
 */
export interface GetIdentityResponse {
  /**
   *
   * @type {Identity}
   * @memberof GetIdentityResponse
   */
  identity?: Identity;
  /**
   *
   * @type {LoginIdentityShort}
   * @memberof GetIdentityResponse
   */
  login_identity?: LoginIdentityShort;
  /**
   *
   * @type {InstitutionShort}
   * @memberof GetIdentityResponse
   */
  institution?: InstitutionShort;
}
/**
 *
 * @export
 * @interface GetLoginIdentityByIdResponse
 */
export interface GetLoginIdentityByIdResponse {
  /**
   *
   * @type {LoginIdentity}
   * @memberof GetLoginIdentityByIdResponse
   */
  login_identity?: LoginIdentity;
  /**
   *
   * @type {InstitutionShort}
   * @memberof GetLoginIdentityByIdResponse
   */
  institution?: InstitutionShort;
}
/**
 *
 * @export
 * @interface GetLoginIdentityHistoryResponse
 */
export interface GetLoginIdentityHistoryResponse {
  /**
   *
   * @type {LoginIdentity}
   * @memberof GetLoginIdentityHistoryResponse
   */
  login_identity?: LoginIdentity;
  /**
   *
   * @type {Array<LoginIdentityStatusDetails>}
   * @memberof GetLoginIdentityHistoryResponse
   */
  status_history?: Array<LoginIdentityStatusDetails>;
}
/**
 *
 * @export
 * @interface GetStatementLinkResponse
 */
export interface GetStatementLinkResponse {
  /**
   *
   * @type {Array<StatementLink>}
   * @memberof GetStatementLinkResponse
   */
  statement_links?: Array<StatementLink>;
}
/**
 *
 * @export
 * @interface GetStatementsResponse
 */
export interface GetStatementsResponse {
  /**
   *
   * @type {Array<Statement>}
   * @memberof GetStatementsResponse
   */
  statements?: Array<Statement>;
  /**
   *
   * @type {LoginIdentityShort}
   * @memberof GetStatementsResponse
   */
  login_identity?: LoginIdentityShort;
  /**
   *
   * @type {InstitutionShort}
   * @memberof GetStatementsResponse
   */
  institution?: InstitutionShort;
}
/**
 *
 * @export
 * @interface Identity
 */
export interface Identity {
  /**
   *
   * @type {Array<IdentityName>}
   * @memberof Identity
   */
  names?: Array<IdentityName>;
  /**
   *
   * @type {Array<IdentityAddress>}
   * @memberof Identity
   */
  addresses?: Array<IdentityAddress>;
  /**
   *
   * @type {Array<IdentityEmail>}
   * @memberof Identity
   */
  emails?: Array<IdentityEmail>;
  /**
   *
   * @type {Array<IdentityPhoneNumber>}
   * @memberof Identity
   */
  phone_numbers?: Array<IdentityPhoneNumber>;
  /**
   *
   * @type {Array<IdentityDateOfBirth>}
   * @memberof Identity
   */
  date_of_births?: Array<IdentityDateOfBirth>;
}
/**
 *
 * @export
 * @interface IdentityAddress
 */
export interface IdentityAddress {
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  raw?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  full_address?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  unit_number?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  floor_number?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  building_name?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  street_number?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  street_name?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  city?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  district?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  ward?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  street_address?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  province?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  country?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  postal_code?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  source?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof IdentityAddress
   */
  source_ids?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof IdentityAddress
   */
  account_ids?: Array<string>;
}
/**
 *
 * @export
 * @interface IdentityDateOfBirth
 */
export interface IdentityDateOfBirth {
  /**
   *
   * @type {string}
   * @memberof IdentityDateOfBirth
   */
  raw?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityDateOfBirth
   */
  date_of_birth?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityDateOfBirth
   */
  source?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof IdentityDateOfBirth
   */
  source_ids?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof IdentityDateOfBirth
   */
  account_ids?: Array<string>;
}
/**
 *
 * @export
 * @interface IdentityEmail
 */
export interface IdentityEmail {
  /**
   *
   * @type {string}
   * @memberof IdentityEmail
   */
  raw?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityEmail
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityEmail
   */
  masked_email?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityEmail
   */
  source?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof IdentityEmail
   */
  source_ids?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof IdentityEmail
   */
  account_ids?: Array<string>;
}
/**
 *
 * @export
 * @interface IdentityName
 */
export interface IdentityName {
  /**
   *
   * @type {string}
   * @memberof IdentityName
   */
  raw?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityName
   */
  full_name?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityName
   */
  first_name?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityName
   */
  last_name?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityName
   */
  other_name?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityName
   */
  source?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof IdentityName
   */
  source_ids?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof IdentityName
   */
  account_ids?: Array<string>;
}
/**
 *
 * @export
 * @interface IdentityPhoneNumber
 */
export interface IdentityPhoneNumber {
  /**
   *
   * @type {string}
   * @memberof IdentityPhoneNumber
   */
  raw?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityPhoneNumber
   */
  mobile_phone?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityPhoneNumber
   */
  other_phone?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityPhoneNumber
   */
  masked_phone?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityPhoneNumber
   */
  source?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof IdentityPhoneNumber
   */
  source_ids?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof IdentityPhoneNumber
   */
  account_ids?: Array<string>;
}
/**
 *
 * @export
 * @interface Institution
 */
export interface Institution {
  /**
   *
   * @type {string}
   * @memberof Institution
   */
  institution_id: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Institution
   */
  countries: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof Institution
   */
  tags?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof Institution
   */
  institution_type: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Institution
   */
  products_supported: Array<string>;
  /**
   *
   * @type {string}
   * @memberof Institution
   */
  parent_institution_name?: string;
  /**
   *
   * @type {string}
   * @memberof Institution
   */
  institution_name: string;
  /**
   *
   * @type {string}
   * @memberof Institution
   */
  portal_name?: string;
  /**
   *
   * @type {string}
   * @memberof Institution
   */
  user_type: string;
  /**
   *
   * @type {string}
   * @memberof Institution
   */
  status: string;
  /**
   *
   * @type {object}
   * @memberof Institution
   */
  status_details?: object;
  /**
   *
   * @type {string}
   * @memberof Institution
   */
  login_url?: string;
  /**
   *
   * @type {object}
   * @memberof Institution
   */
  login_details?: object;
  /**
   *
   * @type {Array<LoginMethod>}
   * @memberof Institution
   */
  login_methods?: Array<LoginMethod>;
  /**
   *
   * @type {string}
   * @memberof Institution
   */
  color?: string;
  /**
   *
   * @type {string}
   * @memberof Institution
   */
  updated_at?: string;
}
/**
 *
 * @export
 * @interface InstitutionShort
 */
export interface InstitutionShort {
  /**
   *
   * @type {string}
   * @memberof InstitutionShort
   */
  institution_id?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof InstitutionShort
   */
  countries?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof InstitutionShort
   */
  institution_name?: string;
  /**
   *
   * @type {string}
   * @memberof InstitutionShort
   */
  portal_name?: string;
}
/**
 *
 * @export
 * @interface LinkRequest
 */
export interface LinkRequest {
  /**
   *
   * @type {string}
   * @memberof LinkRequest
   */
  institution_id: string;
  /**
   *
   * @type {boolean}
   * @memberof LinkRequest
   */
  store_credential: boolean;
}
/**
 *
 * @export
 * @interface LinkResponse
 */
export interface LinkResponse {
  /**
   *
   * @type {string}
   * @memberof LinkResponse
   */
  auth_url?: string;
}
/**
 *
 * @export
 * @interface LinkTokenRequest
 */
export interface LinkTokenRequest {
  /**
   * support only client_credentials
   * @type {string}
   * @memberof LinkTokenRequest
   */
  grant_type: string;
  /**
   *
   * @type {string}
   * @memberof LinkTokenRequest
   */
  response_type: string;
  /**
   *
   * @type {string}
   * @memberof LinkTokenRequest
   */
  response_mode: string;
  /**
   * required when creating new Link, ignored when updating existing Link
   * @type {string}
   * @memberof LinkTokenRequest
   */
  user_id?: string;
  /**
   *
   * @type {string}
   * @memberof LinkTokenRequest
   */
  client_id: string;
  /**
   *
   * @type {string}
   * @memberof LinkTokenRequest
   */
  redirect_uri: string;
  /**
   *
   * @type {string}
   * @memberof LinkTokenRequest
   */
  state?: string;
  /**
   *
   * @type {string}
   * @memberof LinkTokenRequest
   */
  scope?: string;
  /**
   * Space separated list of the tags of the institutions to view.
   * @type {string}
   * @memberof LinkTokenRequest
   */
  link_mode?: string;
  /**
   * The UI mode link is intended to be used in - \"iframe\" (default), \"auto_redirect\" or \"redirect\"
   * @type {string}
   * @memberof LinkTokenRequest
   */
  ui_mode?: LinkTokenRequestUiModeEnum;
  /**
   *
   * @type {string}
   * @memberof LinkTokenRequest
   */
  language?: string;
  /**
   *
   * @type {string}
   * @memberof LinkTokenRequest
   */
  code_challenge?: string;
  /**
   *
   * @type {string}
   * @memberof LinkTokenRequest
   */
  code_challenge_method?: string;
  /**
   * use this to update a specific login identity
   * @type {string}
   * @memberof LinkTokenRequest
   */
  login_identity_id?: string;
  /**
   * The customization id if the customer wishes to embed it into link token for spawning link with their choice of stuffs
   * @type {string}
   * @memberof LinkTokenRequest
   */
  customization_id?: string;
  /**
   * Institution to preselect
   * @type {string}
   * @memberof LinkTokenRequest
   */
  institution_id?: string;
  /**
   * institution\'s country filter
   * @type {Array<string>}
   * @memberof LinkTokenRequest
   */
  countries?: Array<string>;
  /**
   * institution\'s supported user_type filter
   * @type {Array<string>}
   * @memberof LinkTokenRequest
   */
  user_type?: Array<string>;
  /**
   * institution\'s supported product filter
   * @type {Array<string>}
   * @memberof LinkTokenRequest
   */
  products_supported?: Array<string>;
}

export const LinkTokenRequestUiModeEnum = {
  Iframe: 'iframe',
  Redirect: 'redirect',
  AutoRedirect: 'auto_redirect',
} as const;

export type LinkTokenRequestUiModeEnum = typeof LinkTokenRequestUiModeEnum[keyof typeof LinkTokenRequestUiModeEnum];

/**
 *
 * @export
 * @interface LinkTokenResponse
 */
export interface LinkTokenResponse {
  /**
   *
   * @type {string}
   * @memberof LinkTokenResponse
   */
  access_token: string;
  /**
   *
   * @type {string}
   * @memberof LinkTokenResponse
   */
  token_type: string;
  /**
   * seconds
   * @type {number}
   * @memberof LinkTokenResponse
   */
  expires_in: number;
  /**
   *
   * @type {string}
   * @memberof LinkTokenResponse
   */
  link_url: string;
}
/**
 *
 * @export
 * @interface ListAccountsResponse
 */
export interface ListAccountsResponse {
  /**
   *
   * @type {Array<Account>}
   * @memberof ListAccountsResponse
   */
  accounts?: Array<Account>;
  /**
   *
   * @type {LoginIdentityShort}
   * @memberof ListAccountsResponse
   */
  login_identity?: LoginIdentityShort;
  /**
   *
   * @type {InstitutionShort}
   * @memberof ListAccountsResponse
   */
  institution?: InstitutionShort;
}
/**
 *
 * @export
 * @interface ListTransactionsResponse
 */
export interface ListTransactionsResponse {
  /**
   *
   * @type {Array<Account>}
   * @memberof ListTransactionsResponse
   */
  accounts?: Array<Account>;
  /**
   *
   * @type {Array<Transaction>}
   * @memberof ListTransactionsResponse
   */
  transactions?: Array<Transaction>;
  /**
   *
   * @type {LoginIdentityShort}
   * @memberof ListTransactionsResponse
   */
  login_identity?: LoginIdentityShort;
  /**
   *
   * @type {InstitutionShort}
   * @memberof ListTransactionsResponse
   */
  institution?: InstitutionShort;
  /**
   *
   * @type {number}
   * @memberof ListTransactionsResponse
   */
  total_transactions: number;
}
/**
 *
 * @export
 * @interface LoginField
 */
export interface LoginField {
  /**
   *
   * @type {string}
   * @memberof LoginField
   */
  key?: string;
  /**
   *
   * @type {string}
   * @memberof LoginField
   */
  name?: string;
  /**
   * could be password, text, number
   * @type {string}
   * @memberof LoginField
   */
  type?: string;
}
/**
 *
 * @export
 * @interface LoginIdentity
 */
export interface LoginIdentity {
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  login_identity_id?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  customer_app_id: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  user_id: string;
  /**
   *
   * @type {LoginIdentityLoginMethodsAvailable}
   * @memberof LoginIdentity
   */
  login_methods_available?: LoginIdentityLoginMethodsAvailable;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  permissions_grant_date?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  permissions_expiry_date?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof LoginIdentity
   */
  permissions?: Array<string>;
  /**
   *
   * @type {LoginIdentityBillingDetails}
   * @memberof LoginIdentity
   */
  billing_details?: LoginIdentityBillingDetails;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  status?: string;
  /**
   *
   * @type {LoginIdentityStatusDetails}
   * @memberof LoginIdentity
   */
  status_details?: LoginIdentityStatusDetails;
  /**
   *
   * @type {AllProductStatus}
   * @memberof LoginIdentity
   */
  product_status?: AllProductStatus;
  /**
   *
   * @type {ProductStatus}
   * @memberof LoginIdentity
   */
  authentication_status?: ProductStatus;
  /**
   *
   * @type {LoginIdentityError}
   * @memberof LoginIdentity
   */
  error?: LoginIdentityError;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  last_success?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  first_success?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  webhook?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  institution_id: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  updated_at?: string;
  /**
   * a login attempt id which is unique per login_identity
   * @type {string}
   * @memberof LoginIdentity
   */
  linking_attempt_id?: string;
  /**
   * a successful login attempt id which is unique per login_identity
   * @type {string}
   * @memberof LoginIdentity
   */
  authentication_id?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  last_session_id?: string;
}
/**
 *
 * @export
 * @interface LoginIdentityBillingDetails
 */
export interface LoginIdentityBillingDetails {
  /**
   *
   * @type {Array<string>}
   * @memberof LoginIdentityBillingDetails
   */
  billed_products?: Array<string>;
}
/**
 *
 * @export
 * @interface LoginIdentityError
 */
export interface LoginIdentityError {
  /**
   *
   * @type {number}
   * @memberof LoginIdentityError
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof LoginIdentityError
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentityError
   */
  message?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentityError
   */
  details?: string;
}
/**
 *
 * @export
 * @interface LoginIdentityLoginMethodsAvailable
 */
export interface LoginIdentityLoginMethodsAvailable {
  /**
   *
   * @type {boolean}
   * @memberof LoginIdentityLoginMethodsAvailable
   */
  havePassword?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof LoginIdentityLoginMethodsAvailable
   */
  haveSecret?: boolean;
}
/**
 *
 * @export
 * @interface LoginIdentityShort
 */
export interface LoginIdentityShort {
  /**
   *
   * @type {string}
   * @memberof LoginIdentityShort
   */
  login_identity_id?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentityShort
   */
  status?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentityShort
   */
  last_session_id?: string;
}
/**
 *
 * @export
 * @interface LoginIdentityStatusDetails
 */
export interface LoginIdentityStatusDetails {
  /**
   *
   * @type {string}
   * @memberof LoginIdentityStatusDetails
   */
  event_date?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentityStatusDetails
   */
  event_name?: string;
}
/**
 *
 * @export
 * @interface LoginMethod
 */
export interface LoginMethod {
  /**
   *
   * @type {string}
   * @memberof LoginMethod
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof LoginMethod
   */
  name?: string;
  /**
   *
   * @type {Array<LoginField>}
   * @memberof LoginMethod
   */
  login_fields?: Array<LoginField>;
}
/**
 *
 * @export
 * @interface OtherInfo
 */
export interface OtherInfo {
  /**
   *
   * @type {string}
   * @memberof OtherInfo
   */
  bank_code?: string;
}
/**
 *
 * @export
 * @interface PaymentDetails
 */
export interface PaymentDetails {
  /**
   *
   * @type {string}
   * @memberof PaymentDetails
   */
  format?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentDetails
   */
  bic?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentDetails
   */
  bank_fullname?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentDetails
   */
  bank_shortname?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentDetails
   */
  bank_address?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentDetails
   */
  bank_country?: string;
  /**
   *
   * @type {OtherInfo}
   * @memberof PaymentDetails
   */
  other_info?: OtherInfo;
}
/**
 *
 * @export
 * @interface Principal
 */
export interface Principal {
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  subject: string;
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  token?: string;
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  client_id: string;
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  customer_app_id: string;
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  login_identity_id: string;
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  customization_id?: string;
  /**
   *
   * @type {number}
   * @memberof Principal
   */
  expires_in?: number;
  /**
   *
   * @type {Array<string>}
   * @memberof Principal
   */
  scopes?: Array<string>;
  /**
   *
   * @type {LinkTokenRequest}
   * @memberof Principal
   */
  link_token_request?: LinkTokenRequest;
}
/**
 *
 * @export
 * @interface ProductStatus
 */
export interface ProductStatus {
  /**
   * The current health of this product
   * @type {string}
   * @memberof ProductStatus
   */
  status?: string;
  /**
   * The detailed event name
   * @type {string}
   * @memberof ProductStatus
   */
  status_details?: string;
  /**
   *
   * @type {string}
   * @memberof ProductStatus
   */
  last_update?: string | null;
  /**
   *
   * @type {string}
   * @memberof ProductStatus
   */
  last_successful_update?: string | null;
}
/**
 *
 * @export
 * @interface RedirectUriResponse
 */
export interface RedirectUriResponse {
  /**
   *
   * @type {string}
   * @memberof RedirectUriResponse
   */
  redirect_uri?: string;
}
/**
 *
 * @export
 * @interface RefreshRequest
 */
export interface RefreshRequest {
  /**
   *
   * @type {string}
   * @memberof RefreshRequest
   */
  refresh_token: string;
}
/**
 *
 * @export
 * @interface RelinkRequest
 */
export interface RelinkRequest {
  /**
   *
   * @type {boolean}
   * @memberof RelinkRequest
   */
  store_credential: boolean;
}
/**
 *
 * @export
 * @interface Statement
 */
export interface Statement {
  /**
   *
   * @type {string}
   * @memberof Statement
   */
  id?: string;
  /**
   * YYYY-MM-DD
   * @type {string}
   * @memberof Statement
   */
  date?: string;
  /**
   *
   * @type {string}
   * @memberof Statement
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof Statement
   */
  created_at?: string;
}
/**
 *
 * @export
 * @interface StatementLink
 */
export interface StatementLink {
  /**
   * signedURL to download statement
   * @type {string}
   * @memberof StatementLink
   */
  url?: string;
  /**
   * expiry of the signedURL
   * @type {string}
   * @memberof StatementLink
   */
  expiry?: string;
  /**
   *
   * @type {string}
   * @memberof StatementLink
   */
  statement_id?: string;
}
/**
 *
 * @export
 * @interface TokenRequest
 */
export interface TokenRequest {
  /**
   *
   * @type {string}
   * @memberof TokenRequest
   */
  client_id: string;
  /**
   *
   * @type {string}
   * @memberof TokenRequest
   */
  client_secret: string;
  /**
   * support only client_credentials
   * @type {string}
   * @memberof TokenRequest
   */
  grant_type: string;
}
/**
 *
 * @export
 * @interface TokenResponse
 */
export interface TokenResponse {
  /**
   *
   * @type {string}
   * @memberof TokenResponse
   */
  access_token: string;
  /**
   *
   * @type {string}
   * @memberof TokenResponse
   */
  token_type: string;
  /**
   * seconds
   * @type {number}
   * @memberof TokenResponse
   */
  expires_in: number;
}
/**
 *
 * @export
 * @interface Transaction
 */
export interface Transaction {
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  transaction_id?: string;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  account_id?: string;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  transaction_state?: string;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  transaction_type?: string;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  category?: string;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  category_id?: string;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  merchant_name?: string;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  location?: string;
  /**
   *
   * @type {boolean}
   * @memberof Transaction
   */
  is_pending: boolean;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  status?: string;
  /**
   * YYYY-MM-DD
   * @type {string}
   * @memberof Transaction
   */
  posted_date?: string;
  /**
   * YYYY-MM-DD
   * @type {string}
   * @memberof Transaction
   */
  transaction_date?: string;
  /**
   *
   * @type {CurrencyAmount}
   * @memberof Transaction
   */
  amount?: CurrencyAmount;
  /**
   *
   * @type {object}
   * @memberof Transaction
   */
  transfer_details?: object;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  updated_at?: string;
}

/**
 * CustomerApi - axios parameter creator
 * @export
 */
export const CustomerApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * generate a link token that can be used to create link
     * @param {LinkTokenRequest} linkTokenRequest token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateLinkToken: async (
      linkTokenRequest: LinkTokenRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'linkTokenRequest' is not null or undefined
      assertParamExists('generateLinkToken', 'linkTokenRequest', linkTokenRequest);
      const localVarPath = `/link/token`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(linkTokenRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a specific institution by institutionId
     * @param {string} institutionId The institution id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInstitution: async (institutionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'institutionId' is not null or undefined
      assertParamExists('getInstitution', 'institutionId', institutionId);
      const localVarPath = `/institutions/{institutionId}`.replace(
        `{${'institutionId'}}`,
        encodeURIComponent(String(institutionId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', ['institution'], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a specific loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoginIdentityById: async (loginIdentityId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'loginIdentityId' is not null or undefined
      assertParamExists('getLoginIdentityById', 'loginIdentityId', loginIdentityId);
      const localVarPath = `/login_identity/{loginIdentityId}`.replace(
        `{${'loginIdentityId'}}`,
        encodeURIComponent(String(loginIdentityId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a history of events for a specific loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoginIdentityHistory: async (
      loginIdentityId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'loginIdentityId' is not null or undefined
      assertParamExists('getLoginIdentityHistory', 'loginIdentityId', loginIdentityId);
      const localVarPath = `/login_identity/{loginIdentityId}/history`.replace(
        `{${'loginIdentityId'}}`,
        encodeURIComponent(String(loginIdentityId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of institutions
     * @param {string} [country] The country the institution belongs to
     * @param {Array<string>} [countries] The countries the institution belongs to
     * @param {string} [productsSupported] The products that this institution supports
     * @param {string} [institutionType] The type of institution
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listInstitutions: async (
      country?: string,
      countries?: Array<string>,
      productsSupported?: string,
      institutionType?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/institutions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', ['institution'], configuration);

      if (country !== undefined) {
        localVarQueryParameter['country'] = country;
      }

      if (countries) {
        localVarQueryParameter['countries'] = countries.join(COLLECTION_FORMATS.csv);
      }

      if (productsSupported !== undefined) {
        localVarQueryParameter['products_supported'] = productsSupported;
      }

      if (institutionType !== undefined) {
        localVarQueryParameter['institution_type'] = institutionType;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Refresh an access token
     * @param {RefreshRequest} refreshRequest The refresh token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshToken: async (refreshRequest: RefreshRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'refreshRequest' is not null or undefined
      assertParamExists('refreshToken', 'refreshRequest', refreshRequest);
      const localVarPath = `/auth/token/refresh`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(refreshRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CustomerApi - functional programming interface
 * @export
 */
export const CustomerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = CustomerApiAxiosParamCreator(configuration);
  return {
    /**
     * generate a link token that can be used to create link
     * @param {LinkTokenRequest} linkTokenRequest token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async generateLinkToken(
      linkTokenRequest: LinkTokenRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkTokenResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.generateLinkToken(linkTokenRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get a specific institution by institutionId
     * @param {string} institutionId The institution id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getInstitution(
      institutionId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Institution>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getInstitution(institutionId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get a specific loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLoginIdentityById(
      loginIdentityId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLoginIdentityByIdResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLoginIdentityById(loginIdentityId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get a history of events for a specific loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLoginIdentityHistory(
      loginIdentityId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLoginIdentityHistoryResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLoginIdentityHistory(loginIdentityId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get a list of institutions
     * @param {string} [country] The country the institution belongs to
     * @param {Array<string>} [countries] The countries the institution belongs to
     * @param {string} [productsSupported] The products that this institution supports
     * @param {string} [institutionType] The type of institution
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listInstitutions(
      country?: string,
      countries?: Array<string>,
      productsSupported?: string,
      institutionType?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Institution>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listInstitutions(
        country,
        countries,
        productsSupported,
        institutionType,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Refresh an access token
     * @param {RefreshRequest} refreshRequest The refresh token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async refreshToken(
      refreshRequest: RefreshRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessTokenResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(refreshRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * CustomerApi - factory interface
 * @export
 */
export const CustomerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = CustomerApiFp(configuration);
  return {
    /**
     * generate a link token that can be used to create link
     * @param {LinkTokenRequest} linkTokenRequest token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateLinkToken(linkTokenRequest: LinkTokenRequest, options?: any): AxiosPromise<LinkTokenResponse> {
      return localVarFp.generateLinkToken(linkTokenRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Get a specific institution by institutionId
     * @param {string} institutionId The institution id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInstitution(institutionId: string, options?: any): AxiosPromise<Institution> {
      return localVarFp.getInstitution(institutionId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get a specific loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoginIdentityById(loginIdentityId: string, options?: any): AxiosPromise<GetLoginIdentityByIdResponse> {
      return localVarFp.getLoginIdentityById(loginIdentityId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get a history of events for a specific loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoginIdentityHistory(loginIdentityId: string, options?: any): AxiosPromise<GetLoginIdentityHistoryResponse> {
      return localVarFp.getLoginIdentityHistory(loginIdentityId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get a list of institutions
     * @param {string} [country] The country the institution belongs to
     * @param {Array<string>} [countries] The countries the institution belongs to
     * @param {string} [productsSupported] The products that this institution supports
     * @param {string} [institutionType] The type of institution
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listInstitutions(
      country?: string,
      countries?: Array<string>,
      productsSupported?: string,
      institutionType?: string,
      options?: any,
    ): AxiosPromise<Array<Institution>> {
      return localVarFp
        .listInstitutions(country, countries, productsSupported, institutionType, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Refresh an access token
     * @param {RefreshRequest} refreshRequest The refresh token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshToken(refreshRequest: RefreshRequest, options?: any): AxiosPromise<AccessTokenResponse> {
      return localVarFp.refreshToken(refreshRequest, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * CustomerApi - interface
 * @export
 * @interface CustomerApi
 */
export interface CustomerApiInterface {
  /**
   * generate a link token that can be used to create link
   * @param {LinkTokenRequest} linkTokenRequest token request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  generateLinkToken(linkTokenRequest: LinkTokenRequest, options?: AxiosRequestConfig): AxiosPromise<LinkTokenResponse>;

  /**
   * Get a specific institution by institutionId
   * @param {string} institutionId The institution id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  getInstitution(institutionId: string, options?: AxiosRequestConfig): AxiosPromise<Institution>;

  /**
   * Get a specific loginIdentity
   * @param {string} loginIdentityId The login identity id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  getLoginIdentityById(
    loginIdentityId: string,
    options?: AxiosRequestConfig,
  ): AxiosPromise<GetLoginIdentityByIdResponse>;

  /**
   * Get a history of events for a specific loginIdentity
   * @param {string} loginIdentityId The login identity id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  getLoginIdentityHistory(
    loginIdentityId: string,
    options?: AxiosRequestConfig,
  ): AxiosPromise<GetLoginIdentityHistoryResponse>;

  /**
   * Get a list of institutions
   * @param {string} [country] The country the institution belongs to
   * @param {Array<string>} [countries] The countries the institution belongs to
   * @param {string} [productsSupported] The products that this institution supports
   * @param {string} [institutionType] The type of institution
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  listInstitutions(
    country?: string,
    countries?: Array<string>,
    productsSupported?: string,
    institutionType?: string,
    options?: AxiosRequestConfig,
  ): AxiosPromise<Array<Institution>>;

  /**
   * Refresh an access token
   * @param {RefreshRequest} refreshRequest The refresh token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  refreshToken(refreshRequest: RefreshRequest, options?: AxiosRequestConfig): AxiosPromise<AccessTokenResponse>;
}

/**
 * CustomerApi - object-oriented interface
 * @export
 * @class CustomerApi
 * @extends {BaseAPI}
 */
export class CustomerApi extends BaseAPI implements CustomerApiInterface {
  /**
   * generate a link token that can be used to create link
   * @param {LinkTokenRequest} linkTokenRequest token request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public generateLinkToken(linkTokenRequest: LinkTokenRequest, options?: AxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .generateLinkToken(linkTokenRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a specific institution by institutionId
   * @param {string} institutionId The institution id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public getInstitution(institutionId: string, options?: AxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .getInstitution(institutionId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a specific loginIdentity
   * @param {string} loginIdentityId The login identity id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public getLoginIdentityById(loginIdentityId: string, options?: AxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .getLoginIdentityById(loginIdentityId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a history of events for a specific loginIdentity
   * @param {string} loginIdentityId The login identity id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public getLoginIdentityHistory(loginIdentityId: string, options?: AxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .getLoginIdentityHistory(loginIdentityId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of institutions
   * @param {string} [country] The country the institution belongs to
   * @param {Array<string>} [countries] The countries the institution belongs to
   * @param {string} [productsSupported] The products that this institution supports
   * @param {string} [institutionType] The type of institution
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public listInstitutions(
    country?: string,
    countries?: Array<string>,
    productsSupported?: string,
    institutionType?: string,
    options?: AxiosRequestConfig,
  ) {
    return CustomerApiFp(this.configuration)
      .listInstitutions(country, countries, productsSupported, institutionType, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Refresh an access token
   * @param {RefreshRequest} refreshRequest The refresh token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public refreshToken(refreshRequest: RefreshRequest, options?: AxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .refreshToken(refreshRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * LinkApi - axios parameter creator
 * @export
 */
export const LinkApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Creates a new link
     * @param {LinkRequest} linkRequest Request body for starting a new Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLink: async (linkRequest: LinkRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'linkRequest' is not null or undefined
      assertParamExists('createLink', 'linkRequest', linkRequest);
      const localVarPath = `/link`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', ['link'], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(linkRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the customization details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCustomization: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/customer/customizations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', ['link'], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of institutions
     * @param {string} [country] The country the institution belongs to
     * @param {Array<string>} [countries] The countries the institution belongs to
     * @param {string} [productsSupported] The products that this institution supports
     * @param {string} [institutionType] The type of institution
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listInstitutions: async (
      country?: string,
      countries?: Array<string>,
      productsSupported?: string,
      institutionType?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/institutions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', ['institution'], configuration);

      if (country !== undefined) {
        localVarQueryParameter['country'] = country;
      }

      if (countries) {
        localVarQueryParameter['countries'] = countries.join(COLLECTION_FORMATS.csv);
      }

      if (productsSupported !== undefined) {
        localVarQueryParameter['products_supported'] = productsSupported;
      }

      if (institutionType !== undefined) {
        localVarQueryParameter['institution_type'] = institutionType;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update an existing link
     * @param {RelinkRequest} relinkRequest Request body for updating Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    relink: async (relinkRequest: RelinkRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'relinkRequest' is not null or undefined
      assertParamExists('relink', 'relinkRequest', relinkRequest);
      const localVarPath = `/link/relink`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(relinkRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Exchange authorization code for token
     * @param {string} grantType
     * @param {string} code
     * @param {string} clientId
     * @param {string} redirectUri
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    token: async (
      grantType: string,
      code: string,
      clientId: string,
      redirectUri: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'grantType' is not null or undefined
      assertParamExists('token', 'grantType', grantType);
      // verify required parameter 'code' is not null or undefined
      assertParamExists('token', 'code', code);
      // verify required parameter 'clientId' is not null or undefined
      assertParamExists('token', 'clientId', clientId);
      // verify required parameter 'redirectUri' is not null or undefined
      assertParamExists('token', 'redirectUri', redirectUri);
      const localVarPath = `/auth/token`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new URLSearchParams();

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      if (grantType !== undefined) {
        localVarFormParams.set('grant_type', grantType as any);
      }

      if (code !== undefined) {
        localVarFormParams.set('code', code as any);
      }

      if (clientId !== undefined) {
        localVarFormParams.set('client_id', clientId as any);
      }

      if (redirectUri !== undefined) {
        localVarFormParams.set('redirect_uri', redirectUri as any);
      }

      localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = localVarFormParams.toString();

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LinkApi - functional programming interface
 * @export
 */
export const LinkApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = LinkApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new link
     * @param {LinkRequest} linkRequest Request body for starting a new Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createLink(
      linkRequest: LinkRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createLink(linkRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get the customization details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCustomization(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomizationDetails>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomization(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get a list of institutions
     * @param {string} [country] The country the institution belongs to
     * @param {Array<string>} [countries] The countries the institution belongs to
     * @param {string} [productsSupported] The products that this institution supports
     * @param {string} [institutionType] The type of institution
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listInstitutions(
      country?: string,
      countries?: Array<string>,
      productsSupported?: string,
      institutionType?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Institution>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listInstitutions(
        country,
        countries,
        productsSupported,
        institutionType,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Update an existing link
     * @param {RelinkRequest} relinkRequest Request body for updating Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async relink(
      relinkRequest: RelinkRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.relink(relinkRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Exchange authorization code for token
     * @param {string} grantType
     * @param {string} code
     * @param {string} clientId
     * @param {string} redirectUri
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async token(
      grantType: string,
      code: string,
      clientId: string,
      redirectUri: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessTokenResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.token(grantType, code, clientId, redirectUri, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * LinkApi - factory interface
 * @export
 */
export const LinkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = LinkApiFp(configuration);
  return {
    /**
     * Creates a new link
     * @param {LinkRequest} linkRequest Request body for starting a new Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLink(linkRequest: LinkRequest, options?: any): AxiosPromise<LinkResponse> {
      return localVarFp.createLink(linkRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Get the customization details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCustomization(options?: any): AxiosPromise<CustomizationDetails> {
      return localVarFp.getCustomization(options).then((request) => request(axios, basePath));
    },
    /**
     * Get a list of institutions
     * @param {string} [country] The country the institution belongs to
     * @param {Array<string>} [countries] The countries the institution belongs to
     * @param {string} [productsSupported] The products that this institution supports
     * @param {string} [institutionType] The type of institution
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listInstitutions(
      country?: string,
      countries?: Array<string>,
      productsSupported?: string,
      institutionType?: string,
      options?: any,
    ): AxiosPromise<Array<Institution>> {
      return localVarFp
        .listInstitutions(country, countries, productsSupported, institutionType, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update an existing link
     * @param {RelinkRequest} relinkRequest Request body for updating Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    relink(relinkRequest: RelinkRequest, options?: any): AxiosPromise<LinkResponse> {
      return localVarFp.relink(relinkRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Exchange authorization code for token
     * @param {string} grantType
     * @param {string} code
     * @param {string} clientId
     * @param {string} redirectUri
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    token(
      grantType: string,
      code: string,
      clientId: string,
      redirectUri: string,
      options?: any,
    ): AxiosPromise<AccessTokenResponse> {
      return localVarFp
        .token(grantType, code, clientId, redirectUri, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * LinkApi - interface
 * @export
 * @interface LinkApi
 */
export interface LinkApiInterface {
  /**
   * Creates a new link
   * @param {LinkRequest} linkRequest Request body for starting a new Link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApiInterface
   */
  createLink(linkRequest: LinkRequest, options?: AxiosRequestConfig): AxiosPromise<LinkResponse>;

  /**
   * Get the customization details
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApiInterface
   */
  getCustomization(options?: AxiosRequestConfig): AxiosPromise<CustomizationDetails>;

  /**
   * Get a list of institutions
   * @param {string} [country] The country the institution belongs to
   * @param {Array<string>} [countries] The countries the institution belongs to
   * @param {string} [productsSupported] The products that this institution supports
   * @param {string} [institutionType] The type of institution
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApiInterface
   */
  listInstitutions(
    country?: string,
    countries?: Array<string>,
    productsSupported?: string,
    institutionType?: string,
    options?: AxiosRequestConfig,
  ): AxiosPromise<Array<Institution>>;

  /**
   * Update an existing link
   * @param {RelinkRequest} relinkRequest Request body for updating Link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApiInterface
   */
  relink(relinkRequest: RelinkRequest, options?: AxiosRequestConfig): AxiosPromise<LinkResponse>;

  /**
   * Exchange authorization code for token
   * @param {string} grantType
   * @param {string} code
   * @param {string} clientId
   * @param {string} redirectUri
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApiInterface
   */
  token(
    grantType: string,
    code: string,
    clientId: string,
    redirectUri: string,
    options?: AxiosRequestConfig,
  ): AxiosPromise<AccessTokenResponse>;
}

/**
 * LinkApi - object-oriented interface
 * @export
 * @class LinkApi
 * @extends {BaseAPI}
 */
export class LinkApi extends BaseAPI implements LinkApiInterface {
  /**
   * Creates a new link
   * @param {LinkRequest} linkRequest Request body for starting a new Link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApi
   */
  public createLink(linkRequest: LinkRequest, options?: AxiosRequestConfig) {
    return LinkApiFp(this.configuration)
      .createLink(linkRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get the customization details
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApi
   */
  public getCustomization(options?: AxiosRequestConfig) {
    return LinkApiFp(this.configuration)
      .getCustomization(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of institutions
   * @param {string} [country] The country the institution belongs to
   * @param {Array<string>} [countries] The countries the institution belongs to
   * @param {string} [productsSupported] The products that this institution supports
   * @param {string} [institutionType] The type of institution
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApi
   */
  public listInstitutions(
    country?: string,
    countries?: Array<string>,
    productsSupported?: string,
    institutionType?: string,
    options?: AxiosRequestConfig,
  ) {
    return LinkApiFp(this.configuration)
      .listInstitutions(country, countries, productsSupported, institutionType, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update an existing link
   * @param {RelinkRequest} relinkRequest Request body for updating Link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApi
   */
  public relink(relinkRequest: RelinkRequest, options?: AxiosRequestConfig) {
    return LinkApiFp(this.configuration)
      .relink(relinkRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Exchange authorization code for token
   * @param {string} grantType
   * @param {string} code
   * @param {string} clientId
   * @param {string} redirectUri
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApi
   */
  public token(grantType: string, code: string, clientId: string, redirectUri: string, options?: AxiosRequestConfig) {
    return LinkApiFp(this.configuration)
      .token(grantType, code, clientId, redirectUri, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * LoginIdentityApi - axios parameter creator
 * @export
 */
export const LoginIdentityApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Delete a specific loginIdentity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLoginIdentity: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/login_identity`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * generate a link token that can be used to create link
     * @param {LinkTokenRequest} linkTokenRequest token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateLinkToken: async (
      linkTokenRequest: LinkTokenRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'linkTokenRequest' is not null or undefined
      assertParamExists('generateLinkToken', 'linkTokenRequest', linkTokenRequest);
      const localVarPath = `/link/token`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(linkTokenRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a specific account\'s information
     * @param {string} accountId The account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccount: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('getAccount', 'accountId', accountId);
      const localVarPath = `/accounts/{accountId}`.replace(`{${'accountId'}}`, encodeURIComponent(String(accountId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', ['account'], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the account number for a specific account
     * @param {string} accountId The account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccountNumber: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('getAccountNumber', 'accountId', accountId);
      const localVarPath = `/account_numbers/{accountId}`.replace(
        `{${'accountId'}}`,
        encodeURIComponent(String(accountId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the balance history for a specific account
     * @param {string} accountId The account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBalanceHistory: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('getBalanceHistory', 'accountId', accountId);
      const localVarPath = `/balance_history/{accountId}`.replace(
        `{${'accountId'}}`,
        encodeURIComponent(String(accountId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * \\[BETA] Get a list of identity data for a given login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentity: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/identity`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a specific loginIdentity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoginIdentity: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/login_identity`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Download statement
     * @param {string} statementId The statement id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatement: async (statementId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'statementId' is not null or undefined
      assertParamExists('getStatement', 'statementId', statementId);
      const localVarPath = `/statements/{statementId}`.replace(
        `{${'statementId'}}`,
        encodeURIComponent(String(statementId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get statement link for download
     * @param {string} statementId The statement id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatementLink: async (statementId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'statementId' is not null or undefined
      assertParamExists('getStatementLink', 'statementId', statementId);
      const localVarPath = `/statement_links/{statementId}`.replace(
        `{${'statementId'}}`,
        encodeURIComponent(String(statementId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get list of available statements
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatements: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/statements`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of accounts for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAccounts: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/accounts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', ['account'], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of transactions for a particular account. The transactions are returned in sorted order, with the most recent one appearing first.
     * @param {string} accountId The account id (ULID, example - 01EP4A1MZDHKETZFRPF0K62S6S)
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTransactionsByAccountId: async (
      accountId: string,
      offset?: number,
      limit?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('listTransactionsByAccountId', 'accountId', accountId);
      const localVarPath = `/transactions/{accountId}`.replace(
        `{${'accountId'}}`,
        encodeURIComponent(String(accountId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', ['transaction'], configuration);

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of transactions for a login identity. The transactions are returned in sorted order, with the most recent one appearing first.
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTransactionsByLoginIdentityId: async (
      offset?: number,
      limit?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/transactions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', ['transaction'], configuration);

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a refresh job for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshLoginIdentity: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/login_identity/refresh`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LoginIdentityApi - functional programming interface
 * @export
 */
export const LoginIdentityApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = LoginIdentityApiAxiosParamCreator(configuration);
  return {
    /**
     * Delete a specific loginIdentity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteLoginIdentity(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteLoginIdentityResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLoginIdentity(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * generate a link token that can be used to create link
     * @param {LinkTokenRequest} linkTokenRequest token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async generateLinkToken(
      linkTokenRequest: LinkTokenRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkTokenResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.generateLinkToken(linkTokenRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get a specific account\'s information
     * @param {string} accountId The account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAccount(
      accountId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAccountResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(accountId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get the account number for a specific account
     * @param {string} accountId The account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAccountNumber(
      accountId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAccountNumberResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountNumber(accountId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get the balance history for a specific account
     * @param {string} accountId The account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBalanceHistory(
      accountId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBalanceHistoryResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBalanceHistory(accountId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * \\[BETA] Get a list of identity data for a given login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getIdentity(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetIdentityResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentity(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get a specific loginIdentity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLoginIdentity(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLoginIdentityByIdResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLoginIdentity(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Download statement
     * @param {string} statementId The statement id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStatement(
      statementId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStatement(statementId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get statement link for download
     * @param {string} statementId The statement id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStatementLink(
      statementId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStatementLinkResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStatementLink(statementId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get list of available statements
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStatements(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStatementsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStatements(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get a list of accounts for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listAccounts(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAccountsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listAccounts(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get a list of transactions for a particular account. The transactions are returned in sorted order, with the most recent one appearing first.
     * @param {string} accountId The account id (ULID, example - 01EP4A1MZDHKETZFRPF0K62S6S)
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listTransactionsByAccountId(
      accountId: string,
      offset?: number,
      limit?: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListTransactionsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listTransactionsByAccountId(
        accountId,
        offset,
        limit,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get a list of transactions for a login identity. The transactions are returned in sorted order, with the most recent one appearing first.
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listTransactionsByLoginIdentityId(
      offset?: number,
      limit?: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListTransactionsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listTransactionsByLoginIdentityId(
        offset,
        limit,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Create a refresh job for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async refreshLoginIdentity(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.refreshLoginIdentity(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * LoginIdentityApi - factory interface
 * @export
 */
export const LoginIdentityApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = LoginIdentityApiFp(configuration);
  return {
    /**
     * Delete a specific loginIdentity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLoginIdentity(options?: any): AxiosPromise<DeleteLoginIdentityResponse> {
      return localVarFp.deleteLoginIdentity(options).then((request) => request(axios, basePath));
    },
    /**
     * generate a link token that can be used to create link
     * @param {LinkTokenRequest} linkTokenRequest token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateLinkToken(linkTokenRequest: LinkTokenRequest, options?: any): AxiosPromise<LinkTokenResponse> {
      return localVarFp.generateLinkToken(linkTokenRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Get a specific account\'s information
     * @param {string} accountId The account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccount(accountId: string, options?: any): AxiosPromise<GetAccountResponse> {
      return localVarFp.getAccount(accountId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get the account number for a specific account
     * @param {string} accountId The account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccountNumber(accountId: string, options?: any): AxiosPromise<GetAccountNumberResponse> {
      return localVarFp.getAccountNumber(accountId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get the balance history for a specific account
     * @param {string} accountId The account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBalanceHistory(accountId: string, options?: any): AxiosPromise<GetBalanceHistoryResponse> {
      return localVarFp.getBalanceHistory(accountId, options).then((request) => request(axios, basePath));
    },
    /**
     * \\[BETA] Get a list of identity data for a given login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentity(options?: any): AxiosPromise<GetIdentityResponse> {
      return localVarFp.getIdentity(options).then((request) => request(axios, basePath));
    },
    /**
     * Get a specific loginIdentity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoginIdentity(options?: any): AxiosPromise<GetLoginIdentityByIdResponse> {
      return localVarFp.getLoginIdentity(options).then((request) => request(axios, basePath));
    },
    /**
     * Download statement
     * @param {string} statementId The statement id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatement(statementId: string, options?: any): AxiosPromise<void> {
      return localVarFp.getStatement(statementId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get statement link for download
     * @param {string} statementId The statement id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatementLink(statementId: string, options?: any): AxiosPromise<GetStatementLinkResponse> {
      return localVarFp.getStatementLink(statementId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get list of available statements
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatements(options?: any): AxiosPromise<GetStatementsResponse> {
      return localVarFp.getStatements(options).then((request) => request(axios, basePath));
    },
    /**
     * Get a list of accounts for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAccounts(options?: any): AxiosPromise<ListAccountsResponse> {
      return localVarFp.listAccounts(options).then((request) => request(axios, basePath));
    },
    /**
     * Get a list of transactions for a particular account. The transactions are returned in sorted order, with the most recent one appearing first.
     * @param {string} accountId The account id (ULID, example - 01EP4A1MZDHKETZFRPF0K62S6S)
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTransactionsByAccountId(
      accountId: string,
      offset?: number,
      limit?: number,
      options?: any,
    ): AxiosPromise<ListTransactionsResponse> {
      return localVarFp
        .listTransactionsByAccountId(accountId, offset, limit, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a list of transactions for a login identity. The transactions are returned in sorted order, with the most recent one appearing first.
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTransactionsByLoginIdentityId(
      offset?: number,
      limit?: number,
      options?: any,
    ): AxiosPromise<ListTransactionsResponse> {
      return localVarFp
        .listTransactionsByLoginIdentityId(offset, limit, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a refresh job for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshLoginIdentity(options?: any): AxiosPromise<void> {
      return localVarFp.refreshLoginIdentity(options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * LoginIdentityApi - interface
 * @export
 * @interface LoginIdentityApi
 */
export interface LoginIdentityApiInterface {
  /**
   * Delete a specific loginIdentity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  deleteLoginIdentity(options?: AxiosRequestConfig): AxiosPromise<DeleteLoginIdentityResponse>;

  /**
   * generate a link token that can be used to create link
   * @param {LinkTokenRequest} linkTokenRequest token request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  generateLinkToken(linkTokenRequest: LinkTokenRequest, options?: AxiosRequestConfig): AxiosPromise<LinkTokenResponse>;

  /**
   * Get a specific account\'s information
   * @param {string} accountId The account id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  getAccount(accountId: string, options?: AxiosRequestConfig): AxiosPromise<GetAccountResponse>;

  /**
   * Get the account number for a specific account
   * @param {string} accountId The account id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  getAccountNumber(accountId: string, options?: AxiosRequestConfig): AxiosPromise<GetAccountNumberResponse>;

  /**
   * Get the balance history for a specific account
   * @param {string} accountId The account id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  getBalanceHistory(accountId: string, options?: AxiosRequestConfig): AxiosPromise<GetBalanceHistoryResponse>;

  /**
   * \\[BETA] Get a list of identity data for a given login identity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  getIdentity(options?: AxiosRequestConfig): AxiosPromise<GetIdentityResponse>;

  /**
   * Get a specific loginIdentity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  getLoginIdentity(options?: AxiosRequestConfig): AxiosPromise<GetLoginIdentityByIdResponse>;

  /**
   * Download statement
   * @param {string} statementId The statement id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  getStatement(statementId: string, options?: AxiosRequestConfig): AxiosPromise<void>;

  /**
   * Get statement link for download
   * @param {string} statementId The statement id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  getStatementLink(statementId: string, options?: AxiosRequestConfig): AxiosPromise<GetStatementLinkResponse>;

  /**
   * Get list of available statements
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  getStatements(options?: AxiosRequestConfig): AxiosPromise<GetStatementsResponse>;

  /**
   * Get a list of accounts for a login identity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  listAccounts(options?: AxiosRequestConfig): AxiosPromise<ListAccountsResponse>;

  /**
   * Get a list of transactions for a particular account. The transactions are returned in sorted order, with the most recent one appearing first.
   * @param {string} accountId The account id (ULID, example - 01EP4A1MZDHKETZFRPF0K62S6S)
   * @param {number} [offset] default is 0
   * @param {number} [limit] default is 500, max is 1000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  listTransactionsByAccountId(
    accountId: string,
    offset?: number,
    limit?: number,
    options?: AxiosRequestConfig,
  ): AxiosPromise<ListTransactionsResponse>;

  /**
   * Get a list of transactions for a login identity. The transactions are returned in sorted order, with the most recent one appearing first.
   * @param {number} [offset] default is 0
   * @param {number} [limit] default is 500, max is 1000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  listTransactionsByLoginIdentityId(
    offset?: number,
    limit?: number,
    options?: AxiosRequestConfig,
  ): AxiosPromise<ListTransactionsResponse>;

  /**
   * Create a refresh job for a login identity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  refreshLoginIdentity(options?: AxiosRequestConfig): AxiosPromise<void>;
}

/**
 * LoginIdentityApi - object-oriented interface
 * @export
 * @class LoginIdentityApi
 * @extends {BaseAPI}
 */
export class LoginIdentityApi extends BaseAPI implements LoginIdentityApiInterface {
  /**
   * Delete a specific loginIdentity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public deleteLoginIdentity(options?: AxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .deleteLoginIdentity(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * generate a link token that can be used to create link
   * @param {LinkTokenRequest} linkTokenRequest token request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public generateLinkToken(linkTokenRequest: LinkTokenRequest, options?: AxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .generateLinkToken(linkTokenRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a specific account\'s information
   * @param {string} accountId The account id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public getAccount(accountId: string, options?: AxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .getAccount(accountId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get the account number for a specific account
   * @param {string} accountId The account id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public getAccountNumber(accountId: string, options?: AxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .getAccountNumber(accountId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get the balance history for a specific account
   * @param {string} accountId The account id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public getBalanceHistory(accountId: string, options?: AxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .getBalanceHistory(accountId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * \\[BETA] Get a list of identity data for a given login identity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public getIdentity(options?: AxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .getIdentity(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a specific loginIdentity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public getLoginIdentity(options?: AxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .getLoginIdentity(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Download statement
   * @param {string} statementId The statement id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public getStatement(statementId: string, options?: AxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .getStatement(statementId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get statement link for download
   * @param {string} statementId The statement id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public getStatementLink(statementId: string, options?: AxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .getStatementLink(statementId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get list of available statements
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public getStatements(options?: AxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .getStatements(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of accounts for a login identity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public listAccounts(options?: AxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .listAccounts(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of transactions for a particular account. The transactions are returned in sorted order, with the most recent one appearing first.
   * @param {string} accountId The account id (ULID, example - 01EP4A1MZDHKETZFRPF0K62S6S)
   * @param {number} [offset] default is 0
   * @param {number} [limit] default is 500, max is 1000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public listTransactionsByAccountId(accountId: string, offset?: number, limit?: number, options?: AxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .listTransactionsByAccountId(accountId, offset, limit, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of transactions for a login identity. The transactions are returned in sorted order, with the most recent one appearing first.
   * @param {number} [offset] default is 0
   * @param {number} [limit] default is 500, max is 1000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public listTransactionsByLoginIdentityId(offset?: number, limit?: number, options?: AxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .listTransactionsByLoginIdentityId(offset, limit, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a refresh job for a login identity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public refreshLoginIdentity(options?: AxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .refreshLoginIdentity(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PublicApi - axios parameter creator
 * @export
 */
export const PublicApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Callback url to get the oauth authorization token
     * @param {string} state The state of the client when oauth was initialized
     * @param {string} [code] The authorization code generated by the Oauth provider
     * @param {string} [error] error
     * @param {string} [errorDescription] error description
     * @param {string} [errorDetails] error details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authCallback: async (
      state: string,
      code?: string,
      error?: string,
      errorDescription?: string,
      errorDetails?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'state' is not null or undefined
      assertParamExists('authCallback', 'state', state);
      const localVarPath = `/auth/callback`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', ['test'], configuration);

      if (state !== undefined) {
        localVarQueryParameter['state'] = state;
      }

      if (code !== undefined) {
        localVarQueryParameter['code'] = code;
      }

      if (error !== undefined) {
        localVarQueryParameter['error'] = error;
      }

      if (errorDescription !== undefined) {
        localVarQueryParameter['error_description'] = errorDescription;
      }

      if (errorDetails !== undefined) {
        localVarQueryParameter['error_details'] = errorDetails;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * generate an access_token
     * @param {TokenRequest} [tokenRequest] token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateCustomerAccessToken: async (
      tokenRequest?: TokenRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/auth/customer/token`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', ['test'], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(tokenRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PublicApi - functional programming interface
 * @export
 */
export const PublicApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PublicApiAxiosParamCreator(configuration);
  return {
    /**
     * Callback url to get the oauth authorization token
     * @param {string} state The state of the client when oauth was initialized
     * @param {string} [code] The authorization code generated by the Oauth provider
     * @param {string} [error] error
     * @param {string} [errorDescription] error description
     * @param {string} [errorDetails] error details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authCallback(
      state: string,
      code?: string,
      error?: string,
      errorDescription?: string,
      errorDetails?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RedirectUriResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.authCallback(
        state,
        code,
        error,
        errorDescription,
        errorDetails,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * generate an access_token
     * @param {TokenRequest} [tokenRequest] token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async generateCustomerAccessToken(
      tokenRequest?: TokenRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.generateCustomerAccessToken(tokenRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * PublicApi - factory interface
 * @export
 */
export const PublicApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = PublicApiFp(configuration);
  return {
    /**
     * Callback url to get the oauth authorization token
     * @param {string} state The state of the client when oauth was initialized
     * @param {string} [code] The authorization code generated by the Oauth provider
     * @param {string} [error] error
     * @param {string} [errorDescription] error description
     * @param {string} [errorDetails] error details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authCallback(
      state: string,
      code?: string,
      error?: string,
      errorDescription?: string,
      errorDetails?: string,
      options?: any,
    ): AxiosPromise<RedirectUriResponse> {
      return localVarFp
        .authCallback(state, code, error, errorDescription, errorDetails, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * generate an access_token
     * @param {TokenRequest} [tokenRequest] token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateCustomerAccessToken(tokenRequest?: TokenRequest, options?: any): AxiosPromise<TokenResponse> {
      return localVarFp.generateCustomerAccessToken(tokenRequest, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * PublicApi - interface
 * @export
 * @interface PublicApi
 */
export interface PublicApiInterface {
  /**
   * Callback url to get the oauth authorization token
   * @param {string} state The state of the client when oauth was initialized
   * @param {string} [code] The authorization code generated by the Oauth provider
   * @param {string} [error] error
   * @param {string} [errorDescription] error description
   * @param {string} [errorDetails] error details
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PublicApiInterface
   */
  authCallback(
    state: string,
    code?: string,
    error?: string,
    errorDescription?: string,
    errorDetails?: string,
    options?: AxiosRequestConfig,
  ): AxiosPromise<RedirectUriResponse>;

  /**
   * generate an access_token
   * @param {TokenRequest} [tokenRequest] token request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PublicApiInterface
   */
  generateCustomerAccessToken(tokenRequest?: TokenRequest, options?: AxiosRequestConfig): AxiosPromise<TokenResponse>;
}

/**
 * PublicApi - object-oriented interface
 * @export
 * @class PublicApi
 * @extends {BaseAPI}
 */
export class PublicApi extends BaseAPI implements PublicApiInterface {
  /**
   * Callback url to get the oauth authorization token
   * @param {string} state The state of the client when oauth was initialized
   * @param {string} [code] The authorization code generated by the Oauth provider
   * @param {string} [error] error
   * @param {string} [errorDescription] error description
   * @param {string} [errorDetails] error details
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PublicApi
   */
  public authCallback(
    state: string,
    code?: string,
    error?: string,
    errorDescription?: string,
    errorDetails?: string,
    options?: AxiosRequestConfig,
  ) {
    return PublicApiFp(this.configuration)
      .authCallback(state, code, error, errorDescription, errorDetails, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * generate an access_token
   * @param {TokenRequest} [tokenRequest] token request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PublicApi
   */
  public generateCustomerAccessToken(tokenRequest?: TokenRequest, options?: AxiosRequestConfig) {
    return PublicApiFp(this.configuration)
      .generateCustomerAccessToken(tokenRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
