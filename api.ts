/* tslint:disable */
/* eslint-disable */
/**
 * Finverse Public
 * Documentation of the early finverse services
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: info@finverse.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface AccessTokenResponse
 */
export interface AccessTokenResponse {
  /**
   *
   * @type {string}
   * @memberof AccessTokenResponse
   */
  access_token: string;
  /**
   *
   * @type {string}
   * @memberof AccessTokenResponse
   */
  login_identity_id: string;
  /**
   *
   * @type {string}
   * @memberof AccessTokenResponse
   */
  token_type: string;
  /**
   * seconds
   * @type {number}
   * @memberof AccessTokenResponse
   */
  expires_in: number;
  /**
   *
   * @type {string}
   * @memberof AccessTokenResponse
   */
  refresh_token: string;
  /**
   *
   * @type {string}
   * @memberof AccessTokenResponse
   */
  issued_at: string;
}
/**
 *
 * @export
 * @interface Account
 */
export interface Account {
  /**
   *
   * @type {string}
   * @memberof Account
   */
  account_id: string;
  /**
   * The SHA3-256 hash of the account number, salted with the loginIdentityId
   * @type {string}
   * @memberof Account
   */
  group_id: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  account_holder_name?: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  account_name: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  account_nickname?: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  account_sub_type?: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  account_number_masked?: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  country?: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  updated_at?: string;
  /**
   *
   * @type {string}
   * @memberof Account
   */
  account_currency?: string;
  /**
   *
   * @type {CurrencyAmount}
   * @memberof Account
   */
  balance?: CurrencyAmount;
  /**
   *
   * @type {CurrencyAmount}
   * @memberof Account
   */
  statement_balance?: CurrencyAmount;
  /**
   *
   * @type {boolean}
   * @memberof Account
   */
  is_parent: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Account
   */
  is_closed: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Account
   */
  is_excluded: boolean;
  /**
   *
   * @type {AccountType}
   * @memberof Account
   */
  account_type?: AccountType;
}
/**
 *
 * @export
 * @interface AccountNumber
 */
export interface AccountNumber {
  /**
   *
   * @type {string}
   * @memberof AccountNumber
   */
  account_id: string;
  /**
   *
   * @type {string}
   * @memberof AccountNumber
   */
  number?: string;
  /**
   *
   * @type {string}
   * @memberof AccountNumber
   */
  raw: string;
}
/**
 *
 * @export
 * @interface AccountType
 */
export interface AccountType {
  /**
   *
   * @type {string}
   * @memberof AccountType
   */
  type?: AccountTypeTypeEnum;
  /**
   *
   * @type {string}
   * @memberof AccountType
   */
  subtype?: AccountTypeSubtypeEnum;
}

export const AccountTypeTypeEnum = {
  Deposit: 'DEPOSIT',
  Card: 'CARD',
  Investment: 'INVESTMENT',
  Loan: 'LOAN',
  Unknown: 'UNKNOWN',
} as const;

export type AccountTypeTypeEnum = (typeof AccountTypeTypeEnum)[keyof typeof AccountTypeTypeEnum];
export const AccountTypeSubtypeEnum = {
  Current: 'CURRENT',
  Savings: 'SAVINGS',
  TimeDeposit: 'TIME_DEPOSIT',
  Other: 'OTHER',
  CreditCard: 'CREDIT_CARD',
  DebitCard: 'DEBIT_CARD',
  Securities: 'SECURITIES',
  Funds: 'FUNDS',
  Stocks: 'STOCKS',
  Bonds: 'BONDS',
  Mortgage: 'MORTGAGE',
  PersonalLoan: 'PERSONAL_LOAN',
  RevolvingLoan: 'REVOLVING_LOAN',
  Unknown: 'UNKNOWN',
} as const;

export type AccountTypeSubtypeEnum = (typeof AccountTypeSubtypeEnum)[keyof typeof AccountTypeSubtypeEnum];

/**
 *
 * @export
 * @interface ActionRequest
 */
export interface ActionRequest {
  /**
   *
   * @type {EncryptedPayload}
   * @memberof ActionRequest
   */
  encrypted_credentials: EncryptedPayload;
  /**
   * The action id
   * @type {string}
   * @memberof ActionRequest
   */
  action_id: string;
}
/**
 *
 * @export
 * @interface AllProductStatus
 */
export interface AllProductStatus {
  /**
   *
   * @type {ProductStatus}
   * @memberof AllProductStatus
   */
  accounts?: ProductStatus;
  /**
   *
   * @type {ProductStatus}
   * @memberof AllProductStatus
   */
  online_transactions?: ProductStatus;
  /**
   *
   * @type {ProductStatus}
   * @memberof AllProductStatus
   */
  statements?: ProductStatus;
  /**
   *
   * @type {ProductStatus}
   * @memberof AllProductStatus
   */
  historical_transactions?: ProductStatus;
  /**
   *
   * @type {ProductStatus}
   * @memberof AllProductStatus
   */
  account_numbers?: ProductStatus;
  /**
   *
   * @type {ProductStatus}
   * @memberof AllProductStatus
   */
  identity?: ProductStatus;
  /**
   *
   * @type {ProductStatus}
   * @memberof AllProductStatus
   */
  balance_history?: ProductStatus;
  /**
   *
   * @type {ProductStatus}
   * @memberof AllProductStatus
   */
  payments?: ProductStatus;
  /**
   *
   * @type {ProductStatus}
   * @memberof AllProductStatus
   */
  income_estimation?: ProductStatus;
  /**
   *
   * @type {ProductStatus}
   * @memberof AllProductStatus
   */
  card_details?: ProductStatus;
}
/**
 *
 * @export
 * @interface ApiLinkRequest
 */
export interface ApiLinkRequest {
  /**
   *
   * @type {string}
   * @memberof ApiLinkRequest
   */
  institution_id: string;
  /**
   * Identifier for end user
   * @type {string}
   * @memberof ApiLinkRequest
   */
  user_id: string;
  /**
   * this is a mandatory field
   * @type {boolean}
   * @memberof ApiLinkRequest
   */
  consent: boolean | null;
  /**
   * products that are requested
   * @type {Array<string>}
   * @memberof ApiLinkRequest
   */
  products_requested: Array<string>;
  /**
   *
   * @type {boolean}
   * @memberof ApiLinkRequest
   */
  store_credentials: boolean;
  /**
   *
   * @type {EncryptedPayload}
   * @memberof ApiLinkRequest
   */
  encrypted_credentials: EncryptedPayload;
  /**
   *
   * @type {string}
   * @memberof ApiLinkRequest
   */
  payment_instruction_id?: string;
}
/**
 *
 * @export
 * @interface ApiRelinkRequest
 */
export interface ApiRelinkRequest {
  /**
   *
   * @type {boolean}
   * @memberof ApiRelinkRequest
   */
  store_credential?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ApiRelinkRequest
   */
  consent: boolean;
  /**
   *
   * @type {EncryptedPayload}
   * @memberof ApiRelinkRequest
   */
  encrypted_credentials: EncryptedPayload;
}
/**
 *
 * @export
 * @interface AuthChecklistFactor
 */
export interface AuthChecklistFactor {
  /**
   * Type of authorization factor
   * @type {string}
   * @memberof AuthChecklistFactor
   */
  type: AuthChecklistFactorTypeEnum;
  /**
   * Allows grouping similar checklist item types together
   * @type {string}
   * @memberof AuthChecklistFactor
   */
  group_id: string;
  /**
   * Indicates whether authorization factor is known to be required at this time.  Possible values are YES, NO, OPTIONAL
   * @type {string}
   * @memberof AuthChecklistFactor
   */
  required: AuthChecklistFactorRequiredEnum;
  /**
   * Helper text that applies to a specific checklist item
   * @type {string}
   * @memberof AuthChecklistFactor
   */
  helper_text?: string;
  /**
   * Array of the options accepted for a specific authorization factor
   * @type {Array<AuthChecklistOptions>}
   * @memberof AuthChecklistFactor
   */
  options: Array<AuthChecklistOptions>;
}

export const AuthChecklistFactorTypeEnum = {
  AccountIdentification: 'ACCOUNT_IDENTIFICATION',
  UserIdentification: 'USER_IDENTIFICATION',
  EnduserConsent: 'ENDUSER_CONSENT',
  AccountholderAuthentication: 'ACCOUNTHOLDER_AUTHENTICATION',
} as const;

export type AuthChecklistFactorTypeEnum =
  (typeof AuthChecklistFactorTypeEnum)[keyof typeof AuthChecklistFactorTypeEnum];
export const AuthChecklistFactorRequiredEnum = {
  Yes: 'YES',
  No: 'NO',
  Optional: 'OPTIONAL',
} as const;

export type AuthChecklistFactorRequiredEnum =
  (typeof AuthChecklistFactorRequiredEnum)[keyof typeof AuthChecklistFactorRequiredEnum];

/**
 *
 * @export
 * @interface AuthChecklistOptions
 */
export interface AuthChecklistOptions {
  /**
   * Name of authorization factor. Possible values are INSTITUTION_CREDENTIALS_LOGIN, INSTITUTION_OAUTH_LOGIN,
   * @type {string}
   * @memberof AuthChecklistOptions
   */
  name: AuthChecklistOptionsNameEnum;
  /**
   * Timestamp in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ) for when the authorization factor was submitted to Finverse
   * @type {string}
   * @memberof AuthChecklistOptions
   */
  submitted_at?: string | null;
  /**
   * Indicates who submitted the authorization factor to Finverse. Possible values are CUSTOMER_APP, FINVERSE_LINK
   * @type {string}
   * @memberof AuthChecklistOptions
   */
  submitted_by?: AuthChecklistOptionsSubmittedByEnum;
  /**
   * Redirect to bank for authentication
   * @type {string}
   * @memberof AuthChecklistOptions
   */
  redirect_url?: string;
}

export const AuthChecklistOptionsNameEnum = {
  CredentialsLogin: 'INSTITUTION_CREDENTIALS_LOGIN',
  OauthLogin: 'INSTITUTION_OAUTH_LOGIN',
} as const;

export type AuthChecklistOptionsNameEnum =
  (typeof AuthChecklistOptionsNameEnum)[keyof typeof AuthChecklistOptionsNameEnum];
export const AuthChecklistOptionsSubmittedByEnum = {
  CustomerApp: 'CUSTOMER_APP',
  FinverseLink: 'FINVERSE_LINK',
} as const;

export type AuthChecklistOptionsSubmittedByEnum =
  (typeof AuthChecklistOptionsSubmittedByEnum)[keyof typeof AuthChecklistOptionsSubmittedByEnum];

/**
 *
 * @export
 * @interface AuthorizeMandateRequest
 */
export interface AuthorizeMandateRequest {
  /**
   * Whether a consent was provided by the enduser to authorize a mandate
   * @type {boolean}
   * @memberof AuthorizeMandateRequest
   */
  enduser_consent: boolean;
}
/**
 *
 * @export
 * @interface BadRequestModel
 */
export interface BadRequestModel {
  /**
   *
   * @type {BadRequestModelError}
   * @memberof BadRequestModel
   */
  error?: BadRequestModelError;
}
/**
 *
 * @export
 * @interface BadRequestModelError
 */
export interface BadRequestModelError {
  /**
   *
   * @type {number}
   * @memberof BadRequestModelError
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof BadRequestModelError
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof BadRequestModelError
   */
  message?: string;
  /**
   * A link to visit for further action
   * @type {string}
   * @memberof BadRequestModelError
   */
  link?: string;
}
/**
 *
 * @export
 * @interface BadRequestModelV2
 */
export interface BadRequestModelV2 {
  /**
   *
   * @type {BadRequestModelV2Error}
   * @memberof BadRequestModelV2
   */
  error?: BadRequestModelV2Error;
}
/**
 *
 * @export
 * @interface BadRequestModelV2Error
 */
export interface BadRequestModelV2Error {
  /**
   * The error type
   * @type {string}
   * @memberof BadRequestModelV2Error
   */
  type: BadRequestModelV2ErrorTypeEnum;
  /**
   *
   * @type {string}
   * @memberof BadRequestModelV2Error
   */
  error_code: string;
  /**
   *
   * @type {number}
   * @memberof BadRequestModelV2Error
   */
  code: number;
  /**
   *
   * @type {string}
   * @memberof BadRequestModelV2Error
   */
  message: string;
  /**
   *
   * @type {string}
   * @memberof BadRequestModelV2Error
   */
  details?: string;
  /**
   * The request_id provided in the request header
   * @type {string}
   * @memberof BadRequestModelV2Error
   */
  request_id: string;
}

export const BadRequestModelV2ErrorTypeEnum = {
  LinkError: 'LINK_ERROR',
  ApiError: 'API_ERROR',
} as const;

export type BadRequestModelV2ErrorTypeEnum =
  (typeof BadRequestModelV2ErrorTypeEnum)[keyof typeof BadRequestModelV2ErrorTypeEnum];

/**
 *
 * @export
 * @interface BalanceHistory
 */
export interface BalanceHistory {
  /**
   * The date the balance was recorded
   * @type {string}
   * @memberof BalanceHistory
   */
  date: string;
  /**
   * The end of day balance for this account on this specific date
   * @type {number}
   * @memberof BalanceHistory
   */
  amount: number;
  /**
   * The currency the balance
   * @type {string}
   * @memberof BalanceHistory
   */
  currency: string;
}
/**
 *
 * @export
 * @interface CardAccount
 */
export interface CardAccount {
  /**
   * Account this card is associated with
   * @type {string}
   * @memberof CardAccount
   */
  account_id?: string;
  /**
   *
   * @type {string}
   * @memberof CardAccount
   */
  account_name?: string;
  /**
   * Masked Account number of the card account
   * @type {string}
   * @memberof CardAccount
   */
  account_number_masked?: string;
  /**
   *
   * @type {AccountType}
   * @memberof CardAccount
   */
  account_type?: AccountType;
  /**
   * The statement payment due date
   * @type {string}
   * @memberof CardAccount
   */
  statement_payment_due_date?: string;
  /**
   * The next payment due date
   * @type {string}
   * @memberof CardAccount
   */
  next_payment_due_date?: string;
  /**
   * The statement date
   * @type {string}
   * @memberof CardAccount
   */
  statement_date?: string;
  /**
   * The date of the last payment
   * @type {string}
   * @memberof CardAccount
   */
  last_payment_date?: string;
  /**
   *
   * @type {CurrencyAmount}
   * @memberof CardAccount
   */
  last_payment_amount?: CurrencyAmount;
  /**
   *
   * @type {CurrencyAmount}
   * @memberof CardAccount
   */
  current_balance?: CurrencyAmount;
  /**
   *
   * @type {CurrencyAmount}
   * @memberof CardAccount
   */
  payment_due_amount?: CurrencyAmount;
  /**
   *
   * @type {CurrencyAmount}
   * @memberof CardAccount
   */
  statement_due_amount?: CurrencyAmount;
  /**
   *
   * @type {CurrencyAmount}
   * @memberof CardAccount
   */
  total_credit_limit?: CurrencyAmount;
  /**
   *
   * @type {CurrencyAmount}
   * @memberof CardAccount
   */
  available_credit_limit?: CurrencyAmount;
  /**
   *
   * @type {CurrencyAmount}
   * @memberof CardAccount
   */
  minimum_payment_due?: CurrencyAmount;
  /**
   *
   * @type {Array<GenericAmount>}
   * @memberof CardAccount
   */
  rewards_balances?: Array<GenericAmount>;
  /**
   *
   * @type {string}
   * @memberof CardAccount
   */
  updated_at?: string;
}
/**
 *
 * @export
 * @interface CardDetails
 */
export interface CardDetails {
  /**
   *
   * @type {Array<CardAccount>}
   * @memberof CardDetails
   */
  card_accounts?: Array<CardAccount>;
  /**
   *
   * @type {CardTotal}
   * @memberof CardDetails
   */
  card_total?: CardTotal;
}
/**
 *
 * @export
 * @interface CardTotal
 */
export interface CardTotal {
  /**
   *
   * @type {CurrencyAmount}
   * @memberof CardTotal
   */
  current_balance?: CurrencyAmount;
  /**
   *
   * @type {CurrencyAmount}
   * @memberof CardTotal
   */
  payment_due_amount?: CurrencyAmount;
  /**
   *
   * @type {CurrencyAmount}
   * @memberof CardTotal
   */
  statement_due_amount?: CurrencyAmount;
  /**
   *
   * @type {CurrencyAmount}
   * @memberof CardTotal
   */
  total_credit_limit?: CurrencyAmount;
  /**
   *
   * @type {CurrencyAmount}
   * @memberof CardTotal
   */
  available_credit_limit?: CurrencyAmount;
  /**
   *
   * @type {CurrencyAmount}
   * @memberof CardTotal
   */
  minimum_payment_due?: CurrencyAmount;
  /**
   *
   * @type {Array<GenericAmount>}
   * @memberof CardTotal
   */
  rewards_balances?: Array<GenericAmount>;
  /**
   *
   * @type {string}
   * @memberof CardTotal
   */
  updated_at?: string;
}
/**
 *
 * @export
 * @interface CategoryPredictions
 */
export interface CategoryPredictions {
  /**
   *
   * @type {Array<string>}
   * @memberof CategoryPredictions
   */
  categories?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof CategoryPredictions
   */
  source?: string;
  /**
   *
   * @type {string}
   * @memberof CategoryPredictions
   */
  source_id?: string;
}
/**
 *
 * @export
 * @interface CompositeStatementLink
 */
export interface CompositeStatementLink {
  /**
   * signedURL to download statement
   * @type {string}
   * @memberof CompositeStatementLink
   */
  url: string;
  /**
   * expiry of the signedURL
   * @type {string}
   * @memberof CompositeStatementLink
   */
  expiry: string;
}
/**
 *
 * @export
 * @interface ConfirmPaymentResponse
 */
export interface ConfirmPaymentResponse {
  /**
   *
   * @type {boolean}
   * @memberof ConfirmPaymentResponse
   */
  success: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ConfirmPaymentResponse
   */
  skip_autopay_consent: boolean;
}
/**
 *
 * @export
 * @interface CreateFpsTokenResponse
 */
export interface CreateFpsTokenResponse {
  /**
   *
   * @type {PaymentLinkTokenResponse}
   * @memberof CreateFpsTokenResponse
   */
  fps_token: PaymentLinkTokenResponse;
}
/**
 *
 * @export
 * @interface CreateMandateRequest
 */
export interface CreateMandateRequest {
  /**
   *
   * @type {MandateRecipientRequest}
   * @memberof CreateMandateRequest
   */
  recipient_account: MandateRecipientRequest;
  /**
   *
   * @type {CreateMandateSender}
   * @memberof CreateMandateRequest
   */
  sender: CreateMandateSender;
  /**
   *
   * @type {MandateDetails}
   * @memberof CreateMandateRequest
   */
  mandate_details: MandateDetails;
  /**
   * Additional attributes of the mandate in key:value format (e.g. mandate_internal_id: 1234). It supports up to 10 key:value pairs, whereas the key and value supports up to 50 and 500 characters respectively.
   * @type {{ [key: string]: string; }}
   * @memberof CreateMandateRequest
   */
  metadata?: { [key: string]: string };
}
/**
 *
 * @export
 * @interface CreateMandateResponse
 */
export interface CreateMandateResponse {
  /**
   * Timestamp in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
   * @type {string}
   * @memberof CreateMandateResponse
   */
  created_at?: string;
  /**
   * Timestamp in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
   * @type {string}
   * @memberof CreateMandateResponse
   */
  updated_at: string;
  /**
   * Finverse Mandate ID (ULID)
   * @type {string}
   * @memberof CreateMandateResponse
   */
  mandate_id: string;
  /**
   * Finverse Payment Method ID (ULID)
   * @type {string}
   * @memberof CreateMandateResponse
   */
  payment_method_id?: string;
  /**
   * Mandate status
   * @type {string}
   * @memberof CreateMandateResponse
   */
  status: CreateMandateResponseStatusEnum;
  /**
   *
   * @type {MandateRecipient}
   * @memberof CreateMandateResponse
   */
  recipient: MandateRecipient;
  /**
   *
   * @type {MandateRecipientAccount}
   * @memberof CreateMandateResponse
   */
  recipient_account?: MandateRecipientAccount;
  /**
   *
   * @type {GetMandateSender}
   * @memberof CreateMandateResponse
   */
  sender: GetMandateSender;
  /**
   *
   * @type {MandateSenderAccount}
   * @memberof CreateMandateResponse
   */
  sender_account?: MandateSenderAccount;
  /**
   *
   * @type {MandateDetails}
   * @memberof CreateMandateResponse
   */
  mandate_details: MandateDetails;
  /**
   *
   * @type {Array<Fee>}
   * @memberof CreateMandateResponse
   */
  fees?: Array<Fee>;
  /**
   * Additional attributes of the mandate in key:value format (e.g. mandate_internal_id: 1234). It supports up to 10 key:value pairs, whereas the key and value supports up to 50 and 500 characters respectively.
   * @type {{ [key: string]: string; }}
   * @memberof CreateMandateResponse
   */
  metadata?: { [key: string]: string };
  /**
   *
   * @type {FvErrorModelV2}
   * @memberof CreateMandateResponse
   */
  error?: FvErrorModelV2;
}

export const CreateMandateResponseStatusEnum = {
  AuthorizationRequired: 'AUTHORIZATION_REQUIRED',
  Authorizing: 'AUTHORIZING',
  Processing: 'PROCESSING',
  Submitted: 'SUBMITTED',
  Succeeded: 'SUCCEEDED',
  Failed: 'FAILED',
  Revoked: 'REVOKED',
} as const;

export type CreateMandateResponseStatusEnum =
  (typeof CreateMandateResponseStatusEnum)[keyof typeof CreateMandateResponseStatusEnum];

/**
 *
 * @export
 * @interface CreateMandateSender
 */
export interface CreateMandateSender {
  /**
   *
   * @type {string}
   * @memberof CreateMandateSender
   */
  name?: string;
  /**
   * Customer App\'s user ID, representing the end-user making the payment.
   * @type {string}
   * @memberof CreateMandateSender
   */
  external_user_id?: string;
  /**
   * Type of account held by the Sender at the Institution. Possible values are INDIVIDUAL, BUSINESS
   * @type {string}
   * @memberof CreateMandateSender
   */
  user_type?: CreateMandateSenderUserTypeEnum;
  /**
   * Sender details which will be used for fraud checking.
   * @type {Array<SenderDetail>}
   * @memberof CreateMandateSender
   */
  user_details?: Array<SenderDetail>;
}

export const CreateMandateSenderUserTypeEnum = {
  Individual: 'INDIVIDUAL',
  Business: 'BUSINESS',
} as const;

export type CreateMandateSenderUserTypeEnum =
  (typeof CreateMandateSenderUserTypeEnum)[keyof typeof CreateMandateSenderUserTypeEnum];

/**
 *
 * @export
 * @interface CreateMandateWithSenderAccountRequest
 */
export interface CreateMandateWithSenderAccountRequest {
  /**
   *
   * @type {MandateRecipientRequest}
   * @memberof CreateMandateWithSenderAccountRequest
   */
  recipient_account: MandateRecipientRequest;
  /**
   *
   * @type {MandateSenderAccountRequest}
   * @memberof CreateMandateWithSenderAccountRequest
   */
  sender_account: MandateSenderAccountRequest;
  /**
   *
   * @type {MandateDetails}
   * @memberof CreateMandateWithSenderAccountRequest
   */
  mandate_details: MandateDetails;
  /**
   * Additional attributes of the mandate in key:value format (e.g. mandate_internal_id: 1234). It supports up to 10 key:value pairs, whereas the key and value supports up to 50 and 500 characters respectively.
   * @type {{ [key: string]: string; }}
   * @memberof CreateMandateWithSenderAccountRequest
   */
  metadata?: { [key: string]: string };
}
/**
 *
 * @export
 * @interface CreatePaymentAccountRequest
 */
export interface CreatePaymentAccountRequest {
  /**
   *
   * @type {RecipientAccountNumber}
   * @memberof CreatePaymentAccountRequest
   */
  account_number: RecipientAccountNumber;
  /**
   * Type of payment account. Currently only allow creating external account.
   * @type {string}
   * @memberof CreatePaymentAccountRequest
   */
  account_type: CreatePaymentAccountRequestAccountTypeEnum;
  /**
   * Accountholder name of the payment account
   * @type {string}
   * @memberof CreatePaymentAccountRequest
   */
  accountholder_name: string;
  /**
   * List of currencies supported by the payment account
   * @type {Array<string>}
   * @memberof CreatePaymentAccountRequest
   */
  currencies?: Array<string>;
  /**
   * Finverse Institution ID for the payment institution.
   * @type {string}
   * @memberof CreatePaymentAccountRequest
   */
  institution_id: string;
  /**
   * A unique identifier generated after creating user (Finverse Payment User ID)
   * @type {string}
   * @memberof CreatePaymentAccountRequest
   */
  user_id: string;
  /**
   * Additional attributes of the payment in key:value format (e.g. payment_internal_id: 1234). It supports up to 10 key:value pairs, whereas the key and value supports up to 50 and 500 characters respectively.
   * @type {{ [key: string]: string; }}
   * @memberof CreatePaymentAccountRequest
   */
  metadata?: { [key: string]: string };
}

export const CreatePaymentAccountRequestAccountTypeEnum = {
  ExternalAccount: 'EXTERNAL_ACCOUNT',
} as const;

export type CreatePaymentAccountRequestAccountTypeEnum =
  (typeof CreatePaymentAccountRequestAccountTypeEnum)[keyof typeof CreatePaymentAccountRequestAccountTypeEnum];

/**
 *
 * @export
 * @interface CreatePaymentInstructionResponse
 */
export interface CreatePaymentInstructionResponse {
  /**
   *
   * @type {string}
   * @memberof CreatePaymentInstructionResponse
   */
  payment_instruction_id?: string;
}
/**
 *
 * @export
 * @interface CreatePaymentLinkCardPaymentResponse
 */
export interface CreatePaymentLinkCardPaymentResponse {
  /**
   * URL to redirect to for making the card payment (e.g. Stripe)
   * @type {string}
   * @memberof CreatePaymentLinkCardPaymentResponse
   */
  card_processor_redirect_uri: string;
  /**
   * Finverse Payment ID
   * @type {string}
   * @memberof CreatePaymentLinkCardPaymentResponse
   */
  payment_id?: string;
}
/**
 *
 * @export
 * @interface CreatePaymentLinkMandateRequest
 */
export interface CreatePaymentLinkMandateRequest {
  /**
   *
   * @type {string}
   * @memberof CreatePaymentLinkMandateRequest
   */
  payment_attempt_id: string;
  /**
   * The sender type of the mandate
   * @type {string}
   * @memberof CreatePaymentLinkMandateRequest
   */
  sender_type: CreatePaymentLinkMandateRequestSenderTypeEnum;
}

export const CreatePaymentLinkMandateRequestSenderTypeEnum = {
  Individual: 'INDIVIDUAL',
  Business: 'BUSINESS',
} as const;

export type CreatePaymentLinkMandateRequestSenderTypeEnum =
  (typeof CreatePaymentLinkMandateRequestSenderTypeEnum)[keyof typeof CreatePaymentLinkMandateRequestSenderTypeEnum];

/**
 *
 * @export
 * @interface CreatePaymentLinkMandateResponse
 */
export interface CreatePaymentLinkMandateResponse {
  /**
   *
   * @type {PaymentLinkTokenResponse}
   * @memberof CreatePaymentLinkMandateResponse
   */
  mandate_link_token: PaymentLinkTokenResponse;
}
/**
 *
 * @export
 * @interface CreatePaymentLinkRequest
 */
export interface CreatePaymentLinkRequest {
  /**
   * The amount of the payment. Expressed in currency\'s smallest unit or “minor unit”, as defined in ISO 4217.
   * @type {number}
   * @memberof CreatePaymentLinkRequest
   */
  amount?: number;
  /**
   *
   * @type {string}
   * @memberof CreatePaymentLinkRequest
   */
  currency: string;
  /**
   *
   * @type {PaymentLinkCustomizations}
   * @memberof CreatePaymentLinkRequest
   */
  link_customizations?: PaymentLinkCustomizations;
  /**
   * The payment link mode
   * @type {string}
   * @memberof CreatePaymentLinkRequest
   */
  mode: CreatePaymentLinkRequestModeEnum;
  /**
   *
   * @type {PaymentLinkDetails}
   * @memberof CreatePaymentLinkRequest
   */
  payment_details?: PaymentLinkDetails;
  /**
   *
   * @type {PaymentLinkSender}
   * @memberof CreatePaymentLinkRequest
   */
  sender: PaymentLinkSender;
  /**
   * Unique reference id to identifying the payment to be collected.
   * @type {string}
   * @memberof CreatePaymentLinkRequest
   */
  unique_reference_id: string;
  /**
   *
   * @type {PaymentSetupOptions}
   * @memberof CreatePaymentLinkRequest
   */
  payment_setup_options?: PaymentSetupOptions;
  /**
   * Additional attributes of the payment link in key:value format (e.g. payment_id: 1234). It supports up to 10 key:value pairs, whereas the key and value supports up to 50 and 500 characters respectively.
   * @type {{ [key: string]: string; }}
   * @memberof CreatePaymentLinkRequest
   */
  metadata?: { [key: string]: string };
}

export const CreatePaymentLinkRequestModeEnum = {
  Payment: 'PAYMENT',
  Setup: 'SETUP',
} as const;

export type CreatePaymentLinkRequestModeEnum =
  (typeof CreatePaymentLinkRequestModeEnum)[keyof typeof CreatePaymentLinkRequestModeEnum];

/**
 *
 * @export
 * @interface CreatePaymentRequest
 */
export interface CreatePaymentRequest {
  /**
   * Amount to be paid, in currency\'s smallest unit or “minor unit”, as defined in ISO 4217. For example, HKD 100.01 is represented as amount = 10001 (minor unit = cents). For currencies without minor units (e.g. VND, JPY), the amount is represented as is, without modification. For example, VND 15101 is represented as amount = 15101.
   * @type {number}
   * @memberof CreatePaymentRequest
   */
  amount: number;
  /**
   * The currency code as defined in ISO 4217.
   * @type {string}
   * @memberof CreatePaymentRequest
   */
  currency: string;
  /**
   * Indicates whether this is a mandate-based payment or one-off direct payment to an account. Possible values - MANDATE, SINGLE
   * @type {string}
   * @memberof CreatePaymentRequest
   */
  type: CreatePaymentRequestTypeEnum;
  /**
   *
   * @type {PaymentDetails2}
   * @memberof CreatePaymentRequest
   */
  payment_details: PaymentDetails2;
  /**
   * Additional attributes of the payment in key:value format (e.g. payment_internal_id: 1234). It supports up to 10 key:value pairs, whereas the key and value supports up to 50 and 500 characters respectively.
   * @type {{ [key: string]: string; }}
   * @memberof CreatePaymentRequest
   */
  metadata?: { [key: string]: string };
}

export const CreatePaymentRequestTypeEnum = {
  Mandate: 'MANDATE',
  Single: 'SINGLE',
} as const;

export type CreatePaymentRequestTypeEnum =
  (typeof CreatePaymentRequestTypeEnum)[keyof typeof CreatePaymentRequestTypeEnum];

/**
 *
 * @export
 * @interface CreatePaymentUserRequest
 */
export interface CreatePaymentUserRequest {
  /**
   *
   * @type {string}
   * @memberof CreatePaymentUserRequest
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof CreatePaymentUserRequest
   */
  external_user_id: string;
  /**
   *
   * @type {string}
   * @memberof CreatePaymentUserRequest
   */
  user_type?: CreatePaymentUserRequestUserTypeEnum;
  /**
   *
   * @type {string}
   * @memberof CreatePaymentUserRequest
   */
  email?: string;
  /**
   *
   * @type {Array<SenderDetail>}
   * @memberof CreatePaymentUserRequest
   */
  user_details?: Array<SenderDetail>;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof CreatePaymentUserRequest
   */
  metadata?: { [key: string]: string };
}

export const CreatePaymentUserRequestUserTypeEnum = {
  Individual: 'INDIVIDUAL',
  Business: 'BUSINESS',
} as const;

export type CreatePaymentUserRequestUserTypeEnum =
  (typeof CreatePaymentUserRequestUserTypeEnum)[keyof typeof CreatePaymentUserRequestUserTypeEnum];

/**
 *
 * @export
 * @interface CreateRecipientAccount
 */
export interface CreateRecipientAccount {
  /**
   * Accountholder name of the recipient\'s account
   * @type {string}
   * @memberof CreateRecipientAccount
   */
  accountholder_name: string;
  /**
   *
   * @type {RecipientAccountNumber}
   * @memberof CreateRecipientAccount
   */
  account_number: RecipientAccountNumber;
  /**
   * Type of recipient account.
   * @type {string}
   * @memberof CreateRecipientAccount
   */
  account_type: CreateRecipientAccountAccountTypeEnum;
  /**
   * List of currencies supported by the recipient account
   * @type {Array<string>}
   * @memberof CreateRecipientAccount
   */
  currencies: Array<string>;
  /**
   * Finverse Institution ID for the recipient’s institution.
   * @type {string}
   * @memberof CreateRecipientAccount
   */
  institution_id: string;
}

export const CreateRecipientAccountAccountTypeEnum = {
  ExternalAccount: 'EXTERNAL_ACCOUNT',
} as const;

export type CreateRecipientAccountAccountTypeEnum =
  (typeof CreateRecipientAccountAccountTypeEnum)[keyof typeof CreateRecipientAccountAccountTypeEnum];

/**
 *
 * @export
 * @interface CreateScheduledPayoutRequest
 */
export interface CreateScheduledPayoutRequest {
  /**
   * Amount to be paid, in currency\'s smallest unit or “minor unit”, as defined in ISO 4217. For example, HKD 100.01 is represented as amount = 10001 (minor unit = cents). For currencies without minor units (e.g. VND, JPY), the amount is represented as is, without modification. For example, VND 15101 is represented as amount = 15101.
   * @type {number}
   * @memberof CreateScheduledPayoutRequest
   */
  amount: number;
  /**
   * The currency code as defined in ISO 4217.
   * @type {string}
   * @memberof CreateScheduledPayoutRequest
   */
  currency: string;
  /**
   *
   * @type {PayoutDetails}
   * @memberof CreateScheduledPayoutRequest
   */
  payment_details: PayoutDetails;
  /**
   *
   * @type {MandateRecipientRequest}
   * @memberof CreateScheduledPayoutRequest
   */
  recipient_account: MandateRecipientRequest;
  /**
   * Additional attributes of the payout instruction in key:value format (e.g. payout_instruction_internal_id: 1234). It supports up to 10 key:value pairs, whereas the key and value supports up to 50 and 500 characters respectively.
   * @type {{ [key: string]: string; }}
   * @memberof CreateScheduledPayoutRequest
   */
  metadata?: { [key: string]: string };
}
/**
 *
 * @export
 * @interface CurrencyAmount
 */
export interface CurrencyAmount {
  /**
   *
   * @type {string}
   * @memberof CurrencyAmount
   */
  currency?: string;
  /**
   *
   * @type {number}
   * @memberof CurrencyAmount
   */
  value: number;
  /**
   *
   * @type {string}
   * @memberof CurrencyAmount
   */
  raw?: string;
}
/**
 *
 * @export
 * @interface CustomerPaymentInstruction
 */
export interface CustomerPaymentInstruction {
  /**
   * A id of the user of this payment, need to equal to userId when creating link
   * @type {string}
   * @memberof CustomerPaymentInstruction
   */
  user_id: string;
  /**
   * Type of payment is being created, please check Documentation on which payment type is supported in each institution
   * @type {string}
   * @memberof CustomerPaymentInstruction
   */
  type: CustomerPaymentInstructionTypeEnum;
  /**
   * The recipient name
   * @type {string}
   * @memberof CustomerPaymentInstruction
   */
  recipient_name?: string;
  /**
   * The recipient account Id
   * @type {string}
   * @memberof CustomerPaymentInstruction
   */
  recipient_account_id?: string;
  /**
   * The sender name
   * @type {string}
   * @memberof CustomerPaymentInstruction
   */
  sender_name?: string;
  /**
   * The sender account Id
   * @type {string}
   * @memberof CustomerPaymentInstruction
   */
  sender_account_id?: string;
  /**
   * When the payment should start
   * @type {string}
   * @memberof CustomerPaymentInstruction
   */
  start_date?: string | null;
  /**
   * When the payment should stop
   * @type {string}
   * @memberof CustomerPaymentInstruction
   */
  end_date?: string | null;
  /**
   * The currency for the payment
   * @type {string}
   * @memberof CustomerPaymentInstruction
   */
  currency?: string;
  /**
   * The payment amount
   * @type {number}
   * @memberof CustomerPaymentInstruction
   */
  amount?: number;
  /**
   * How often the payment should be executed
   * @type {string}
   * @memberof CustomerPaymentInstruction
   */
  frequency?: string;
  /**
   * Related remarks about this instruction
   * @type {string}
   * @memberof CustomerPaymentInstruction
   */
  remarks?: string;
}

export const CustomerPaymentInstructionTypeEnum = {
  DebitAuthorization: 'DEBIT_AUTHORIZATION',
} as const;

export type CustomerPaymentInstructionTypeEnum =
  (typeof CustomerPaymentInstructionTypeEnum)[keyof typeof CustomerPaymentInstructionTypeEnum];

/**
 *
 * @export
 * @interface DeleteLoginIdentityResponse
 */
export interface DeleteLoginIdentityResponse {
  /**
   *
   * @type {boolean}
   * @memberof DeleteLoginIdentityResponse
   */
  success?: boolean;
}
/**
 *
 * @export
 * @interface EncryptedPayload
 */
export interface EncryptedPayload {
  /**
   * The credential payload encrypted with AES (base64)
   * @type {string}
   * @memberof EncryptedPayload
   */
  ciphertext: string;
  /**
   * The 16 byte IV used w/ AES (base64)
   * @type {string}
   * @memberof EncryptedPayload
   */
  initializationVector: string;
  /**
   * The MAC to verify AES decryption validity
   * @type {string}
   * @memberof EncryptedPayload
   */
  messageAuthenticationCode: string;
  /**
   * The AES key encrypted with an RSA pubkey (base64)
   * @type {string}
   * @memberof EncryptedPayload
   */
  envelopeEncryptionKey: string;
  /**
   * The identifier of the public key used to encrypt the AES key
   * @type {string}
   * @memberof EncryptedPayload
   */
  keyId: string;
}
/**
 *
 * @export
 * @interface ErrBodyModel
 */
export interface ErrBodyModel {
  /**
   *
   * @type {FvErrorModel}
   * @memberof ErrBodyModel
   */
  error?: FvErrorModel;
}
/**
 *
 * @export
 * @interface ErrBodyModelV2
 */
export interface ErrBodyModelV2 {
  /**
   *
   * @type {FvErrorModelV2}
   * @memberof ErrBodyModelV2
   */
  error?: FvErrorModelV2;
}
/**
 *
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
  /**
   *
   * @type {string}
   * @memberof ErrorResponse
   */
  err?: string;
  /**
   *
   * @type {number}
   * @memberof ErrorResponse
   */
  http_status_code?: number;
  /**
   *
   * @type {string}
   * @memberof ErrorResponse
   */
  status_text?: string;
  /**
   *
   * @type {number}
   * @memberof ErrorResponse
   */
  app_code?: number;
  /**
   *
   * @type {string}
   * @memberof ErrorResponse
   */
  error_category?: string;
  /**
   *
   * @type {string}
   * @memberof ErrorResponse
   */
  error_text?: string;
  /**
   *
   * @type {string}
   * @memberof ErrorResponse
   */
  request_id?: string;
}
/**
 *
 * @export
 * @interface Fee
 */
export interface Fee {
  /**
   * The amount of fee for a single transaction. Expressed in currency\'s smallest unit or “minor unit”, as defined in ISO 4217.
   * @type {number}
   * @memberof Fee
   */
  amount: number;
  /**
   *
   * @type {string}
   * @memberof Fee
   */
  currency?: string;
  /**
   *
   * @type {string}
   * @memberof Fee
   */
  paid_by?: FeePaidByEnum;
  /**
   * The payment account Id
   * @type {string}
   * @memberof Fee
   */
  paid_by_account_id?: string;
}

export const FeePaidByEnum = {
  Recipient: 'RECIPIENT',
  Sender: 'SENDER',
} as const;

export type FeePaidByEnum = (typeof FeePaidByEnum)[keyof typeof FeePaidByEnum];

/**
 *
 * @export
 * @interface FpsQrCodeResponse
 */
export interface FpsQrCodeResponse {
  /**
   * The FPS QR code in base64
   * @type {string}
   * @memberof FpsQrCodeResponse
   */
  qr_code: string;
}
/**
 *
 * @export
 * @interface FvErrorModel
 */
export interface FvErrorModel {
  /**
   * The error type
   * @type {string}
   * @memberof FvErrorModel
   */
  type: FvErrorModelTypeEnum;
  /**
   *
   * @type {string}
   * @memberof FvErrorModel
   */
  error_code: string;
  /**
   *
   * @type {string}
   * @memberof FvErrorModel
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof FvErrorModel
   */
  message: string;
  /**
   *
   * @type {string}
   * @memberof FvErrorModel
   */
  details: string;
  /**
   * The request_id provided in the request header
   * @type {string}
   * @memberof FvErrorModel
   */
  request_id: string;
}

export const FvErrorModelTypeEnum = {
  LinkError: 'LINK_ERROR',
  ApiError: 'API_ERROR',
} as const;

export type FvErrorModelTypeEnum = (typeof FvErrorModelTypeEnum)[keyof typeof FvErrorModelTypeEnum];

/**
 *
 * @export
 * @interface FvErrorModelV2
 */
export interface FvErrorModelV2 {
  /**
   * The error type
   * @type {string}
   * @memberof FvErrorModelV2
   */
  type: FvErrorModelV2TypeEnum;
  /**
   *
   * @type {string}
   * @memberof FvErrorModelV2
   */
  error_code: string;
  /**
   *
   * @type {string}
   * @memberof FvErrorModelV2
   */
  message: string;
  /**
   *
   * @type {string}
   * @memberof FvErrorModelV2
   */
  details: string;
  /**
   * The request_id provided in the request header
   * @type {string}
   * @memberof FvErrorModelV2
   */
  request_id: string;
}

export const FvErrorModelV2TypeEnum = {
  LinkError: 'LINK_ERROR',
  ApiError: 'API_ERROR',
} as const;

export type FvErrorModelV2TypeEnum = (typeof FvErrorModelV2TypeEnum)[keyof typeof FvErrorModelV2TypeEnum];

/**
 *
 * @export
 * @interface GenericAmount
 */
export interface GenericAmount {
  /**
   *
   * @type {string}
   * @memberof GenericAmount
   */
  unit?: string;
  /**
   *
   * @type {number}
   * @memberof GenericAmount
   */
  value: number;
  /**
   *
   * @type {string}
   * @memberof GenericAmount
   */
  raw?: string;
}
/**
 *
 * @export
 * @interface GetAccountNumberResponse
 */
export interface GetAccountNumberResponse {
  /**
   *
   * @type {AccountNumber}
   * @memberof GetAccountNumberResponse
   */
  account_number?: AccountNumber;
  /**
   *
   * @type {Account}
   * @memberof GetAccountNumberResponse
   */
  account?: Account;
  /**
   *
   * @type {LoginIdentityShort}
   * @memberof GetAccountNumberResponse
   */
  login_identity?: LoginIdentityShort;
  /**
   *
   * @type {InstitutionShort}
   * @memberof GetAccountNumberResponse
   */
  institution?: InstitutionShort;
  /**
   *
   * @type {Array<PaymentDetails>}
   * @memberof GetAccountNumberResponse
   */
  payment_details?: Array<PaymentDetails>;
}
/**
 *
 * @export
 * @interface GetAccountResponse
 */
export interface GetAccountResponse {
  /**
   *
   * @type {Account}
   * @memberof GetAccountResponse
   */
  account?: Account;
  /**
   *
   * @type {LoginIdentityShort}
   * @memberof GetAccountResponse
   */
  login_identity?: LoginIdentityShort;
  /**
   *
   * @type {InstitutionShort}
   * @memberof GetAccountResponse
   */
  institution?: InstitutionShort;
}
/**
 *
 * @export
 * @interface GetBalanceHistoryResponse
 */
export interface GetBalanceHistoryResponse {
  /**
   *
   * @type {Account}
   * @memberof GetBalanceHistoryResponse
   */
  account?: Account;
  /**
   *
   * @type {LoginIdentityShort}
   * @memberof GetBalanceHistoryResponse
   */
  login_identity?: LoginIdentityShort;
  /**
   *
   * @type {InstitutionShort}
   * @memberof GetBalanceHistoryResponse
   */
  institution?: InstitutionShort;
  /**
   *
   * @type {Array<BalanceHistory>}
   * @memberof GetBalanceHistoryResponse
   */
  balance_history?: Array<BalanceHistory>;
  /**
   *
   * @type {string}
   * @memberof GetBalanceHistoryResponse
   */
  source?: GetBalanceHistoryResponseSourceEnum;
}

export const GetBalanceHistoryResponseSourceEnum = {
  Institution: 'INSTITUTION',
  Computed: 'COMPUTED',
} as const;

export type GetBalanceHistoryResponseSourceEnum =
  (typeof GetBalanceHistoryResponseSourceEnum)[keyof typeof GetBalanceHistoryResponseSourceEnum];

/**
 *
 * @export
 * @interface GetIdentityResponse
 */
export interface GetIdentityResponse {
  /**
   *
   * @type {Identity}
   * @memberof GetIdentityResponse
   */
  identity?: Identity;
  /**
   *
   * @type {LoginIdentityShort}
   * @memberof GetIdentityResponse
   */
  login_identity?: LoginIdentityShort;
  /**
   *
   * @type {InstitutionShort}
   * @memberof GetIdentityResponse
   */
  institution?: InstitutionShort;
}
/**
 *
 * @export
 * @interface GetJWKSResponse
 */
export interface GetJWKSResponse {
  /**
   *
   * @type {Array<JWKSKey>}
   * @memberof GetJWKSResponse
   */
  keys?: Array<JWKSKey>;
}
/**
 *
 * @export
 * @interface GetLineItemsForDisplayResponse
 */
export interface GetLineItemsForDisplayResponse {
  /**
   *
   * @type {Array<LineItem>}
   * @memberof GetLineItemsForDisplayResponse
   */
  line_items?: Array<LineItem>;
}
/**
 *
 * @export
 * @interface GetLoginIdentityByIdResponse
 */
export interface GetLoginIdentityByIdResponse {
  /**
   *
   * @type {LoginIdentity}
   * @memberof GetLoginIdentityByIdResponse
   */
  login_identity?: LoginIdentity;
  /**
   *
   * @type {InstitutionShort}
   * @memberof GetLoginIdentityByIdResponse
   */
  institution?: InstitutionShort;
}
/**
 *
 * @export
 * @interface GetLoginIdentityHistoryResponse
 */
export interface GetLoginIdentityHistoryResponse {
  /**
   *
   * @type {LoginIdentity}
   * @memberof GetLoginIdentityHistoryResponse
   */
  login_identity?: LoginIdentity;
  /**
   *
   * @type {Array<LoginIdentityStatusDetails>}
   * @memberof GetLoginIdentityHistoryResponse
   */
  status_history?: Array<LoginIdentityStatusDetails>;
}
/**
 *
 * @export
 * @interface GetMandateAuthLinkRequest
 */
export interface GetMandateAuthLinkRequest {
  /**
   * Mandate ID
   * @type {string}
   * @memberof GetMandateAuthLinkRequest
   */
  mandate_id: string;
  /**
   *
   * @type {MandateAuthLinkCustomizations}
   * @memberof GetMandateAuthLinkRequest
   */
  link_customizations: MandateAuthLinkCustomizations;
}
/**
 *
 * @export
 * @interface GetMandateAuthLinkResponse
 */
export interface GetMandateAuthLinkResponse {
  /**
   * Short-lived access-token to interact with Finverse Link
   * @type {string}
   * @memberof GetMandateAuthLinkResponse
   */
  access_token: string;
  /**
   * Access token validity duration (in seconds)
   * @type {number}
   * @memberof GetMandateAuthLinkResponse
   */
  expires_in: number;
  /**
   * URL to launch Finverse Link to authorize the mandate
   * @type {string}
   * @memberof GetMandateAuthLinkResponse
   */
  link_url: string;
  /**
   *
   * @type {string}
   * @memberof GetMandateAuthLinkResponse
   */
  token_type: GetMandateAuthLinkResponseTokenTypeEnum;
}

export const GetMandateAuthLinkResponseTokenTypeEnum = {
  Bearer: 'Bearer',
} as const;

export type GetMandateAuthLinkResponseTokenTypeEnum =
  (typeof GetMandateAuthLinkResponseTokenTypeEnum)[keyof typeof GetMandateAuthLinkResponseTokenTypeEnum];

/**
 *
 * @export
 * @interface GetMandateAuthResponse
 */
export interface GetMandateAuthResponse {
  /**
   * Finverse Mandate ID
   * @type {string}
   * @memberof GetMandateAuthResponse
   */
  mandate_id: string;
  /**
   * Mandate status
   * @type {string}
   * @memberof GetMandateAuthResponse
   */
  mandate_status: GetMandateAuthResponseMandateStatusEnum;
  /**
   * Merchant account ID assigned by Finverse
   * @type {string}
   * @memberof GetMandateAuthResponse
   */
  recipient_account_id: string;
  /**
   * Finverse Institution ID. Only returned if institution_id was included in the request.
   * @type {string}
   * @memberof GetMandateAuthResponse
   */
  institution_id: string;
  /**
   * Type of account held by the Sender at the Institution. Possible values are INDIVIDUAL, BUSINESS
   * @type {string}
   * @memberof GetMandateAuthResponse
   */
  sender_type?: GetMandateAuthResponseSenderTypeEnum;
  /**
   * Checklist of the authorization factors needed to complete Mandate authorization
   * @type {Array<AuthChecklistFactor>}
   * @memberof GetMandateAuthResponse
   */
  auth_checklist: Array<AuthChecklistFactor>;
  /**
   *
   * @type {MandateAuthEncryptionInfo}
   * @memberof GetMandateAuthResponse
   */
  encryption_info: MandateAuthEncryptionInfo;
  /**
   * Timestamp in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
   * @type {string}
   * @memberof GetMandateAuthResponse
   */
  last_update: string;
  /**
   *
   * @type {FvErrorModelV2}
   * @memberof GetMandateAuthResponse
   */
  error?: FvErrorModelV2;
  /**
   *
   * @type {MandateDetails}
   * @memberof GetMandateAuthResponse
   */
  mandate_details?: MandateDetails;
  /**
   *
   * @type {MandateRecipient}
   * @memberof GetMandateAuthResponse
   */
  recipient?: MandateRecipient;
}

export const GetMandateAuthResponseMandateStatusEnum = {
  Created: 'CREATED',
  Processing: 'PROCESSING',
  Submitted: 'SUBMITTED',
  Error: 'ERROR',
} as const;

export type GetMandateAuthResponseMandateStatusEnum =
  (typeof GetMandateAuthResponseMandateStatusEnum)[keyof typeof GetMandateAuthResponseMandateStatusEnum];
export const GetMandateAuthResponseSenderTypeEnum = {
  Individual: 'INDIVIDUAL',
  Business: 'BUSINESS',
} as const;

export type GetMandateAuthResponseSenderTypeEnum =
  (typeof GetMandateAuthResponseSenderTypeEnum)[keyof typeof GetMandateAuthResponseSenderTypeEnum];

/**
 *
 * @export
 * @interface GetMandateResponse
 */
export interface GetMandateResponse {
  /**
   * Timestamp in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
   * @type {string}
   * @memberof GetMandateResponse
   */
  created_at?: string;
  /**
   * Timestamp in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
   * @type {string}
   * @memberof GetMandateResponse
   */
  updated_at: string;
  /**
   * Finverse Mandate ID (ULID)
   * @type {string}
   * @memberof GetMandateResponse
   */
  mandate_id: string;
  /**
   * Finverse Payment Method ID (ULID)
   * @type {string}
   * @memberof GetMandateResponse
   */
  payment_method_id?: string;
  /**
   * Mandate Status
   * @type {string}
   * @memberof GetMandateResponse
   */
  status: GetMandateResponseStatusEnum;
  /**
   *
   * @type {MandateRecipient}
   * @memberof GetMandateResponse
   */
  recipient: MandateRecipient;
  /**
   *
   * @type {MandateRecipientAccount}
   * @memberof GetMandateResponse
   */
  recipient_account?: MandateRecipientAccount;
  /**
   *
   * @type {GetMandateSender}
   * @memberof GetMandateResponse
   */
  sender: GetMandateSender;
  /**
   *
   * @type {MandateSenderAccount}
   * @memberof GetMandateResponse
   */
  sender_account?: MandateSenderAccount;
  /**
   *
   * @type {MandateDetails}
   * @memberof GetMandateResponse
   */
  mandate_details: MandateDetails;
  /**
   *
   * @type {Array<Fee>}
   * @memberof GetMandateResponse
   */
  fees?: Array<Fee>;
  /**
   *
   * @type {FvErrorModelV2}
   * @memberof GetMandateResponse
   */
  error?: FvErrorModelV2;
  /**
   * Additional attributes of the mandate in key:value format (e.g. mandate_internal_id: 1234). It supports up to 10 key:value pairs, whereas the key and value supports up to 50 and 500 characters respectively.
   * @type {{ [key: string]: string; }}
   * @memberof GetMandateResponse
   */
  metadata?: { [key: string]: string };
}

export const GetMandateResponseStatusEnum = {
  AuthorizationRequired: 'AUTHORIZATION_REQUIRED',
  Authorizing: 'AUTHORIZING',
  Processing: 'PROCESSING',
  Submitted: 'SUBMITTED',
  Succeeded: 'SUCCEEDED',
  Failed: 'FAILED',
  Revoked: 'REVOKED',
} as const;

export type GetMandateResponseStatusEnum =
  (typeof GetMandateResponseStatusEnum)[keyof typeof GetMandateResponseStatusEnum];

/**
 *
 * @export
 * @interface GetMandateSender
 */
export interface GetMandateSender {
  /**
   * A unique identifier generated after creating sender
   * @type {string}
   * @memberof GetMandateSender
   */
  user_id: string;
  /**
   *
   * @type {string}
   * @memberof GetMandateSender
   */
  name?: string;
  /**
   * Customer App\'s user ID, representing the end-user making the payment.
   * @type {string}
   * @memberof GetMandateSender
   */
  external_user_id: string;
  /**
   * Type of account held by the Sender at the Institution. Possible values are INDIVIDUAL, BUSINESS
   * @type {string}
   * @memberof GetMandateSender
   */
  user_type: GetMandateSenderUserTypeEnum;
  /**
   * Sender details which will be used for fraud checking.
   * @type {Array<SenderDetail>}
   * @memberof GetMandateSender
   */
  user_details?: Array<SenderDetail>;
}

export const GetMandateSenderUserTypeEnum = {
  Individual: 'INDIVIDUAL',
  Business: 'BUSINESS',
} as const;

export type GetMandateSenderUserTypeEnum =
  (typeof GetMandateSenderUserTypeEnum)[keyof typeof GetMandateSenderUserTypeEnum];

/**
 *
 * @export
 * @interface GetPaymentInstructionsResponse
 */
export interface GetPaymentInstructionsResponse {
  /**
   *
   * @type {PaymentInstruction}
   * @memberof GetPaymentInstructionsResponse
   */
  payment_instruction?: PaymentInstruction;
}
/**
 *
 * @export
 * @interface GetPaymentUserResponse
 */
export interface GetPaymentUserResponse {
  /**
   *
   * @type {string}
   * @memberof GetPaymentUserResponse
   */
  payment_user_id: string;
  /**
   *
   * @type {string}
   * @memberof GetPaymentUserResponse
   */
  customer_app_id: string;
  /**
   * The user\'s current autopay value
   * @type {boolean}
   * @memberof GetPaymentUserResponse
   */
  autopay_consent: boolean;
  /**
   * This indicates the value that the user\'s pre-set selection should be. If this is a new user, the value will be set to true by default, else it will be the user\'s current autopay value.
   * @type {boolean}
   * @memberof GetPaymentUserResponse
   */
  autopay_prefill: boolean;
}
/**
 *
 * @export
 * @interface GetStatementLinkResponse
 */
export interface GetStatementLinkResponse {
  /**
   *
   * @type {Array<StatementLink>}
   * @memberof GetStatementLinkResponse
   */
  statement_links?: Array<StatementLink>;
}
/**
 *
 * @export
 * @interface GetStatementsResponse
 */
export interface GetStatementsResponse {
  /**
   *
   * @type {Array<Statement>}
   * @memberof GetStatementsResponse
   */
  statements?: Array<Statement>;
  /**
   *
   * @type {LoginIdentityShort}
   * @memberof GetStatementsResponse
   */
  login_identity?: LoginIdentityShort;
  /**
   *
   * @type {InstitutionShort}
   * @memberof GetStatementsResponse
   */
  institution?: InstitutionShort;
}
/**
 *
 * @export
 * @interface Identity
 */
export interface Identity {
  /**
   *
   * @type {Array<IdentityName>}
   * @memberof Identity
   */
  names?: Array<IdentityName>;
  /**
   *
   * @type {Array<IdentityAddress>}
   * @memberof Identity
   */
  addresses?: Array<IdentityAddress>;
  /**
   *
   * @type {Array<IdentityEmail>}
   * @memberof Identity
   */
  emails?: Array<IdentityEmail>;
  /**
   *
   * @type {Array<IdentityPhoneNumber>}
   * @memberof Identity
   */
  phone_numbers?: Array<IdentityPhoneNumber>;
  /**
   *
   * @type {Array<IdentityDateOfBirth>}
   * @memberof Identity
   */
  date_of_births?: Array<IdentityDateOfBirth>;
}
/**
 *
 * @export
 * @interface IdentityAddress
 */
export interface IdentityAddress {
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  raw?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  full_address?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  unit_number?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  floor_number?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  building_name?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  street_number?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  street_name?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  city?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  district?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  ward?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  street_address?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  province?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  country?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  postal_code?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityAddress
   */
  source?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof IdentityAddress
   */
  source_ids?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof IdentityAddress
   */
  account_ids?: Array<string>;
}
/**
 *
 * @export
 * @interface IdentityDateOfBirth
 */
export interface IdentityDateOfBirth {
  /**
   *
   * @type {string}
   * @memberof IdentityDateOfBirth
   */
  raw?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityDateOfBirth
   */
  date_of_birth?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityDateOfBirth
   */
  masked_date_of_birth?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityDateOfBirth
   */
  source?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof IdentityDateOfBirth
   */
  source_ids?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof IdentityDateOfBirth
   */
  account_ids?: Array<string>;
}
/**
 *
 * @export
 * @interface IdentityEmail
 */
export interface IdentityEmail {
  /**
   *
   * @type {string}
   * @memberof IdentityEmail
   */
  raw?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityEmail
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityEmail
   */
  masked_email?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityEmail
   */
  source?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof IdentityEmail
   */
  source_ids?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof IdentityEmail
   */
  account_ids?: Array<string>;
}
/**
 *
 * @export
 * @interface IdentityName
 */
export interface IdentityName {
  /**
   *
   * @type {string}
   * @memberof IdentityName
   */
  raw?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityName
   */
  full_name?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityName
   */
  first_name?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityName
   */
  last_name?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityName
   */
  other_name?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityName
   */
  source?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof IdentityName
   */
  source_ids?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof IdentityName
   */
  account_ids?: Array<string>;
}
/**
 *
 * @export
 * @interface IdentityPhoneNumber
 */
export interface IdentityPhoneNumber {
  /**
   *
   * @type {string}
   * @memberof IdentityPhoneNumber
   */
  raw?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityPhoneNumber
   */
  mobile_phone?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityPhoneNumber
   */
  other_phone?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityPhoneNumber
   */
  masked_phone?: string;
  /**
   *
   * @type {string}
   * @memberof IdentityPhoneNumber
   */
  source?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof IdentityPhoneNumber
   */
  source_ids?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof IdentityPhoneNumber
   */
  account_ids?: Array<string>;
}
/**
 *
 * @export
 * @interface IncomeEstimate
 */
export interface IncomeEstimate {
  /**
   * Income amount
   * @type {number}
   * @memberof IncomeEstimate
   */
  amount: number;
  /**
   * Currency
   * @type {string}
   * @memberof IncomeEstimate
   */
  currency: string;
}
/**
 *
 * @export
 * @interface IncomeResponse
 */
export interface IncomeResponse {
  /**
   *
   * @type {Array<SingleSourceIncome>}
   * @memberof IncomeResponse
   */
  income: Array<SingleSourceIncome>;
  /**
   *
   * @type {LoginIdentityShort}
   * @memberof IncomeResponse
   */
  login_identity: LoginIdentityShort;
  /**
   *
   * @type {InstitutionShort}
   * @memberof IncomeResponse
   */
  institution: InstitutionShort;
}
/**
 *
 * @export
 * @interface IncomeStream
 */
export interface IncomeStream {
  /**
   * Account this income estimate is associated with
   * @type {string}
   * @memberof IncomeStream
   */
  account_id: string;
  /**
   *
   * @type {IncomeEstimate}
   * @memberof IncomeStream
   */
  estimated_monthly_income?: IncomeEstimate;
  /**
   * Number of transactions counted towards income
   * @type {number}
   * @memberof IncomeStream
   */
  transaction_count: number;
  /**
   *
   * @type {Array<MonthlyIncomeEstimate>}
   * @memberof IncomeStream
   */
  monthly_history: Array<MonthlyIncomeEstimate>;
}
/**
 *
 * @export
 * @interface IncomeTotal
 */
export interface IncomeTotal {
  /**
   *
   * @type {IncomeEstimate}
   * @memberof IncomeTotal
   */
  estimated_monthly_income?: IncomeEstimate;
  /**
   * Number of transactions counted towards income
   * @type {number}
   * @memberof IncomeTotal
   */
  transaction_count: number;
  /**
   *
   * @type {Array<MonthlyIncomeEstimate>}
   * @memberof IncomeTotal
   */
  monthly_history: Array<MonthlyIncomeEstimate>;
}
/**
 *
 * @export
 * @interface Institution
 */
export interface Institution {
  /**
   *
   * @type {string}
   * @memberof Institution
   */
  institution_id: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Institution
   */
  countries: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof Institution
   */
  tags?: Array<InstitutionTagsEnum>;
  /**
   *
   * @type {string}
   * @memberof Institution
   */
  institution_type: InstitutionInstitutionTypeEnum;
  /**
   *
   * @type {Array<string>}
   * @memberof Institution
   */
  products_supported: Array<InstitutionProductsSupportedEnum>;
  /**
   *
   * @type {string}
   * @memberof Institution
   */
  parent_institution_name?: string;
  /**
   *
   * @type {string}
   * @memberof Institution
   */
  institution_name: string;
  /**
   *
   * @type {string}
   * @memberof Institution
   */
  portal_name?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Institution
   */
  user_type: Array<InstitutionUserTypeEnum>;
  /**
   *
   * @type {string}
   * @memberof Institution
   */
  status: InstitutionStatusEnum;
  /**
   *
   * @type {object}
   * @memberof Institution
   */
  status_details?: object;
  /**
   *
   * @type {string}
   * @memberof Institution
   */
  login_url?: string;
  /**
   *
   * @type {object}
   * @memberof Institution
   */
  login_details: object;
  /**
   *
   * @type {Array<LoginMethod>}
   * @memberof Institution
   */
  login_methods?: Array<LoginMethod>;
  /**
   *
   * @type {PaymentInfo}
   * @memberof Institution
   */
  payment_info?: PaymentInfo;
  /**
   *
   * @type {string}
   * @memberof Institution
   */
  color?: string;
  /**
   *
   * @type {string}
   * @memberof Institution
   */
  updated_at?: string;
  /**
   *
   * @type {Array<LoginAction>}
   * @memberof Institution
   */
  login_actions?: Array<LoginAction>;
}

export const InstitutionTagsEnum = {
  Real: 'real',
  Test: 'test',
} as const;

export type InstitutionTagsEnum = (typeof InstitutionTagsEnum)[keyof typeof InstitutionTagsEnum];
export const InstitutionInstitutionTypeEnum = {
  Bank: 'BANK',
  Wallet: 'WALLET',
  Test: 'TEST',
} as const;

export type InstitutionInstitutionTypeEnum =
  (typeof InstitutionInstitutionTypeEnum)[keyof typeof InstitutionInstitutionTypeEnum];
export const InstitutionProductsSupportedEnum = {
  Accounts: 'ACCOUNTS',
  Transactions: 'TRANSACTIONS',
  Statements: 'STATEMENTS',
  AccountNumbers: 'ACCOUNT_NUMBERS',
  Identity: 'IDENTITY',
} as const;

export type InstitutionProductsSupportedEnum =
  (typeof InstitutionProductsSupportedEnum)[keyof typeof InstitutionProductsSupportedEnum];
export const InstitutionUserTypeEnum = {
  Personal: 'PERSONAL',
  Individual: 'INDIVIDUAL',
  Business: 'BUSINESS',
} as const;

export type InstitutionUserTypeEnum = (typeof InstitutionUserTypeEnum)[keyof typeof InstitutionUserTypeEnum];
export const InstitutionStatusEnum = {
  Supported: 'SUPPORTED',
  Alpha: 'ALPHA',
  Beta: 'BETA',
} as const;

export type InstitutionStatusEnum = (typeof InstitutionStatusEnum)[keyof typeof InstitutionStatusEnum];

/**
 *
 * @export
 * @interface InstitutionShort
 */
export interface InstitutionShort {
  /**
   *
   * @type {string}
   * @memberof InstitutionShort
   */
  institution_id?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof InstitutionShort
   */
  countries?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof InstitutionShort
   */
  institution_name?: string;
  /**
   *
   * @type {string}
   * @memberof InstitutionShort
   */
  portal_name?: string;
}
/**
 *
 * @export
 * @interface JWKSKey
 */
export interface JWKSKey {
  /**
   * The \"kty\" (key type) parameter identifies the cryptographic algorithm family used with the key, such as \"RSA\" or \"EC\".
   * @type {string}
   * @memberof JWKSKey
   */
  kty?: string;
  /**
   * The \"kid\" (key ID) parameter is used to match a specific key
   * @type {string}
   * @memberof JWKSKey
   */
  kid?: string;
  /**
   * The \"use\" (public key use) parameter identifies the intended use of the public key
   * @type {string}
   * @memberof JWKSKey
   */
  use?: string;
  /**
   * RSA key value \"e\"
   * @type {string}
   * @memberof JWKSKey
   */
  e?: string;
  /**
   * RSA key value \"n\"
   * @type {string}
   * @memberof JWKSKey
   */
  n?: string;
  /**
   * The \"x5c\" (X.509 certificate chain) parameter contains a chain of one or more PKIX certificates
   * @type {Array<string>}
   * @memberof JWKSKey
   */
  x5c?: Array<string>;
}
/**
 *
 * @export
 * @interface LineItem
 */
export interface LineItem {
  /**
   *
   * @type {string}
   * @memberof LineItem
   */
  currency?: string;
  /**
   * The amount in decimal
   * @type {string}
   * @memberof LineItem
   */
  amount?: string;
  /**
   *
   * @type {string}
   * @memberof LineItem
   */
  item_type?: LineItemItemTypeEnum;
}

export const LineItemItemTypeEnum = {
  AmountDue: 'AMOUNT_DUE',
  Surcharge: 'SURCHARGE',
  Total: 'TOTAL',
} as const;

export type LineItemItemTypeEnum = (typeof LineItemItemTypeEnum)[keyof typeof LineItemItemTypeEnum];

/**
 *
 * @export
 * @interface LinkRequest
 */
export interface LinkRequest {
  /**
   *
   * @type {string}
   * @memberof LinkRequest
   */
  institution_id: string;
  /**
   *
   * @type {boolean}
   * @memberof LinkRequest
   */
  store_credential: boolean;
  /**
   * this is a mandatory field
   * @type {boolean}
   * @memberof LinkRequest
   */
  consent?: boolean | null;
  /**
   * products that is requested
   * @type {Array<string>}
   * @memberof LinkRequest
   */
  products_requested?: Array<string>;
  /**
   * The identifier returned after creating payment instruction
   * @type {string}
   * @memberof LinkRequest
   */
  payment_instruction_id?: string;
}
/**
 *
 * @export
 * @interface LinkResponse
 */
export interface LinkResponse {
  /**
   *
   * @type {string}
   * @memberof LinkResponse
   */
  auth_url?: string;
}
/**
 *
 * @export
 * @interface LinkStatusActionModel
 */
export interface LinkStatusActionModel {
  /**
   * Unique identifier
   * @type {string}
   * @memberof LinkStatusActionModel
   */
  action_id: string;
  /**
   * The type of user screen the UI is to render
   * @type {string}
   * @memberof LinkStatusActionModel
   */
  type: string;
  /**
   * The name of the user screen the UI is to render
   * @type {string}
   * @memberof LinkStatusActionModel
   */
  name: string;
  /**
   *
   * @type {Array<UserMessage>}
   * @memberof LinkStatusActionModel
   */
  messages: Array<UserMessage>;
  /**
   *
   * @type {Array<UserField>}
   * @memberof LinkStatusActionModel
   */
  fields: Array<UserField>;
  /**
   *
   * @type {Array<UserButton>}
   * @memberof LinkStatusActionModel
   */
  buttons?: Array<UserButton>;
}
/**
 *
 * @export
 * @interface LinkStatusPendingModel
 */
export interface LinkStatusPendingModel {
  /**
   *
   * @type {string}
   * @memberof LinkStatusPendingModel
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof LinkStatusPendingModel
   */
  message?: string;
  /**
   *
   * @type {string}
   * @memberof LinkStatusPendingModel
   */
  details?: string;
}
/**
 *
 * @export
 * @interface LinkStatusResponse
 */
export interface LinkStatusResponse {
  /**
   *
   * @type {AccessTokenResponse}
   * @memberof LinkStatusResponse
   */
  success?: AccessTokenResponse;
  /**
   *
   * @type {LinkStatusPendingModel}
   * @memberof LinkStatusResponse
   */
  pending?: LinkStatusPendingModel;
  /**
   *
   * @type {LinkStatusActionModel}
   * @memberof LinkStatusResponse
   */
  action?: LinkStatusActionModel;
}
/**
 *
 * @export
 * @interface LinkTokenRequest
 */
export interface LinkTokenRequest {
  /**
   * support only client_credentials
   * @type {string}
   * @memberof LinkTokenRequest
   */
  grant_type: string;
  /**
   *
   * @type {string}
   * @memberof LinkTokenRequest
   */
  response_type: string;
  /**
   *
   * @type {string}
   * @memberof LinkTokenRequest
   */
  response_mode: string;
  /**
   * required when creating new Link, ignored when updating existing Link
   * @type {string}
   * @memberof LinkTokenRequest
   */
  user_id?: string;
  /**
   *
   * @type {string}
   * @memberof LinkTokenRequest
   */
  client_id: string;
  /**
   *
   * @type {string}
   * @memberof LinkTokenRequest
   */
  redirect_uri: string;
  /**
   *
   * @type {string}
   * @memberof LinkTokenRequest
   */
  state?: string;
  /**
   *
   * @type {string}
   * @memberof LinkTokenRequest
   */
  scope?: string;
  /**
   * Space separated list of the tags of the institutions to view.
   * @type {string}
   * @memberof LinkTokenRequest
   */
  link_mode?: string;
  /**
   * The UI mode link is intended to be used in - \"iframe\", \"auto_redirect\", \"redirect\" or \"standalone\"
   * @type {string}
   * @memberof LinkTokenRequest
   */
  ui_mode?: LinkTokenRequestUiModeEnum;
  /**
   * ISO639-1 language code. Language to display when user open the link, default to English (en) if not specified
   * @type {string}
   * @memberof LinkTokenRequest
   */
  language?: string;
  /**
   *
   * @type {string}
   * @memberof LinkTokenRequest
   */
  code_challenge?: string;
  /**
   *
   * @type {string}
   * @memberof LinkTokenRequest
   */
  code_challenge_method?: string;
  /**
   * use this to update a specific login identity
   * @type {string}
   * @memberof LinkTokenRequest
   */
  login_identity_id?: string;
  /**
   * The customization id if the customer wishes to embed it into link token for spawning link with their choice of stuffs
   * @type {string}
   * @memberof LinkTokenRequest
   */
  customization_id?: string;
  /**
   * Institution to preselect
   * @type {string}
   * @memberof LinkTokenRequest
   */
  institution_id?: string;
  /**
   * institution\'s country filter
   * @type {Array<string>}
   * @memberof LinkTokenRequest
   */
  countries?: Array<string>;
  /**
   * institution\'s supported user_type filter
   * @type {Array<string>}
   * @memberof LinkTokenRequest
   */
  user_type?: Array<string>;
  /**
   * institution\'s supported product filter
   * @type {Array<string>}
   * @memberof LinkTokenRequest
   */
  products_supported?: Array<string>;
  /**
   * products that is requested
   * @type {Array<string>}
   * @memberof LinkTokenRequest
   */
  products_requested?: Array<string>;
  /**
   * The identifier returned after creating payment instruction
   * @type {string}
   * @memberof LinkTokenRequest
   */
  payment_instruction_id?: string;
  /**
   * Controls the behavior of the automatic data refresh checkbox
   * @type {string}
   * @memberof LinkTokenRequest
   */
  automatic_data_refresh?: LinkTokenRequestAutomaticDataRefreshEnum;
  /**
   * institution\'s status filter
   * @type {string}
   * @memberof LinkTokenRequest
   */
  institution_status?: string;
}

export const LinkTokenRequestUiModeEnum = {
  Iframe: 'iframe',
  Redirect: 'redirect',
  AutoRedirect: 'auto_redirect',
  Standalone: 'standalone',
} as const;

export type LinkTokenRequestUiModeEnum = (typeof LinkTokenRequestUiModeEnum)[keyof typeof LinkTokenRequestUiModeEnum];
export const LinkTokenRequestAutomaticDataRefreshEnum = {
  On: 'ON',
  Off: 'OFF',
  ForcedOn: 'FORCED_ON',
} as const;

export type LinkTokenRequestAutomaticDataRefreshEnum =
  (typeof LinkTokenRequestAutomaticDataRefreshEnum)[keyof typeof LinkTokenRequestAutomaticDataRefreshEnum];

/**
 *
 * @export
 * @interface LinkTokenResponse
 */
export interface LinkTokenResponse {
  /**
   *
   * @type {string}
   * @memberof LinkTokenResponse
   */
  access_token: string;
  /**
   *
   * @type {string}
   * @memberof LinkTokenResponse
   */
  token_type: string;
  /**
   * seconds
   * @type {number}
   * @memberof LinkTokenResponse
   */
  expires_in: number;
  /**
   *
   * @type {string}
   * @memberof LinkTokenResponse
   */
  issued_at: string;
  /**
   *
   * @type {string}
   * @memberof LinkTokenResponse
   */
  link_url: string;
}
/**
 *
 * @export
 * @interface ListAccountsResponse
 */
export interface ListAccountsResponse {
  /**
   *
   * @type {Array<Account>}
   * @memberof ListAccountsResponse
   */
  accounts?: Array<Account>;
  /**
   *
   * @type {LoginIdentityShort}
   * @memberof ListAccountsResponse
   */
  login_identity?: LoginIdentityShort;
  /**
   *
   * @type {InstitutionShort}
   * @memberof ListAccountsResponse
   */
  institution?: InstitutionShort;
}
/**
 *
 * @export
 * @interface ListCardsDetailsResponse
 */
export interface ListCardsDetailsResponse {
  /**
   *
   * @type {LoginIdentityShort}
   * @memberof ListCardsDetailsResponse
   */
  login_identity?: LoginIdentityShort;
  /**
   *
   * @type {InstitutionShort}
   * @memberof ListCardsDetailsResponse
   */
  institution?: InstitutionShort;
  /**
   *
   * @type {CardDetails}
   * @memberof ListCardsDetailsResponse
   */
  card_details?: CardDetails;
}
/**
 *
 * @export
 * @interface ListMandatesResponse
 */
export interface ListMandatesResponse {
  /**
   *
   * @type {Array<GetMandateResponse>}
   * @memberof ListMandatesResponse
   */
  mandates?: Array<GetMandateResponse>;
  /**
   *
   * @type {number}
   * @memberof ListMandatesResponse
   */
  total_mandates: number;
}
/**
 *
 * @export
 * @interface ListPaymentAccountsResponse
 */
export interface ListPaymentAccountsResponse {
  /**
   *
   * @type {Array<PaymentAccountDetails>}
   * @memberof ListPaymentAccountsResponse
   */
  payment_accounts?: Array<PaymentAccountDetails>;
}
/**
 *
 * @export
 * @interface ListPaymentsResponse
 */
export interface ListPaymentsResponse {
  /**
   *
   * @type {Array<PaymentResponse>}
   * @memberof ListPaymentsResponse
   */
  payments?: Array<PaymentResponse>;
  /**
   *
   * @type {number}
   * @memberof ListPaymentsResponse
   */
  total_payments: number;
}
/**
 *
 * @export
 * @interface ListTransactionsResponse
 */
export interface ListTransactionsResponse {
  /**
   *
   * @type {Array<Account>}
   * @memberof ListTransactionsResponse
   */
  accounts?: Array<Account>;
  /**
   *
   * @type {Array<Transaction>}
   * @memberof ListTransactionsResponse
   */
  transactions?: Array<Transaction>;
  /**
   *
   * @type {LoginIdentityShort}
   * @memberof ListTransactionsResponse
   */
  login_identity?: LoginIdentityShort;
  /**
   *
   * @type {InstitutionShort}
   * @memberof ListTransactionsResponse
   */
  institution?: InstitutionShort;
  /**
   *
   * @type {number}
   * @memberof ListTransactionsResponse
   */
  total_transactions: number;
}
/**
 *
 * @export
 * @interface LoginAction
 */
export interface LoginAction {
  /**
   *
   * @type {string}
   * @memberof LoginAction
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof LoginAction
   */
  name?: string;
  /**
   *
   * @type {Array<UserMessage>}
   * @memberof LoginAction
   */
  messages?: Array<UserMessage>;
  /**
   *
   * @type {Array<UserField>}
   * @memberof LoginAction
   */
  fields?: Array<UserField>;
  /**
   *
   * @type {Array<UserButton>}
   * @memberof LoginAction
   */
  buttons?: Array<UserButton>;
}
/**
 *
 * @export
 * @interface LoginField
 */
export interface LoginField {
  /**
   *
   * @type {string}
   * @memberof LoginField
   */
  key?: string;
  /**
   *
   * @type {string}
   * @memberof LoginField
   */
  name?: string;
  /**
   * could be password, text, number
   * @type {string}
   * @memberof LoginField
   */
  type?: string;
}
/**
 *
 * @export
 * @interface LoginIdentity
 */
export interface LoginIdentity {
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  login_identity_id?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  customer_app_id: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  user_id: string;
  /**
   *
   * @type {LoginIdentityLoginMethodsAvailable}
   * @memberof LoginIdentity
   */
  login_methods_available?: LoginIdentityLoginMethodsAvailable;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  permissions_grant_date?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  permissions_expiry_date?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof LoginIdentity
   */
  permissions?: Array<string>;
  /**
   *
   * @type {LoginIdentityBillingDetails}
   * @memberof LoginIdentity
   */
  billing_details?: LoginIdentityBillingDetails;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  status?: string;
  /**
   *
   * @type {LoginIdentityStatusDetails}
   * @memberof LoginIdentity
   */
  status_details?: LoginIdentityStatusDetails;
  /**
   *
   * @type {AllProductStatus}
   * @memberof LoginIdentity
   */
  product_status?: AllProductStatus;
  /**
   *
   * @type {ProductStatus}
   * @memberof LoginIdentity
   */
  authentication_status?: ProductStatus;
  /**
   *
   * @type {LoginIdentityError}
   * @memberof LoginIdentity
   */
  error?: LoginIdentityError;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  last_success?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  first_success?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  webhook?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  session_status?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  institution_id: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  updated_at?: string;
  /**
   * a login attempt id which is unique per login_identity
   * @type {string}
   * @memberof LoginIdentity
   */
  linking_attempt_id?: string;
  /**
   * a successful login attempt id which is unique per login_identity
   * @type {string}
   * @memberof LoginIdentity
   */
  authentication_id?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentity
   */
  last_session_id?: string;
  /**
   *
   * @type {RefreshData}
   * @memberof LoginIdentity
   */
  refresh?: RefreshData;
}
/**
 *
 * @export
 * @interface LoginIdentityBillingDetails
 */
export interface LoginIdentityBillingDetails {
  /**
   *
   * @type {Array<string>}
   * @memberof LoginIdentityBillingDetails
   */
  billed_products?: Array<string>;
}
/**
 *
 * @export
 * @interface LoginIdentityError
 */
export interface LoginIdentityError {
  /**
   *
   * @type {number}
   * @memberof LoginIdentityError
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof LoginIdentityError
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentityError
   */
  message?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentityError
   */
  details?: string;
}
/**
 *
 * @export
 * @interface LoginIdentityLoginMethodsAvailable
 */
export interface LoginIdentityLoginMethodsAvailable {
  /**
   *
   * @type {boolean}
   * @memberof LoginIdentityLoginMethodsAvailable
   */
  havePassword?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof LoginIdentityLoginMethodsAvailable
   */
  haveSecret?: boolean;
}
/**
 *
 * @export
 * @interface LoginIdentityShort
 */
export interface LoginIdentityShort {
  /**
   *
   * @type {string}
   * @memberof LoginIdentityShort
   */
  login_identity_id?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentityShort
   */
  status?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentityShort
   */
  last_session_id?: string;
}
/**
 *
 * @export
 * @interface LoginIdentityStatusDetails
 */
export interface LoginIdentityStatusDetails {
  /**
   *
   * @type {string}
   * @memberof LoginIdentityStatusDetails
   */
  event_date?: string;
  /**
   *
   * @type {string}
   * @memberof LoginIdentityStatusDetails
   */
  event_name?: string;
}
/**
 *
 * @export
 * @interface LoginMethod
 */
export interface LoginMethod {
  /**
   *
   * @type {string}
   * @memberof LoginMethod
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof LoginMethod
   */
  name?: string;
  /**
   *
   * @type {boolean}
   * @memberof LoginMethod
   */
  is_default_method?: boolean | null;
  /**
   *
   * @type {string}
   * @memberof LoginMethod
   */
  status?: LoginMethodStatusEnum;
  /**
   *
   * @type {Array<LoginField>}
   * @memberof LoginMethod
   */
  login_fields?: Array<LoginField>;
}

export const LoginMethodStatusEnum = {
  Supported: 'SUPPORTED',
  Alpha: 'ALPHA',
  Beta: 'BETA',
} as const;

export type LoginMethodStatusEnum = (typeof LoginMethodStatusEnum)[keyof typeof LoginMethodStatusEnum];

/**
 *
 * @export
 * @interface MandateAuthEncryptionInfo
 */
export interface MandateAuthEncryptionInfo {
  /**
   *
   * @type {string}
   * @memberof MandateAuthEncryptionInfo
   */
  jwks_url: string;
  /**
   *
   * @type {string}
   * @memberof MandateAuthEncryptionInfo
   */
  key_id: string;
}
/**
 *
 * @export
 * @interface MandateAuthLinkCustomizations
 */
export interface MandateAuthLinkCustomizations {
  /**
   * institution\'s country filter
   * @type {Array<string>}
   * @memberof MandateAuthLinkCustomizations
   */
  countries?: Array<string>;
  /**
   * Institution to preselect
   * @type {string}
   * @memberof MandateAuthLinkCustomizations
   */
  institution_id?: string;
  /**
   * institution\'s status filter
   * @type {string}
   * @memberof MandateAuthLinkCustomizations
   */
  institution_status?: string;
  /**
   * ISO639-1 language code. Language to display when user open the link, default to English (en) if not specified
   * @type {string}
   * @memberof MandateAuthLinkCustomizations
   */
  language?: string;
  /**
   * Space separated list of the tags of the institutions to view.
   * @type {string}
   * @memberof MandateAuthLinkCustomizations
   */
  link_mode?: string;
  /**
   * institution\'s supported product filter. For mandate authorization, this field should contain [\"MANDATE\"]
   * @type {Array<string>}
   * @memberof MandateAuthLinkCustomizations
   */
  products_supported?: Array<string>;
  /**
   * The UI mode link is intended to be used in - \"iframe\", \"auto_redirect\", \"redirect\" or \"standalone\"
   * @type {string}
   * @memberof MandateAuthLinkCustomizations
   */
  ui_mode?: MandateAuthLinkCustomizationsUiModeEnum;
  /**
   * The URI to redirect to. Required if ui_mode is \"redirect\" or \"auto_redirect\"
   * @type {string}
   * @memberof MandateAuthLinkCustomizations
   */
  redirect_uri?: string;
  /**
   * institution\'s supported user_type filter
   * @type {Array<string>}
   * @memberof MandateAuthLinkCustomizations
   */
  user_type?: Array<string>;
}

export const MandateAuthLinkCustomizationsUiModeEnum = {
  Iframe: 'iframe',
  Redirect: 'redirect',
  AutoRedirect: 'auto_redirect',
  Standalone: 'standalone',
} as const;

export type MandateAuthLinkCustomizationsUiModeEnum =
  (typeof MandateAuthLinkCustomizationsUiModeEnum)[keyof typeof MandateAuthLinkCustomizationsUiModeEnum];

/**
 *
 * @export
 * @interface MandateDetails
 */
export interface MandateDetails {
  /**
   * ISO currency code
   * @type {string}
   * @memberof MandateDetails
   */
  currency: string;
  /**
   * YYYY-MM-DD, must be later than or the same as the date of creation. If unspecified, default to the date of creation.
   * @type {string}
   * @memberof MandateDetails
   */
  start_date?: string | null;
  /**
   * YYYY-MM-DD, must be later than the date of creation.
   * @type {string}
   * @memberof MandateDetails
   */
  end_date?: string | null;
  /**
   *
   * @type {PaymentSchedule}
   * @memberof MandateDetails
   */
  payment_schedule?: PaymentSchedule;
  /**
   *
   * @type {TransactionLimits}
   * @memberof MandateDetails
   */
  transaction_limits?: TransactionLimits;
  /**
   * End-user facing description of the mandate (used in notifications, and in payments if no description is provided)
   * @type {string}
   * @memberof MandateDetails
   */
  description?: string;
  /**
   * A bank specific reference, what the end user may see
   * @type {string}
   * @memberof MandateDetails
   */
  mandate_bank_reference?: string;
}
/**
 *
 * @export
 * @interface MandateDetailsForPaymentLink
 */
export interface MandateDetailsForPaymentLink {
  /**
   * YYYY-MM-DD, must be later than or the same as the date of creation. If unspecified, default to the date of creation.
   * @type {string}
   * @memberof MandateDetailsForPaymentLink
   */
  start_date?: string | null;
  /**
   * YYYY-MM-DD, must be later than the date of creation.
   * @type {string}
   * @memberof MandateDetailsForPaymentLink
   */
  end_date?: string | null;
  /**
   *
   * @type {TransactionLimits}
   * @memberof MandateDetailsForPaymentLink
   */
  transaction_limits?: TransactionLimits;
  /**
   * End-user facing description of the mandate (used in notifications, and in payments if no description is provided)
   * @type {string}
   * @memberof MandateDetailsForPaymentLink
   */
  description?: string;
}
/**
 *
 * @export
 * @interface MandateFvLinkResponse
 */
export interface MandateFvLinkResponse {
  /**
   *
   * @type {string}
   * @memberof MandateFvLinkResponse
   */
  mandate_id?: string;
  /**
   *
   * @type {string}
   * @memberof MandateFvLinkResponse
   */
  institution_id?: string;
  /**
   *
   * @type {string}
   * @memberof MandateFvLinkResponse
   */
  mandate_status?: string;
  /**
   *
   * @type {MandateRecipient}
   * @memberof MandateFvLinkResponse
   */
  recipient?: MandateRecipient;
  /**
   *
   * @type {SenderAccountFvLinkResponse}
   * @memberof MandateFvLinkResponse
   */
  sender_account?: SenderAccountFvLinkResponse;
  /**
   *
   * @type {FvErrorModelV2}
   * @memberof MandateFvLinkResponse
   */
  error?: FvErrorModelV2;
}
/**
 *
 * @export
 * @interface MandateRecipient
 */
export interface MandateRecipient {
  /**
   * Merchant account name
   * @type {string}
   * @memberof MandateRecipient
   */
  name: string;
}
/**
 *
 * @export
 * @interface MandateRecipientAccount
 */
export interface MandateRecipientAccount {
  /**
   * Merchant account ID assigned by Finverse
   * @type {string}
   * @memberof MandateRecipientAccount
   */
  account_id: string;
  /**
   * Type of recipient account.
   * @type {string}
   * @memberof MandateRecipientAccount
   */
  account_type: MandateRecipientAccountAccountTypeEnum;
}

export const MandateRecipientAccountAccountTypeEnum = {
  ExternalAccount: 'EXTERNAL_ACCOUNT',
  SettlementAccount: 'SETTLEMENT_ACCOUNT',
} as const;

export type MandateRecipientAccountAccountTypeEnum =
  (typeof MandateRecipientAccountAccountTypeEnum)[keyof typeof MandateRecipientAccountAccountTypeEnum];

/**
 *
 * @export
 * @interface MandateRecipientRequest
 */
export interface MandateRecipientRequest {
  /**
   * Merchant account ID assigned by Finverse
   * @type {string}
   * @memberof MandateRecipientRequest
   */
  account_id: string;
}
/**
 *
 * @export
 * @interface MandateSenderAccount
 */
export interface MandateSenderAccount {
  /**
   * A unique identifier generated after creating sender account
   * @type {string}
   * @memberof MandateSenderAccount
   */
  account_id?: string;
  /**
   * Accountholder name of the sender\'s account
   * @type {string}
   * @memberof MandateSenderAccount
   */
  accountholder_name?: string;
  /**
   *
   * @type {RecipientAccountNumber}
   * @memberof MandateSenderAccount
   */
  account_number?: RecipientAccountNumber;
  /**
   * Masked Account number of the sender’s account
   * @type {string}
   * @memberof MandateSenderAccount
   */
  account_number_masked?: string;
  /**
   * Type of sender account.
   * @type {string}
   * @memberof MandateSenderAccount
   */
  account_type?: MandateSenderAccountAccountTypeEnum;
  /**
   * Finverse Institution ID for the sender’s institution.
   * @type {string}
   * @memberof MandateSenderAccount
   */
  institution_id?: string;
  /**
   * A unique identifier generated after creating sender (Finverse Payment User ID)
   * @type {string}
   * @memberof MandateSenderAccount
   */
  user_id?: string;
  /**
   *
   * @type {string}
   * @memberof MandateSenderAccount
   */
  bank_code?: string;
  /**
   * Additional attributes of the sender account in key:value format (e.g. sender_id: 1234). It supports up to 10 key:value pairs, whereas the key and value supports up to 50 and 500 characters respectively.
   * @type {{ [key: string]: string; }}
   * @memberof MandateSenderAccount
   */
  metadata?: { [key: string]: string };
}

export const MandateSenderAccountAccountTypeEnum = {
  ExternalAccount: 'EXTERNAL_ACCOUNT',
} as const;

export type MandateSenderAccountAccountTypeEnum =
  (typeof MandateSenderAccountAccountTypeEnum)[keyof typeof MandateSenderAccountAccountTypeEnum];

/**
 *
 * @export
 * @interface MandateSenderAccountRequest
 */
export interface MandateSenderAccountRequest {
  /**
   * account ID assigned by Finverse
   * @type {string}
   * @memberof MandateSenderAccountRequest
   */
  account_id: string;
}
/**
 *
 * @export
 * @interface ManualPaymentConfirmationRequest
 */
export interface ManualPaymentConfirmationRequest {
  /**
   *
   * @type {string}
   * @memberof ManualPaymentConfirmationRequest
   */
  accountholder_name: string;
}
/**
 *
 * @export
 * @interface ManualPaymentConfirmationResponse
 */
export interface ManualPaymentConfirmationResponse {
  /**
   *
   * @type {string}
   * @memberof ManualPaymentConfirmationResponse
   */
  payment_id?: string;
}
/**
 *
 * @export
 * @interface MonthlyIncomeEstimate
 */
export interface MonthlyIncomeEstimate {
  /**
   *
   * @type {IncomeEstimate}
   * @memberof MonthlyIncomeEstimate
   */
  estimated_income: IncomeEstimate;
  /**
   * The numeric month
   * @type {number}
   * @memberof MonthlyIncomeEstimate
   */
  month: number;
  /**
   * The year
   * @type {number}
   * @memberof MonthlyIncomeEstimate
   */
  year: number;
}
/**
 *
 * @export
 * @interface NonSensitiveLinkStatusResponse
 */
export interface NonSensitiveLinkStatusResponse {
  /**
   *
   * @type {LinkStatusActionModel}
   * @memberof NonSensitiveLinkStatusResponse
   */
  action?: LinkStatusActionModel;
  /**
   *
   * @type {string}
   * @memberof NonSensitiveLinkStatusResponse
   */
  redirect_uri?: string;
}
/**
 *
 * @export
 * @interface OtherInfo
 */
export interface OtherInfo {
  /**
   *
   * @type {string}
   * @memberof OtherInfo
   */
  bank_code?: string;
}
/**
 *
 * @export
 * @interface PaymentAccount
 */
export interface PaymentAccount {
  /**
   * The raw value for the account the user selected when making payment request
   * @type {string}
   * @memberof PaymentAccount
   */
  raw?: string;
  /**
   * Finverse Institution ID. Only returned if institution_id was included in the request.
   * @type {string}
   * @memberof PaymentAccount
   */
  institution_id?: string;
}
/**
 *
 * @export
 * @interface PaymentAccountDetails
 */
export interface PaymentAccountDetails {
  /**
   * Payment account id
   * @type {string}
   * @memberof PaymentAccountDetails
   */
  account_id?: string;
  /**
   *
   * @type {RecipientAccountNumber}
   * @memberof PaymentAccountDetails
   */
  account_number?: RecipientAccountNumber;
  /**
   * Masked Account number of the payment account
   * @type {string}
   * @memberof PaymentAccountDetails
   */
  account_number_masked?: string;
  /**
   * Type of payment account.
   * @type {string}
   * @memberof PaymentAccountDetails
   */
  account_type?: PaymentAccountDetailsAccountTypeEnum;
  /**
   * Accountholder name of the payment account
   * @type {string}
   * @memberof PaymentAccountDetails
   */
  accountholder_name?: string;
  /**
   * Finverse Institution ID for the payment institution.
   * @type {string}
   * @memberof PaymentAccountDetails
   */
  institution_id?: string;
  /**
   * A unique identifier generated after creating user (Finverse Payment User ID)
   * @type {string}
   * @memberof PaymentAccountDetails
   */
  user_id?: string;
  /**
   * 3-digit code associated with bank
   * @type {string}
   * @memberof PaymentAccountDetails
   */
  bank_code?: string;
  /**
   * 3-digit code used to identify specific bank branch
   * @type {string}
   * @memberof PaymentAccountDetails
   */
  branch_code?: string;
  /**
   * List of currencies supported by the payment account
   * @type {Array<string>}
   * @memberof PaymentAccountDetails
   */
  currencies?: Array<string>;
  /**
   * Additional attributes of the sender account in key:value format (e.g. sender_id: 1234). It supports up to 10 key:value pairs, whereas the key and value supports up to 50 and 500 characters respectively.
   * @type {{ [key: string]: string; }}
   * @memberof PaymentAccountDetails
   */
  metadata?: { [key: string]: string };
  /**
   * Timestamp of when the payment link was created in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
   * @type {string}
   * @memberof PaymentAccountDetails
   */
  created_at?: string;
  /**
   * Timestamp of when the payment link was last updated in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
   * @type {string}
   * @memberof PaymentAccountDetails
   */
  updated_at?: string;
}

export const PaymentAccountDetailsAccountTypeEnum = {
  ExternalAccount: 'EXTERNAL_ACCOUNT',
  SettlementAccount: 'SETTLEMENT_ACCOUNT',
} as const;

export type PaymentAccountDetailsAccountTypeEnum =
  (typeof PaymentAccountDetailsAccountTypeEnum)[keyof typeof PaymentAccountDetailsAccountTypeEnum];

/**
 *
 * @export
 * @interface PaymentDetails
 */
export interface PaymentDetails {
  /**
   *
   * @type {string}
   * @memberof PaymentDetails
   */
  format?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentDetails
   */
  bic?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentDetails
   */
  bank_fullname?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentDetails
   */
  bank_shortname?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentDetails
   */
  bank_address?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentDetails
   */
  bank_country?: string;
  /**
   *
   * @type {OtherInfo}
   * @memberof PaymentDetails
   */
  other_info?: OtherInfo;
}
/**
 *
 * @export
 * @interface PaymentDetails2
 */
export interface PaymentDetails2 {
  /**
   * The transaction description provided to banks, which banks will show to their customers.
   * @type {string}
   * @memberof PaymentDetails2
   */
  description?: string;
  /**
   * ID of the mandate this pament is referring to.
   * @type {string}
   * @memberof PaymentDetails2
   */
  mandate_id?: string;
  /**
   * ID of the payment method this pament is referring to.
   * @type {string}
   * @memberof PaymentDetails2
   */
  payment_method_id?: string;
  /**
   * Customer\'s ID for this transaction
   * @type {string}
   * @memberof PaymentDetails2
   */
  transaction_reference_id?: string;
}
/**
 *
 * @export
 * @interface PaymentInfo
 */
export interface PaymentInfo {
  /**
   *
   * @type {Array<string>}
   * @memberof PaymentInfo
   */
  currencies_supported?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof PaymentInfo
   */
  payments_supported: Array<PaymentInfoPaymentsSupportedEnum>;
  /**
   *
   * @type {OtherInfo}
   * @memberof PaymentInfo
   */
  other_info?: OtherInfo;
}

export const PaymentInfoPaymentsSupportedEnum = {
  Mandate: 'MANDATE',
  DebitAuthorization: 'DEBIT_AUTHORIZATION',
} as const;

export type PaymentInfoPaymentsSupportedEnum =
  (typeof PaymentInfoPaymentsSupportedEnum)[keyof typeof PaymentInfoPaymentsSupportedEnum];

/**
 *
 * @export
 * @interface PaymentInstruction
 */
export interface PaymentInstruction {
  /**
   * An id of the this payment
   * @type {string}
   * @memberof PaymentInstruction
   */
  payment_instruction_id?: string;
  /**
   * An id of the user of this payment, need to equal to userId when creating link
   * @type {string}
   * @memberof PaymentInstruction
   */
  user_id?: string;
  /**
   * An id that links this payment to a specific Login Identity
   * @type {string}
   * @memberof PaymentInstruction
   */
  login_identity_id?: string;
  /**
   * Type of payment that was created, please check Documentation on which payment type is supported in each institution
   * @type {string}
   * @memberof PaymentInstruction
   */
  type?: PaymentInstructionTypeEnum;
  /**
   * The recipient name
   * @type {string}
   * @memberof PaymentInstruction
   */
  recipient_name?: string;
  /**
   * The recipient account Id
   * @type {string}
   * @memberof PaymentInstruction
   */
  recipient_account_id?: string;
  /**
   * The sender name
   * @type {string}
   * @memberof PaymentInstruction
   */
  sender_name?: string;
  /**
   *
   * @type {PaymentAccount}
   * @memberof PaymentInstruction
   */
  sender_account?: PaymentAccount;
  /**
   * The sender account Id
   * @type {string}
   * @memberof PaymentInstruction
   */
  sender_account_id?: string;
  /**
   * When the payment should start
   * @type {string}
   * @memberof PaymentInstruction
   */
  start_date?: string | null;
  /**
   * When the payment should stop
   * @type {string}
   * @memberof PaymentInstruction
   */
  end_date?: string | null;
  /**
   * The currency for the payment
   * @type {string}
   * @memberof PaymentInstruction
   */
  currency?: string;
  /**
   * The payment amount
   * @type {number}
   * @memberof PaymentInstruction
   */
  amount?: number;
  /**
   * How often the payment should be executed
   * @type {string}
   * @memberof PaymentInstruction
   */
  frequency?: string;
  /**
   * Related remarks about this instruction
   * @type {string}
   * @memberof PaymentInstruction
   */
  remarks?: string;
  /**
   * Status of the payment
   * @type {string}
   * @memberof PaymentInstruction
   */
  status?: string;
  /**
   * Reference identification returned by institution
   * @type {string}
   * @memberof PaymentInstruction
   */
  reference_id?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentInstruction
   */
  last_update?: string;
  /**
   * Extra information collected for this payment instruction
   * @type {object}
   * @memberof PaymentInstruction
   */
  info?: object;
}

export const PaymentInstructionTypeEnum = {
  DebitAuthorization: 'DEBIT_AUTHORIZATION',
} as const;

export type PaymentInstructionTypeEnum = (typeof PaymentInstructionTypeEnum)[keyof typeof PaymentInstructionTypeEnum];

/**
 *
 * @export
 * @interface PaymentLinkCustomizations
 */
export interface PaymentLinkCustomizations {
  /**
   * ISO639-1 language code. Language to display when user open the link, default to English (en) if not specified
   * @type {string}
   * @memberof PaymentLinkCustomizations
   */
  language?: string;
  /**
   * The UI mode link is intended to be used in - \"iframe\", \"auto_redirect\", \"redirect\" or \"standalone\"
   * @type {string}
   * @memberof PaymentLinkCustomizations
   */
  ui_mode?: PaymentLinkCustomizationsUiModeEnum;
  /**
   * URI to redirect to. Only needed if ui_mode = redirect
   * @type {string}
   * @memberof PaymentLinkCustomizations
   */
  redirect_uri?: string;
}

export const PaymentLinkCustomizationsUiModeEnum = {
  Iframe: 'iframe',
  Redirect: 'redirect',
  AutoRedirect: 'auto_redirect',
  Standalone: 'standalone',
} as const;

export type PaymentLinkCustomizationsUiModeEnum =
  (typeof PaymentLinkCustomizationsUiModeEnum)[keyof typeof PaymentLinkCustomizationsUiModeEnum];

/**
 *
 * @export
 * @interface PaymentLinkDetails
 */
export interface PaymentLinkDetails {
  /**
   *
   * @type {string}
   * @memberof PaymentLinkDetails
   */
  description?: string;
  /**
   * For external invoice reference
   * @type {string}
   * @memberof PaymentLinkDetails
   */
  external_invoice_number?: string;
}
/**
 *
 * @export
 * @interface PaymentLinkResponse
 */
export interface PaymentLinkResponse {
  /**
   * Finverse Payment Link ID
   * @type {string}
   * @memberof PaymentLinkResponse
   */
  payment_link_id?: string;
  /**
   * The amount of the payment. Expressed in currency\'s smallest unit or “minor unit”, as defined in ISO 4217.
   * @type {number}
   * @memberof PaymentLinkResponse
   */
  amount?: number;
  /**
   *
   * @type {string}
   * @memberof PaymentLinkResponse
   */
  currency?: string;
  /**
   *
   * @type {PaymentLinkCustomizations}
   * @memberof PaymentLinkResponse
   */
  link_customizations?: PaymentLinkCustomizations;
  /**
   * The payment link mode
   * @type {string}
   * @memberof PaymentLinkResponse
   */
  mode?: PaymentLinkResponseModeEnum;
  /**
   *
   * @type {PaymentLinkDetails}
   * @memberof PaymentLinkResponse
   */
  payment_details?: PaymentLinkDetails;
  /**
   * Unique reference id to identifying the payment to be collected.
   * @type {string}
   * @memberof PaymentLinkResponse
   */
  unique_reference_id?: string;
  /**
   *
   * @type {PaymentSetupOptions}
   * @memberof PaymentLinkResponse
   */
  payment_setup_options?: PaymentSetupOptions;
  /**
   * Additional attributes of the payment link in key:value format (e.g. payment_id: 1234). It supports up to 10 key:value pairs, whereas the key and value supports up to 50 and 500 characters respectively.
   * @type {{ [key: string]: string; }}
   * @memberof PaymentLinkResponse
   */
  metadata?: { [key: string]: string };
  /**
   * The URL for payment link
   * @type {string}
   * @memberof PaymentLinkResponse
   */
  url?: string;
  /**
   * The status of payment link
   * @type {string}
   * @memberof PaymentLinkResponse
   */
  status?: PaymentLinkResponseStatusEnum;
  /**
   * Timestamp of when the payment link was or will expired in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
   * @type {string}
   * @memberof PaymentLinkResponse
   */
  expires_at?: string;
  /**
   * Timestamp of when the payment link was created in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
   * @type {string}
   * @memberof PaymentLinkResponse
   */
  created_at?: string;
  /**
   * Timestamp of when the payment link was last updated in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
   * @type {string}
   * @memberof PaymentLinkResponse
   */
  updated_at?: string;
  /**
   *
   * @type {PaymentResponse}
   * @memberof PaymentLinkResponse
   */
  payment?: PaymentResponse;
  /**
   *
   * @type {PaymentLinkSenderResponse}
   * @memberof PaymentLinkResponse
   */
  sender?: PaymentLinkSenderResponse;
  /**
   *
   * @type {PaymentMethodResponse}
   * @memberof PaymentLinkResponse
   */
  payment_method?: PaymentMethodResponse;
}

export const PaymentLinkResponseModeEnum = {
  Payment: 'PAYMENT',
} as const;

export type PaymentLinkResponseModeEnum =
  (typeof PaymentLinkResponseModeEnum)[keyof typeof PaymentLinkResponseModeEnum];
export const PaymentLinkResponseStatusEnum = {
  Created: 'CREATED',
  Paid: 'PAID',
  Expired: 'EXPIRED',
} as const;

export type PaymentLinkResponseStatusEnum =
  (typeof PaymentLinkResponseStatusEnum)[keyof typeof PaymentLinkResponseStatusEnum];

/**
 *
 * @export
 * @interface PaymentLinkSender
 */
export interface PaymentLinkSender {
  /**
   *
   * @type {string}
   * @memberof PaymentLinkSender
   */
  email?: string;
  /**
   * Customer App\'s user ID, representing the end-user making the payment.
   * @type {string}
   * @memberof PaymentLinkSender
   */
  external_user_id: string;
  /**
   * Accountholder name of the sender\'s account
   * @type {string}
   * @memberof PaymentLinkSender
   */
  name: string;
}
/**
 *
 * @export
 * @interface PaymentLinkSenderResponse
 */
export interface PaymentLinkSenderResponse {
  /**
   *
   * @type {string}
   * @memberof PaymentLinkSenderResponse
   */
  email?: string;
  /**
   * Customer App\'s user ID, representing the end-user making the payment.
   * @type {string}
   * @memberof PaymentLinkSenderResponse
   */
  external_user_id?: string;
  /**
   * Accountholder name of the sender\'s account
   * @type {string}
   * @memberof PaymentLinkSenderResponse
   */
  name?: string;
  /**
   * A unique identifier generated after creating sender
   * @type {string}
   * @memberof PaymentLinkSenderResponse
   */
  user_id?: string;
}
/**
 *
 * @export
 * @interface PaymentLinkTokenResponse
 */
export interface PaymentLinkTokenResponse {
  /**
   * Short-lived access-token to interact with Finverse Link
   * @type {string}
   * @memberof PaymentLinkTokenResponse
   */
  access_token: string;
  /**
   * Access token validity duration (in seconds)
   * @type {number}
   * @memberof PaymentLinkTokenResponse
   */
  expires_in: number;
  /**
   * URL to launch Finverse Link to authorize the mandate
   * @type {string}
   * @memberof PaymentLinkTokenResponse
   */
  link_url: string;
  /**
   * The FPS QR code in base64
   * @type {string}
   * @memberof PaymentLinkTokenResponse
   */
  qr_code?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentLinkTokenResponse
   */
  token_type: PaymentLinkTokenResponseTokenTypeEnum;
}

export const PaymentLinkTokenResponseTokenTypeEnum = {
  Bearer: 'Bearer',
} as const;

export type PaymentLinkTokenResponseTokenTypeEnum =
  (typeof PaymentLinkTokenResponseTokenTypeEnum)[keyof typeof PaymentLinkTokenResponseTokenTypeEnum];

/**
 *
 * @export
 * @interface PaymentMethodFvLinkResponse
 */
export interface PaymentMethodFvLinkResponse {
  /**
   *
   * @type {string}
   * @memberof PaymentMethodFvLinkResponse
   */
  payment_method_id?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentMethodFvLinkResponse
   */
  payment_method_type?: string;
  /**
   *
   * @type {MandateFvLinkResponse}
   * @memberof PaymentMethodFvLinkResponse
   */
  mandate?: MandateFvLinkResponse;
}
/**
 *
 * @export
 * @interface PaymentMethodResponse
 */
export interface PaymentMethodResponse {
  /**
   *
   * @type {string}
   * @memberof PaymentMethodResponse
   */
  payment_method_id?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentMethodResponse
   */
  payment_method_type?: string;
  /**
   *
   * @type {GetMandateResponse}
   * @memberof PaymentMethodResponse
   */
  mandate?: GetMandateResponse;
}
/**
 *
 * @export
 * @interface PaymentResponse
 */
export interface PaymentResponse {
  /**
   * Finverse Payment ID
   * @type {string}
   * @memberof PaymentResponse
   */
  payment_id?: string;
  /**
   * Amount to be paid, in currency\'s smallest unit or “minor unit”, as defined in ISO 4217. For example, HKD 100.01 is represented as amount = 10001 (minor unit = cents). For currencies without minor units (e.g. VND, JPY), the amount is represented as is, without modification. For example, VND 15101 is represented as amount = 15101.
   * @type {number}
   * @memberof PaymentResponse
   */
  amount?: number;
  /**
   * The currency code as defined in ISO 4217.
   * @type {string}
   * @memberof PaymentResponse
   */
  currency?: string;
  /**
   * Indicates whether this is a mandate-based payment or one-off direct payment to an account. Possible values - MANDATE, SINGLE
   * @type {string}
   * @memberof PaymentResponse
   */
  type?: PaymentResponseTypeEnum;
  /**
   * Timestamp in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
   * @type {string}
   * @memberof PaymentResponse
   */
  updated_at?: string;
  /**
   * Possible values - CREATED, AUTHORIZED, SUBMITTED, EXECUTED, FAILED, REJECTED, CANCELLED.
   * @type {string}
   * @memberof PaymentResponse
   */
  status?: PaymentResponseStatusEnum;
  /**
   *
   * @type {PaymentDetails2}
   * @memberof PaymentResponse
   */
  payment_details?: PaymentDetails2;
  /**
   *
   * @type {MandateRecipient}
   * @memberof PaymentResponse
   */
  recipient?: MandateRecipient;
  /**
   *
   * @type {MandateRecipientAccount}
   * @memberof PaymentResponse
   */
  recipient_account?: MandateRecipientAccount;
  /**
   *
   * @type {GetMandateSender}
   * @memberof PaymentResponse
   */
  sender?: GetMandateSender;
  /**
   *
   * @type {MandateSenderAccount}
   * @memberof PaymentResponse
   */
  sender_account?: MandateSenderAccount;
  /**
   *
   * @type {Array<Fee>}
   * @memberof PaymentResponse
   */
  fees?: Array<Fee>;
  /**
   * Timestamp in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
   * @type {string}
   * @memberof PaymentResponse
   */
  created_at?: string;
  /**
   * Additional attributes of the payment in key:value format (e.g. payment_internal_id: 1234). It supports up to 10 key:value pairs, whereas the key and value supports up to 50 and 500 characters respectively.
   * @type {{ [key: string]: string; }}
   * @memberof PaymentResponse
   */
  metadata?: { [key: string]: string };
  /**
   *
   * @type {FvErrorModelV2}
   * @memberof PaymentResponse
   */
  error?: FvErrorModelV2;
}

export const PaymentResponseTypeEnum = {
  Mandate: 'MANDATE',
  Single: 'SINGLE',
} as const;

export type PaymentResponseTypeEnum = (typeof PaymentResponseTypeEnum)[keyof typeof PaymentResponseTypeEnum];
export const PaymentResponseStatusEnum = {
  AuthorizationRequired: 'AUTHORIZATION_REQUIRED',
  Authorizing: 'AUTHORIZING',
  Processing: 'PROCESSING',
  Submitted: 'SUBMITTED',
  Executed: 'EXECUTED',
  Failed: 'FAILED',
  Revoked: 'REVOKED',
} as const;

export type PaymentResponseStatusEnum = (typeof PaymentResponseStatusEnum)[keyof typeof PaymentResponseStatusEnum];

/**
 *
 * @export
 * @interface PaymentSchedule
 */
export interface PaymentSchedule {
  /**
   * Amount to be paid, in currency’s smallest unit or “minor unit”, as defined in ISO 4217. For example, HKD 100.01 is represented as amount = 10001 (minor unit = cents). For currencies without minor units (e.g. VND, JPY), the amount is represented as is, without modification. For example, VND 15101 is represented as amount = 15101.
   * @type {number}
   * @memberof PaymentSchedule
   */
  amount: number;
  /**
   * Frequency of the payment. Possible values (DAILY, WEEKLY, MONTHLY, QUARTERLY, YEARLY)
   * @type {string}
   * @memberof PaymentSchedule
   */
  frequency: PaymentScheduleFrequencyEnum;
}

export const PaymentScheduleFrequencyEnum = {
  Daily: 'DAILY',
  Weekly: 'WEEKLY',
  Monthly: 'MONTHLY',
  Quarterly: 'QUARTERLY',
  Yearly: 'YEARLY',
} as const;

export type PaymentScheduleFrequencyEnum =
  (typeof PaymentScheduleFrequencyEnum)[keyof typeof PaymentScheduleFrequencyEnum];

/**
 *
 * @export
 * @interface PaymentSetupOptions
 */
export interface PaymentSetupOptions {
  /**
   * The type of future_payments that customer want to use. Possible values: AUTOPAY or CLICK_TO_PAY
   * @type {string}
   * @memberof PaymentSetupOptions
   */
  future_payments?: PaymentSetupOptionsFuturePaymentsEnum;
  /**
   *
   * @type {MandateDetailsForPaymentLink}
   * @memberof PaymentSetupOptions
   */
  mandate_details?: MandateDetailsForPaymentLink;
}

export const PaymentSetupOptionsFuturePaymentsEnum = {
  Autopay: 'AUTOPAY',
  ClickToPay: 'CLICK_TO_PAY',
} as const;

export type PaymentSetupOptionsFuturePaymentsEnum =
  (typeof PaymentSetupOptionsFuturePaymentsEnum)[keyof typeof PaymentSetupOptionsFuturePaymentsEnum];

/**
 *
 * @export
 * @interface PaymentUser
 */
export interface PaymentUser {
  /**
   *
   * @type {string}
   * @memberof PaymentUser
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentUser
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentUser
   */
  external_user_id?: string;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof PaymentUser
   */
  metadata?: { [key: string]: string };
  /**
   *
   * @type {string}
   * @memberof PaymentUser
   */
  name?: string;
  /**
   *
   * @type {Array<SenderDetail>}
   * @memberof PaymentUser
   */
  user_details?: Array<SenderDetail>;
  /**
   *
   * @type {string}
   * @memberof PaymentUser
   */
  updated_at?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentUser
   */
  user_id?: string;
  /**
   *
   * @type {string}
   * @memberof PaymentUser
   */
  user_type?: PaymentUserUserTypeEnum;
  /**
   * Whether the user has given consent for autopay
   * @type {boolean}
   * @memberof PaymentUser
   */
  autopay_consent: boolean;
}

export const PaymentUserUserTypeEnum = {
  Individual: 'INDIVIDUAL',
  Business: 'BUSINESS',
} as const;

export type PaymentUserUserTypeEnum = (typeof PaymentUserUserTypeEnum)[keyof typeof PaymentUserUserTypeEnum];

/**
 *
 * @export
 * @interface PayoutDetails
 */
export interface PayoutDetails {
  /**
   * The mandate used to execute payments for this payout instruction. Currency for the mandate must be supported by the recipient account
   * @type {string}
   * @memberof PayoutDetails
   */
  mandate_id: string;
  /**
   * A description for the payment (that will appear as the transaction description on bank statements)
   * @type {string}
   * @memberof PayoutDetails
   */
  description?: string;
  /**
   * YYYY-MM-DD, date (in UTC) to execute the payment, must be 1 day later than current date
   * @type {string}
   * @memberof PayoutDetails
   */
  scheduled_date: string;
}
/**
 *
 * @export
 * @interface PayoutSnapshotDetails
 */
export interface PayoutSnapshotDetails {
  /**
   *
   * @type {string}
   * @memberof PayoutSnapshotDetails
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof PayoutSnapshotDetails
   */
  transaction_reference_id?: string;
  /**
   *
   * @type {string}
   * @memberof PayoutSnapshotDetails
   */
  mandate_id?: string;
  /**
   *
   * @type {string}
   * @memberof PayoutSnapshotDetails
   */
  scheduled_date?: string;
}
/**
 *
 * @export
 * @interface PayoutSnapshotResponse
 */
export interface PayoutSnapshotResponse {
  /**
   *
   * @type {string}
   * @memberof PayoutSnapshotResponse
   */
  payout_id?: string;
  /**
   *
   * @type {string}
   * @memberof PayoutSnapshotResponse
   */
  status?: string;
  /**
   *
   * @type {string}
   * @memberof PayoutSnapshotResponse
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof PayoutSnapshotResponse
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof PayoutSnapshotResponse
   */
  updated_at?: string;
  /**
   *
   * @type {string}
   * @memberof PayoutSnapshotResponse
   */
  transaction_date?: string;
  /**
   *
   * @type {PayoutSnapshotDetails}
   * @memberof PayoutSnapshotResponse
   */
  payment_details?: PayoutSnapshotDetails;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof PayoutSnapshotResponse
   */
  metadata?: { [key: string]: string };
  /**
   *
   * @type {number}
   * @memberof PayoutSnapshotResponse
   */
  amount?: number;
  /**
   *
   * @type {string}
   * @memberof PayoutSnapshotResponse
   */
  currency?: string;
  /**
   *
   * @type {MandateRecipient}
   * @memberof PayoutSnapshotResponse
   */
  sender?: MandateRecipient;
  /**
   *
   * @type {MandateRecipientAccount}
   * @memberof PayoutSnapshotResponse
   */
  sender_account?: MandateRecipientAccount;
  /**
   *
   * @type {GetMandateSender}
   * @memberof PayoutSnapshotResponse
   */
  recipient?: GetMandateSender;
  /**
   *
   * @type {MandateSenderAccount}
   * @memberof PayoutSnapshotResponse
   */
  recipient_account?: MandateSenderAccount;
  /**
   *
   * @type {Array<Fee>}
   * @memberof PayoutSnapshotResponse
   */
  fees?: Array<Fee>;
  /**
   * Whether this payout is live or not
   * @type {boolean}
   * @memberof PayoutSnapshotResponse
   */
  live: boolean;
  /**
   *
   * @type {FvErrorModelV2}
   * @memberof PayoutSnapshotResponse
   */
  error?: FvErrorModelV2;
}
/**
 *
 * @export
 * @interface Principal
 */
export interface Principal {
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  subject: string;
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  token?: string;
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  client_id: string;
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  customer_app_id: string;
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  login_identity_id: string;
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  customization_id?: string;
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  mandate_id?: string;
  /**
   *
   * @type {number}
   * @memberof Principal
   */
  expires_in?: number;
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  payment_attempt_id?: string;
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  product_flow?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Principal
   */
  scopes?: Array<string>;
  /**
   *
   * @type {LinkTokenRequest}
   * @memberof Principal
   */
  link_token_request?: LinkTokenRequest;
  /**
   *
   * @type {GetMandateAuthLinkRequest}
   * @memberof Principal
   */
  get_mandate_auth_link_request?: GetMandateAuthLinkRequest;
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  currency?: string;
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  redirect_uri?: string;
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  payment_link_id?: string;
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  unique_reference_id?: string;
  /**
   *
   * @type {string}
   * @memberof Principal
   */
  payment_method_id?: string;
  /**
   * The qrCode text to be used to generate the image
   * @type {string}
   * @memberof Principal
   */
  qr_code_text?: string;
}
/**
 *
 * @export
 * @interface ProductStatus
 */
export interface ProductStatus {
  /**
   * The current health of this product
   * @type {string}
   * @memberof ProductStatus
   */
  status?: string;
  /**
   * The detailed event name
   * @type {string}
   * @memberof ProductStatus
   */
  status_details?: string;
  /**
   *
   * @type {string}
   * @memberof ProductStatus
   */
  last_update?: string | null;
  /**
   *
   * @type {string}
   * @memberof ProductStatus
   */
  last_successful_update?: string | null;
}
/**
 *
 * @export
 * @interface RecipientAccountNumber
 */
export interface RecipientAccountNumber {
  /**
   * Type of account number. Possible values: LOCAL, IBAN
   * @type {string}
   * @memberof RecipientAccountNumber
   */
  type: RecipientAccountNumberTypeEnum;
  /**
   * Account number value
   * @type {string}
   * @memberof RecipientAccountNumber
   */
  number: string;
}

export const RecipientAccountNumberTypeEnum = {
  Local: 'LOCAL',
  Iban: 'IBAN',
} as const;

export type RecipientAccountNumberTypeEnum =
  (typeof RecipientAccountNumberTypeEnum)[keyof typeof RecipientAccountNumberTypeEnum];

/**
 *
 * @export
 * @interface RecipientAccountResponse
 */
export interface RecipientAccountResponse {
  /**
   * A unique identifier generated after creating recipient
   * @type {string}
   * @memberof RecipientAccountResponse
   */
  recipient_account_id?: string;
  /**
   * Accountholder name of the recipient\'s account
   * @type {string}
   * @memberof RecipientAccountResponse
   */
  accountholder_name?: string;
  /**
   *
   * @type {RecipientAccountNumber}
   * @memberof RecipientAccountResponse
   */
  account_number?: RecipientAccountNumber;
  /**
   * Type of recipient account.
   * @type {string}
   * @memberof RecipientAccountResponse
   */
  account_type?: RecipientAccountResponseAccountTypeEnum;
  /**
   * List of currencies supported by the recipient account
   * @type {Array<string>}
   * @memberof RecipientAccountResponse
   */
  currencies?: Array<string>;
  /**
   * Finverse Institution ID for the recipient’s institution.
   * @type {string}
   * @memberof RecipientAccountResponse
   */
  institution_id?: string;
  /**
   * 3-digit code associated with bank
   * @type {string}
   * @memberof RecipientAccountResponse
   */
  bank_code?: string;
  /**
   * 3-digit code used to identify specific bank branch
   * @type {string}
   * @memberof RecipientAccountResponse
   */
  branch_code?: string;
}

export const RecipientAccountResponseAccountTypeEnum = {
  ExternalAccount: 'EXTERNAL_ACCOUNT',
  SettlementAccount: 'SETTLEMENT_ACCOUNT',
} as const;

export type RecipientAccountResponseAccountTypeEnum =
  (typeof RecipientAccountResponseAccountTypeEnum)[keyof typeof RecipientAccountResponseAccountTypeEnum];

/**
 *
 * @export
 * @interface RedirectUriResponse
 */
export interface RedirectUriResponse {
  /**
   *
   * @type {string}
   * @memberof RedirectUriResponse
   */
  redirect_uri?: string;
}
/**
 *
 * @export
 * @interface RefreshData
 */
export interface RefreshData {
  /**
   *
   * @type {boolean}
   * @memberof RefreshData
   */
  credentials_stored: boolean;
  /**
   *
   * @type {boolean}
   * @memberof RefreshData
   */
  refresh_allowed: boolean;
}
/**
 *
 * @export
 * @interface RefreshRequest
 */
export interface RefreshRequest {
  /**
   *
   * @type {string}
   * @memberof RefreshRequest
   */
  refresh_token: string;
}
/**
 *
 * @export
 * @interface RelinkRequest
 */
export interface RelinkRequest {
  /**
   *
   * @type {boolean}
   * @memberof RelinkRequest
   */
  store_credential: boolean;
  /**
   * this is a mandatory field
   * @type {boolean}
   * @memberof RelinkRequest
   */
  consent?: boolean | null;
}
/**
 *
 * @export
 * @interface SenderAccountFvLinkResponse
 */
export interface SenderAccountFvLinkResponse {
  /**
   *
   * @type {string}
   * @memberof SenderAccountFvLinkResponse
   */
  account_number_masked?: string;
  /**
   *
   * @type {string}
   * @memberof SenderAccountFvLinkResponse
   */
  institution_id?: string;
}
/**
 *
 * @export
 * @interface SenderDetail
 */
export interface SenderDetail {
  /**
   * The type of the details. For e.g. HK_ID, PASSPORT etc
   * @type {string}
   * @memberof SenderDetail
   */
  details_type?: SenderDetailDetailsTypeEnum;
  /**
   * The possible values of the detail. For e.g. A123456 for HK_ID
   * @type {Array<string>}
   * @memberof SenderDetail
   */
  values?: Array<string>;
}

export const SenderDetailDetailsTypeEnum = {
  HkId: 'HK_ID',
  Passport: 'PASSPORT',
  HkBusinessRegistration: 'HK_BUSINESS_REGISTRATION',
  HkCertificateOfIncorporation: 'HK_CERTIFICATE_OF_INCORPORATION',
} as const;

export type SenderDetailDetailsTypeEnum =
  (typeof SenderDetailDetailsTypeEnum)[keyof typeof SenderDetailDetailsTypeEnum];

/**
 *
 * @export
 * @interface SetAutopayConsentRequest
 */
export interface SetAutopayConsentRequest {
  /**
   *
   * @type {boolean}
   * @memberof SetAutopayConsentRequest
   */
  autopay_consent: boolean;
}
/**
 *
 * @export
 * @interface SetMandateInstitutionRequest
 */
export interface SetMandateInstitutionRequest {
  /**
   * Finverse Institution ID
   * @type {string}
   * @memberof SetMandateInstitutionRequest
   */
  institution_id: string;
}
/**
 *
 * @export
 * @interface SetMandateInstitutionResponse
 */
export interface SetMandateInstitutionResponse {
  /**
   * Finverse Mandate ID
   * @type {string}
   * @memberof SetMandateInstitutionResponse
   */
  mandate_id: string;
}
/**
 *
 * @export
 * @interface SingleSourceIncome
 */
export interface SingleSourceIncome {
  /**
   *
   * @type {Array<IncomeStream>}
   * @memberof SingleSourceIncome
   */
  income_streams: Array<IncomeStream>;
  /**
   *
   * @type {IncomeTotal}
   * @memberof SingleSourceIncome
   */
  income_total: IncomeTotal;
  /**
   * Where the income estimate was sourced from
   * @type {string}
   * @memberof SingleSourceIncome
   */
  source: string;
  /**
   * Unknown
   * @type {string}
   * @memberof SingleSourceIncome
   */
  source_id: string;
}
/**
 *
 * @export
 * @interface Statement
 */
export interface Statement {
  /**
   *
   * @type {string}
   * @memberof Statement
   */
  id?: string;
  /**
   * YYYY-MM-DD
   * @type {string}
   * @memberof Statement
   */
  date?: string;
  /**
   *
   * @type {string}
   * @memberof Statement
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof Statement
   */
  created_at?: string;
}
/**
 *
 * @export
 * @interface StatementLink
 */
export interface StatementLink {
  /**
   * signedURL to download statement
   * @type {string}
   * @memberof StatementLink
   */
  url?: string;
  /**
   * expiry of the signedURL
   * @type {string}
   * @memberof StatementLink
   */
  expiry?: string;
  /**
   *
   * @type {string}
   * @memberof StatementLink
   */
  statement_id?: string;
}
/**
 *
 * @export
 * @interface SubmitAuthChecklistRequest
 */
export interface SubmitAuthChecklistRequest {
  /**
   * The key_id that was used to encrypt the envelope key
   * @type {string}
   * @memberof SubmitAuthChecklistRequest
   */
  key_id: string;
  /**
   * The encrypted envelope key
   * @type {string}
   * @memberof SubmitAuthChecklistRequest
   */
  envelope_encryption_key: string;
  /**
   * The initialization vector used for enncrypting the payload
   * @type {string}
   * @memberof SubmitAuthChecklistRequest
   */
  initialization_vector: string;
  /**
   * The authentication code is used to authenticate the origin of the message
   * @type {string}
   * @memberof SubmitAuthChecklistRequest
   */
  message_authentication_code: string;
  /**
   * The encrypted payload that contains auth checklist items
   * @type {string}
   * @memberof SubmitAuthChecklistRequest
   */
  ciphertext: string;
}
/**
 *
 * @export
 * @interface SubmitAuthChecklistResponse
 */
export interface SubmitAuthChecklistResponse {
  /**
   * Finverse Mandate ID
   * @type {string}
   * @memberof SubmitAuthChecklistResponse
   */
  mandate_id: string;
  /**
   * Checklist of the authorization factors needed to complete Mandate authorization
   * @type {Array<AuthChecklistFactor>}
   * @memberof SubmitAuthChecklistResponse
   */
  auth_checklist: Array<AuthChecklistFactor>;
  /**
   * Mandate status
   * @type {string}
   * @memberof SubmitAuthChecklistResponse
   */
  mandate_status: SubmitAuthChecklistResponseMandateStatusEnum;
  /**
   * Timestamp in ISO format (YYYY-MM-DDTHH:MM:SS.SSSZ)
   * @type {string}
   * @memberof SubmitAuthChecklistResponse
   */
  last_update: string;
}

export const SubmitAuthChecklistResponseMandateStatusEnum = {
  Created: 'CREATED',
  Processing: 'PROCESSING',
  Submitted: 'SUBMITTED',
  Error: 'ERROR',
} as const;

export type SubmitAuthChecklistResponseMandateStatusEnum =
  (typeof SubmitAuthChecklistResponseMandateStatusEnum)[keyof typeof SubmitAuthChecklistResponseMandateStatusEnum];

/**
 *
 * @export
 * @interface SwaggerErrBodyModel
 */
export interface SwaggerErrBodyModel {
  /**
   *
   * @type {number}
   * @memberof SwaggerErrBodyModel
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof SwaggerErrBodyModel
   */
  message?: string;
  /**
   *
   * @type {FvErrorModel}
   * @memberof SwaggerErrBodyModel
   */
  error?: FvErrorModel;
}
/**
 *
 * @export
 * @interface TokenRequest
 */
export interface TokenRequest {
  /**
   *
   * @type {string}
   * @memberof TokenRequest
   */
  client_id: string;
  /**
   *
   * @type {string}
   * @memberof TokenRequest
   */
  client_secret: string;
  /**
   * support only client_credentials
   * @type {string}
   * @memberof TokenRequest
   */
  grant_type: string;
}
/**
 *
 * @export
 * @interface TokenResponse
 */
export interface TokenResponse {
  /**
   *
   * @type {string}
   * @memberof TokenResponse
   */
  access_token: string;
  /**
   *
   * @type {string}
   * @memberof TokenResponse
   */
  token_type: string;
  /**
   * seconds
   * @type {number}
   * @memberof TokenResponse
   */
  expires_in: number;
  /**
   *
   * @type {string}
   * @memberof TokenResponse
   */
  issued_at: string;
}
/**
 *
 * @export
 * @interface Transaction
 */
export interface Transaction {
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  transaction_id?: string;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  account_id?: string;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  transaction_state?: string;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  transaction_type?: string;
  /**
   * (Deprecated)
   * @type {string}
   * @memberof Transaction
   */
  category?: string;
  /**
   * (Deprecated)
   * @type {string}
   * @memberof Transaction
   */
  category_id?: string;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  merchant_name?: string;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  location?: string;
  /**
   *
   * @type {boolean}
   * @memberof Transaction
   */
  is_pending: boolean;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  status?: string;
  /**
   * YYYY-MM-DD
   * @type {string}
   * @memberof Transaction
   */
  posted_date?: string;
  /**
   *
   * @type {CurrencyAmount}
   * @memberof Transaction
   */
  amount?: CurrencyAmount;
  /**
   * (Deprecated)
   * @type {object}
   * @memberof Transaction
   */
  transfer_details?: object;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof Transaction
   */
  updated_at?: string;
  /**
   * Array of category labels
   * @type {Array<string>}
   * @memberof Transaction
   */
  categories?: Array<string>;
  /**
   *
   * @type {Array<CategoryPredictions>}
   * @memberof Transaction
   */
  category_predictions?: Array<CategoryPredictions>;
}
/**
 *
 * @export
 * @interface TransactionLimits
 */
export interface TransactionLimits {
  /**
   * Maximum amount of money that can be paid during the reference period (across any number of transactions). Expressed in currency\'s smallest unit or “minor unit”, as defined in ISO 4217.
   * @type {number}
   * @memberof TransactionLimits
   */
  max_period_amount?: number;
  /**
   * Maximum number of transactions (of any amount) that can be executed during the reference period.
   * @type {number}
   * @memberof TransactionLimits
   */
  max_period_count?: number;
  /**
   * The maximum amount of money that can be transferred in a single transaction under this mandate. Expressed in currency\'s smallest unit or “minor unit”, as defined in ISO 4217.
   * @type {number}
   * @memberof TransactionLimits
   */
  max_transaction_amount: number;
  /**
   * Reference calendar periods for the payment limits. Possible values (DAILY, WEEKLY, MONTHLY, QUARTERLY, YEARLY)
   * @type {string}
   * @memberof TransactionLimits
   */
  period?: TransactionLimitsPeriodEnum;
}

export const TransactionLimitsPeriodEnum = {
  Daily: 'DAILY',
  Weekly: 'WEEKLY',
  Monthly: 'MONTHLY',
  Quarterly: 'QUARTERLY',
  Yearly: 'YEARLY',
} as const;

export type TransactionLimitsPeriodEnum =
  (typeof TransactionLimitsPeriodEnum)[keyof typeof TransactionLimitsPeriodEnum];

/**
 *
 * @export
 * @interface UserButton
 */
export interface UserButton {
  /**
   * The name of the button.
   * @type {string}
   * @memberof UserButton
   */
  name: string;
  /**
   * The text that will be displayed for this button
   * @type {string}
   * @memberof UserButton
   */
  value: string;
  /**
   * The type of button. Currently it can only be SUBMIT
   * @type {string}
   * @memberof UserButton
   */
  type: string;
}
/**
 *
 * @export
 * @interface UserField
 */
export interface UserField {
  /**
   * The name of the field. This will be used as the key when submitting response.
   * @type {string}
   * @memberof UserField
   */
  name: string;
  /**
   * The label for this field.
   * @type {string}
   * @memberof UserField
   */
  label?: string;
  /**
   * The placeholder for this field.
   * @type {string}
   * @memberof UserField
   */
  placeholder?: string;
  /**
   * The type of field. Currently it can only be SELECT, INPUT or PASSWORD
   * @type {string}
   * @memberof UserField
   */
  type: string;
  /**
   * This is only applicable when the field type is SELECT
   * @type {Array<UserFieldOption>}
   * @memberof UserField
   */
  options?: Array<UserFieldOption>;
}
/**
 *
 * @export
 * @interface UserFieldOption
 */
export interface UserFieldOption {
  /**
   * The value displayed in the select element.
   * @type {string}
   * @memberof UserFieldOption
   */
  label: string;
  /**
   * The value that will be submitted if this option was selected.
   * @type {string}
   * @memberof UserFieldOption
   */
  value: string;
}
/**
 *
 * @export
 * @interface UserMessage
 */
export interface UserMessage {
  /**
   * The name of the message
   * @type {string}
   * @memberof UserMessage
   */
  name: string;
  /**
   * The type of the message. This will help how the UI renders this text.
   * @type {string}
   * @memberof UserMessage
   */
  type: string;
  /**
   * The actual text value.
   * @type {string}
   * @memberof UserMessage
   */
  value: string;
}

/**
 * CustomerApi - axios parameter creator
 * @export
 */
export const CustomerApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Allows a customer to authorize a specific mandate
     * @param {string} mandateId The mandate_id that is being authorized
     * @param {AuthorizeMandateRequest} authorizeMandateRequest request body for authorizing a mandate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authorizeMandate: async (
      mandateId: string,
      authorizeMandateRequest: AuthorizeMandateRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'mandateId' is not null or undefined
      assertParamExists('authorizeMandate', 'mandateId', mandateId);
      // verify required parameter 'authorizeMandateRequest' is not null or undefined
      assertParamExists('authorizeMandate', 'authorizeMandateRequest', authorizeMandateRequest);
      const localVarPath = `/mandates/{mandateId}/authorize`.replace(
        `{${'mandateId'}}`,
        encodeURIComponent(String(mandateId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        authorizeMandateRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * CREATE Mandate
     * @param {CreateMandateRequest} createMandateRequest request body for creating mandate
     * @param {string} [idempotencyKey] A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMandate: async (
      createMandateRequest: CreateMandateRequest,
      idempotencyKey?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createMandateRequest' is not null or undefined
      assertParamExists('createMandate', 'createMandateRequest', createMandateRequest);
      const localVarPath = `/mandates`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      if (idempotencyKey !== undefined && idempotencyKey !== null) {
        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(createMandateRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create new Payment
     * @param {CreatePaymentRequest} createPaymentRequest request body for creating payment
     * @param {string} [idempotencyKey] A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPayment: async (
      createPaymentRequest: CreatePaymentRequest,
      idempotencyKey?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createPaymentRequest' is not null or undefined
      assertParamExists('createPayment', 'createPaymentRequest', createPaymentRequest);
      const localVarPath = `/payments`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      if (idempotencyKey !== undefined && idempotencyKey !== null) {
        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(createPaymentRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * create payment account
     * @param {CreatePaymentAccountRequest} createPaymentAccountRequest request body for creating payment account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentAccount: async (
      createPaymentAccountRequest: CreatePaymentAccountRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createPaymentAccountRequest' is not null or undefined
      assertParamExists('createPaymentAccount', 'createPaymentAccountRequest', createPaymentAccountRequest);
      const localVarPath = `/payment_accounts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createPaymentAccountRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a new payment instruction to be used when linking to perform new payment
     * @param {CustomerPaymentInstruction} paymentInstruction Request body for starting a new Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentInstruction: async (
      paymentInstruction: CustomerPaymentInstruction,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'paymentInstruction' is not null or undefined
      assertParamExists('createPaymentInstruction', 'paymentInstruction', paymentInstruction);
      const localVarPath = `/payments/instruction`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(paymentInstruction, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a payment user
     * @param {CreatePaymentUserRequest} createPaymentUserRequest request body for creating payment user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentUser: async (
      createPaymentUserRequest: CreatePaymentUserRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createPaymentUserRequest' is not null or undefined
      assertParamExists('createPaymentUser', 'createPaymentUserRequest', createPaymentUserRequest);
      const localVarPath = `/payment_users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createPaymentUserRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * delete payment account
     * @param {string} paymentAccountId The payment account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePaymentAccount: async (paymentAccountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'paymentAccountId' is not null or undefined
      assertParamExists('deletePaymentAccount', 'paymentAccountId', paymentAccountId);
      const localVarPath = `/payment_accounts/{paymentAccountId}`.replace(
        `{${'paymentAccountId'}}`,
        encodeURIComponent(String(paymentAccountId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * generate a link token that can be used to create link
     * @param {LinkTokenRequest} linkTokenRequest token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateLinkToken: async (
      linkTokenRequest: LinkTokenRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'linkTokenRequest' is not null or undefined
      assertParamExists('generateLinkToken', 'linkTokenRequest', linkTokenRequest);
      const localVarPath = `/link/token`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(linkTokenRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a specific institution by institutionId
     * @param {string} institutionId The institution id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInstitution: async (institutionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'institutionId' is not null or undefined
      assertParamExists('getInstitution', 'institutionId', institutionId);
      const localVarPath = `/institutions/{institutionId}`.replace(
        `{${'institutionId'}}`,
        encodeURIComponent(String(institutionId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', ['institution'], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get line items for display
     * @param {'MANDATE' | 'MANUAL'} paymentType The payment type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLineItemsForDisplay: async (
      paymentType: 'MANDATE' | 'MANUAL',
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'paymentType' is not null or undefined
      assertParamExists('getLineItemsForDisplay', 'paymentType', paymentType);
      const localVarPath = `/calculate/line_items/{paymentType}`.replace(
        `{${'paymentType'}}`,
        encodeURIComponent(String(paymentType)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a specific loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoginIdentityById: async (loginIdentityId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'loginIdentityId' is not null or undefined
      assertParamExists('getLoginIdentityById', 'loginIdentityId', loginIdentityId);
      const localVarPath = `/login_identity/{loginIdentityId}`.replace(
        `{${'loginIdentityId'}}`,
        encodeURIComponent(String(loginIdentityId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a history of events for a specific loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoginIdentityHistory: async (
      loginIdentityId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'loginIdentityId' is not null or undefined
      assertParamExists('getLoginIdentityHistory', 'loginIdentityId', loginIdentityId);
      const localVarPath = `/login_identity/{loginIdentityId}/history`.replace(
        `{${'loginIdentityId'}}`,
        encodeURIComponent(String(loginIdentityId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get Mandate details by mandate_id
     * @param {string} mandateId mandate id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMandate: async (mandateId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'mandateId' is not null or undefined
      assertParamExists('getMandate', 'mandateId', mandateId);
      const localVarPath = `/mandates/{mandateId}`.replace(`{${'mandateId'}}`, encodeURIComponent(String(mandateId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get Mandate Authorization by mandate id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMandateAuth: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/mandates/auth`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get link to launch FV Link UI in mandate authorization mode
     * @param {GetMandateAuthLinkRequest} getMandateAuthLinkRequest request body for mandate authorization link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMandateAuthLink: async (
      getMandateAuthLinkRequest: GetMandateAuthLinkRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getMandateAuthLinkRequest' is not null or undefined
      assertParamExists('getMandateAuthLink', 'getMandateAuthLinkRequest', getMandateAuthLinkRequest);
      const localVarPath = `/mandates/link`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getMandateAuthLinkRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get Payment details by payment_id
     * @param {string} paymentId payment id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPayment: async (paymentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'paymentId' is not null or undefined
      assertParamExists('getPayment', 'paymentId', paymentId);
      const localVarPath = `/payments/{paymentId}`.replace(`{${'paymentId'}}`, encodeURIComponent(String(paymentId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get payment instructions by payment_instruction_id
     * @param {string} paymentInstructionId The id of a payment instruction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentInstruction: async (
      paymentInstructionId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'paymentInstructionId' is not null or undefined
      assertParamExists('getPaymentInstruction', 'paymentInstructionId', paymentInstructionId);
      const localVarPath = `/payments/instruction/{paymentInstructionId}`.replace(
        `{${'paymentInstructionId'}}`,
        encodeURIComponent(String(paymentInstructionId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a payment user
     * @param {string} paymentUserId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentUser: async (paymentUserId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'paymentUserId' is not null or undefined
      assertParamExists('getPaymentUser', 'paymentUserId', paymentUserId);
      const localVarPath = `/payment_users/{paymentUserId}`.replace(
        `{${'paymentUserId'}}`,
        encodeURIComponent(String(paymentUserId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of institutions
     * @param {string} [country] (Deprecated) The country the institution belongs to
     * @param {Array<string>} [countries] The countries the institution belongs to
     * @param {string} [productsSupported] The products that this institution supports
     * @param {'BANK' | 'WALLET' | 'TEST'} [institutionType] The type of institution
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listInstitutions: async (
      country?: string,
      countries?: Array<string>,
      productsSupported?: string,
      institutionType?: 'BANK' | 'WALLET' | 'TEST',
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/institutions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', ['institution'], configuration);

      if (country !== undefined) {
        localVarQueryParameter['country'] = country;
      }

      if (countries) {
        localVarQueryParameter['countries'] = countries.join(COLLECTION_FORMATS.csv);
      }

      if (productsSupported !== undefined) {
        localVarQueryParameter['products_supported'] = productsSupported;
      }

      if (institutionType !== undefined) {
        localVarQueryParameter['institution_type'] = institutionType;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get payment account by user id
     * @param {string} paymentUserId The payment user id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPaymentAccounts: async (paymentUserId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'paymentUserId' is not null or undefined
      assertParamExists('listPaymentAccounts', 'paymentUserId', paymentUserId);
      const localVarPath = `/payment_users/{paymentUserId}/payment_accounts`.replace(
        `{${'paymentUserId'}}`,
        encodeURIComponent(String(paymentUserId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Refresh an access token
     * @param {RefreshRequest} refreshRequest The refresh token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshToken: async (refreshRequest: RefreshRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'refreshRequest' is not null or undefined
      assertParamExists('refreshToken', 'refreshRequest', refreshRequest);
      const localVarPath = `/auth/token/refresh`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(refreshRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update InstitutionID and SenderType for Mandate
     * @param {SetMandateInstitutionRequest} updateRequest request body for updating mandate institutionId and senderType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setMandateInstitution: async (
      updateRequest: SetMandateInstitutionRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'updateRequest' is not null or undefined
      assertParamExists('setMandateInstitution', 'updateRequest', updateRequest);
      const localVarPath = `/mandates/institution_selection`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(updateRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Submit authorization checklist items
     * @param {SubmitAuthChecklistRequest} submitAuthChecklistRequest request body for submitting auth checklist
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitAuthChecklist: async (
      submitAuthChecklistRequest: SubmitAuthChecklistRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'submitAuthChecklistRequest' is not null or undefined
      assertParamExists('submitAuthChecklist', 'submitAuthChecklistRequest', submitAuthChecklistRequest);
      const localVarPath = `/mandates/auth`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        submitAuthChecklistRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CustomerApi - functional programming interface
 * @export
 */
export const CustomerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = CustomerApiAxiosParamCreator(configuration);
  return {
    /**
     * Allows a customer to authorize a specific mandate
     * @param {string} mandateId The mandate_id that is being authorized
     * @param {AuthorizeMandateRequest} authorizeMandateRequest request body for authorizing a mandate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authorizeMandate(
      mandateId: string,
      authorizeMandateRequest: AuthorizeMandateRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMandateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.authorizeMandate(
        mandateId,
        authorizeMandateRequest,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * CREATE Mandate
     * @param {CreateMandateRequest} createMandateRequest request body for creating mandate
     * @param {string} [idempotencyKey] A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createMandate(
      createMandateRequest: CreateMandateRequest,
      idempotencyKey?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMandateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createMandate(
        createMandateRequest,
        idempotencyKey,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Create new Payment
     * @param {CreatePaymentRequest} createPaymentRequest request body for creating payment
     * @param {string} [idempotencyKey] A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPayment(
      createPaymentRequest: CreatePaymentRequest,
      idempotencyKey?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createPayment(
        createPaymentRequest,
        idempotencyKey,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * create payment account
     * @param {CreatePaymentAccountRequest} createPaymentAccountRequest request body for creating payment account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPaymentAccount(
      createPaymentAccountRequest: CreatePaymentAccountRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentAccountDetails>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createPaymentAccount(
        createPaymentAccountRequest,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Create a new payment instruction to be used when linking to perform new payment
     * @param {CustomerPaymentInstruction} paymentInstruction Request body for starting a new Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPaymentInstruction(
      paymentInstruction: CustomerPaymentInstruction,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePaymentInstructionResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createPaymentInstruction(paymentInstruction, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Create a payment user
     * @param {CreatePaymentUserRequest} createPaymentUserRequest request body for creating payment user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPaymentUser(
      createPaymentUserRequest: CreatePaymentUserRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentUser>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createPaymentUser(createPaymentUserRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * delete payment account
     * @param {string} paymentAccountId The payment account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletePaymentAccount(
      paymentAccountId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletePaymentAccount(paymentAccountId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * generate a link token that can be used to create link
     * @param {LinkTokenRequest} linkTokenRequest token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async generateLinkToken(
      linkTokenRequest: LinkTokenRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkTokenResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.generateLinkToken(linkTokenRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get a specific institution by institutionId
     * @param {string} institutionId The institution id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getInstitution(
      institutionId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Institution>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getInstitution(institutionId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get line items for display
     * @param {'MANDATE' | 'MANUAL'} paymentType The payment type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLineItemsForDisplay(
      paymentType: 'MANDATE' | 'MANUAL',
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLineItemsForDisplayResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLineItemsForDisplay(paymentType, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get a specific loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLoginIdentityById(
      loginIdentityId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLoginIdentityByIdResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLoginIdentityById(loginIdentityId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get a history of events for a specific loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLoginIdentityHistory(
      loginIdentityId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLoginIdentityHistoryResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLoginIdentityHistory(loginIdentityId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get Mandate details by mandate_id
     * @param {string} mandateId mandate id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMandate(
      mandateId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMandateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMandate(mandateId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get Mandate Authorization by mandate id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMandateAuth(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMandateAuthResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMandateAuth(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get link to launch FV Link UI in mandate authorization mode
     * @param {GetMandateAuthLinkRequest} getMandateAuthLinkRequest request body for mandate authorization link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMandateAuthLink(
      getMandateAuthLinkRequest: GetMandateAuthLinkRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMandateAuthLinkResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMandateAuthLink(getMandateAuthLinkRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get Payment details by payment_id
     * @param {string} paymentId payment id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPayment(
      paymentId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPayment(paymentId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get payment instructions by payment_instruction_id
     * @param {string} paymentInstructionId The id of a payment instruction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPaymentInstruction(
      paymentInstructionId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPaymentInstructionsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentInstruction(paymentInstructionId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get a payment user
     * @param {string} paymentUserId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPaymentUser(
      paymentUserId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentUser>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentUser(paymentUserId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get a list of institutions
     * @param {string} [country] (Deprecated) The country the institution belongs to
     * @param {Array<string>} [countries] The countries the institution belongs to
     * @param {string} [productsSupported] The products that this institution supports
     * @param {'BANK' | 'WALLET' | 'TEST'} [institutionType] The type of institution
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listInstitutions(
      country?: string,
      countries?: Array<string>,
      productsSupported?: string,
      institutionType?: 'BANK' | 'WALLET' | 'TEST',
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Institution>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listInstitutions(
        country,
        countries,
        productsSupported,
        institutionType,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get payment account by user id
     * @param {string} paymentUserId The payment user id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listPaymentAccounts(
      paymentUserId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPaymentAccountsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listPaymentAccounts(paymentUserId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Refresh an access token
     * @param {RefreshRequest} refreshRequest The refresh token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async refreshToken(
      refreshRequest: RefreshRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessTokenResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(refreshRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Update InstitutionID and SenderType for Mandate
     * @param {SetMandateInstitutionRequest} updateRequest request body for updating mandate institutionId and senderType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setMandateInstitution(
      updateRequest: SetMandateInstitutionRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetMandateInstitutionResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setMandateInstitution(updateRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Submit authorization checklist items
     * @param {SubmitAuthChecklistRequest} submitAuthChecklistRequest request body for submitting auth checklist
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async submitAuthChecklist(
      submitAuthChecklistRequest: SubmitAuthChecklistRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmitAuthChecklistResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.submitAuthChecklist(
        submitAuthChecklistRequest,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * CustomerApi - factory interface
 * @export
 */
export const CustomerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = CustomerApiFp(configuration);
  return {
    /**
     * Allows a customer to authorize a specific mandate
     * @param {string} mandateId The mandate_id that is being authorized
     * @param {AuthorizeMandateRequest} authorizeMandateRequest request body for authorizing a mandate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authorizeMandate(
      mandateId: string,
      authorizeMandateRequest: AuthorizeMandateRequest,
      options?: any,
    ): AxiosPromise<GetMandateResponse> {
      return localVarFp
        .authorizeMandate(mandateId, authorizeMandateRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * CREATE Mandate
     * @param {CreateMandateRequest} createMandateRequest request body for creating mandate
     * @param {string} [idempotencyKey] A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMandate(
      createMandateRequest: CreateMandateRequest,
      idempotencyKey?: string,
      options?: any,
    ): AxiosPromise<CreateMandateResponse> {
      return localVarFp
        .createMandate(createMandateRequest, idempotencyKey, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create new Payment
     * @param {CreatePaymentRequest} createPaymentRequest request body for creating payment
     * @param {string} [idempotencyKey] A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPayment(
      createPaymentRequest: CreatePaymentRequest,
      idempotencyKey?: string,
      options?: any,
    ): AxiosPromise<PaymentResponse> {
      return localVarFp
        .createPayment(createPaymentRequest, idempotencyKey, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * create payment account
     * @param {CreatePaymentAccountRequest} createPaymentAccountRequest request body for creating payment account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentAccount(
      createPaymentAccountRequest: CreatePaymentAccountRequest,
      options?: any,
    ): AxiosPromise<PaymentAccountDetails> {
      return localVarFp
        .createPaymentAccount(createPaymentAccountRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a new payment instruction to be used when linking to perform new payment
     * @param {CustomerPaymentInstruction} paymentInstruction Request body for starting a new Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentInstruction(
      paymentInstruction: CustomerPaymentInstruction,
      options?: any,
    ): AxiosPromise<CreatePaymentInstructionResponse> {
      return localVarFp
        .createPaymentInstruction(paymentInstruction, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a payment user
     * @param {CreatePaymentUserRequest} createPaymentUserRequest request body for creating payment user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentUser(createPaymentUserRequest: CreatePaymentUserRequest, options?: any): AxiosPromise<PaymentUser> {
      return localVarFp
        .createPaymentUser(createPaymentUserRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * delete payment account
     * @param {string} paymentAccountId The payment account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePaymentAccount(paymentAccountId: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletePaymentAccount(paymentAccountId, options).then((request) => request(axios, basePath));
    },
    /**
     * generate a link token that can be used to create link
     * @param {LinkTokenRequest} linkTokenRequest token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateLinkToken(linkTokenRequest: LinkTokenRequest, options?: any): AxiosPromise<LinkTokenResponse> {
      return localVarFp.generateLinkToken(linkTokenRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Get a specific institution by institutionId
     * @param {string} institutionId The institution id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInstitution(institutionId: string, options?: any): AxiosPromise<Institution> {
      return localVarFp.getInstitution(institutionId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get line items for display
     * @param {'MANDATE' | 'MANUAL'} paymentType The payment type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLineItemsForDisplay(
      paymentType: 'MANDATE' | 'MANUAL',
      options?: any,
    ): AxiosPromise<GetLineItemsForDisplayResponse> {
      return localVarFp.getLineItemsForDisplay(paymentType, options).then((request) => request(axios, basePath));
    },
    /**
     * Get a specific loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoginIdentityById(loginIdentityId: string, options?: any): AxiosPromise<GetLoginIdentityByIdResponse> {
      return localVarFp.getLoginIdentityById(loginIdentityId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get a history of events for a specific loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoginIdentityHistory(loginIdentityId: string, options?: any): AxiosPromise<GetLoginIdentityHistoryResponse> {
      return localVarFp.getLoginIdentityHistory(loginIdentityId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get Mandate details by mandate_id
     * @param {string} mandateId mandate id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMandate(mandateId: string, options?: any): AxiosPromise<GetMandateResponse> {
      return localVarFp.getMandate(mandateId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get Mandate Authorization by mandate id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMandateAuth(options?: any): AxiosPromise<GetMandateAuthResponse> {
      return localVarFp.getMandateAuth(options).then((request) => request(axios, basePath));
    },
    /**
     * Get link to launch FV Link UI in mandate authorization mode
     * @param {GetMandateAuthLinkRequest} getMandateAuthLinkRequest request body for mandate authorization link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMandateAuthLink(
      getMandateAuthLinkRequest: GetMandateAuthLinkRequest,
      options?: any,
    ): AxiosPromise<GetMandateAuthLinkResponse> {
      return localVarFp
        .getMandateAuthLink(getMandateAuthLinkRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get Payment details by payment_id
     * @param {string} paymentId payment id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPayment(paymentId: string, options?: any): AxiosPromise<PaymentResponse> {
      return localVarFp.getPayment(paymentId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get payment instructions by payment_instruction_id
     * @param {string} paymentInstructionId The id of a payment instruction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentInstruction(paymentInstructionId: string, options?: any): AxiosPromise<GetPaymentInstructionsResponse> {
      return localVarFp
        .getPaymentInstruction(paymentInstructionId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a payment user
     * @param {string} paymentUserId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentUser(paymentUserId: string, options?: any): AxiosPromise<PaymentUser> {
      return localVarFp.getPaymentUser(paymentUserId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get a list of institutions
     * @param {string} [country] (Deprecated) The country the institution belongs to
     * @param {Array<string>} [countries] The countries the institution belongs to
     * @param {string} [productsSupported] The products that this institution supports
     * @param {'BANK' | 'WALLET' | 'TEST'} [institutionType] The type of institution
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listInstitutions(
      country?: string,
      countries?: Array<string>,
      productsSupported?: string,
      institutionType?: 'BANK' | 'WALLET' | 'TEST',
      options?: any,
    ): AxiosPromise<Array<Institution>> {
      return localVarFp
        .listInstitutions(country, countries, productsSupported, institutionType, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get payment account by user id
     * @param {string} paymentUserId The payment user id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPaymentAccounts(paymentUserId: string, options?: any): AxiosPromise<ListPaymentAccountsResponse> {
      return localVarFp.listPaymentAccounts(paymentUserId, options).then((request) => request(axios, basePath));
    },
    /**
     * Refresh an access token
     * @param {RefreshRequest} refreshRequest The refresh token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshToken(refreshRequest: RefreshRequest, options?: any): AxiosPromise<AccessTokenResponse> {
      return localVarFp.refreshToken(refreshRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Update InstitutionID and SenderType for Mandate
     * @param {SetMandateInstitutionRequest} updateRequest request body for updating mandate institutionId and senderType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setMandateInstitution(
      updateRequest: SetMandateInstitutionRequest,
      options?: any,
    ): AxiosPromise<SetMandateInstitutionResponse> {
      return localVarFp.setMandateInstitution(updateRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Submit authorization checklist items
     * @param {SubmitAuthChecklistRequest} submitAuthChecklistRequest request body for submitting auth checklist
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitAuthChecklist(
      submitAuthChecklistRequest: SubmitAuthChecklistRequest,
      options?: any,
    ): AxiosPromise<SubmitAuthChecklistResponse> {
      return localVarFp
        .submitAuthChecklist(submitAuthChecklistRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * CustomerApi - interface
 * @export
 * @interface CustomerApi
 */
export interface CustomerApiInterface {
  /**
   * Allows a customer to authorize a specific mandate
   * @param {string} mandateId The mandate_id that is being authorized
   * @param {AuthorizeMandateRequest} authorizeMandateRequest request body for authorizing a mandate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  authorizeMandate(
    mandateId: string,
    authorizeMandateRequest: AuthorizeMandateRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<GetMandateResponse>;

  /**
   * CREATE Mandate
   * @param {CreateMandateRequest} createMandateRequest request body for creating mandate
   * @param {string} [idempotencyKey] A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  createMandate(
    createMandateRequest: CreateMandateRequest,
    idempotencyKey?: string,
    options?: AxiosRequestConfig,
  ): AxiosPromise<CreateMandateResponse>;

  /**
   * Create new Payment
   * @param {CreatePaymentRequest} createPaymentRequest request body for creating payment
   * @param {string} [idempotencyKey] A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  createPayment(
    createPaymentRequest: CreatePaymentRequest,
    idempotencyKey?: string,
    options?: AxiosRequestConfig,
  ): AxiosPromise<PaymentResponse>;

  /**
   * create payment account
   * @param {CreatePaymentAccountRequest} createPaymentAccountRequest request body for creating payment account
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  createPaymentAccount(
    createPaymentAccountRequest: CreatePaymentAccountRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<PaymentAccountDetails>;

  /**
   * Create a new payment instruction to be used when linking to perform new payment
   * @param {CustomerPaymentInstruction} paymentInstruction Request body for starting a new Link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  createPaymentInstruction(
    paymentInstruction: CustomerPaymentInstruction,
    options?: AxiosRequestConfig,
  ): AxiosPromise<CreatePaymentInstructionResponse>;

  /**
   * Create a payment user
   * @param {CreatePaymentUserRequest} createPaymentUserRequest request body for creating payment user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  createPaymentUser(
    createPaymentUserRequest: CreatePaymentUserRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<PaymentUser>;

  /**
   * delete payment account
   * @param {string} paymentAccountId The payment account id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  deletePaymentAccount(paymentAccountId: string, options?: AxiosRequestConfig): AxiosPromise<void>;

  /**
   * generate a link token that can be used to create link
   * @param {LinkTokenRequest} linkTokenRequest token request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  generateLinkToken(linkTokenRequest: LinkTokenRequest, options?: AxiosRequestConfig): AxiosPromise<LinkTokenResponse>;

  /**
   * Get a specific institution by institutionId
   * @param {string} institutionId The institution id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  getInstitution(institutionId: string, options?: AxiosRequestConfig): AxiosPromise<Institution>;

  /**
   * Get line items for display
   * @param {'MANDATE' | 'MANUAL'} paymentType The payment type
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  getLineItemsForDisplay(
    paymentType: 'MANDATE' | 'MANUAL',
    options?: AxiosRequestConfig,
  ): AxiosPromise<GetLineItemsForDisplayResponse>;

  /**
   * Get a specific loginIdentity
   * @param {string} loginIdentityId The login identity id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  getLoginIdentityById(
    loginIdentityId: string,
    options?: AxiosRequestConfig,
  ): AxiosPromise<GetLoginIdentityByIdResponse>;

  /**
   * Get a history of events for a specific loginIdentity
   * @param {string} loginIdentityId The login identity id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  getLoginIdentityHistory(
    loginIdentityId: string,
    options?: AxiosRequestConfig,
  ): AxiosPromise<GetLoginIdentityHistoryResponse>;

  /**
   * Get Mandate details by mandate_id
   * @param {string} mandateId mandate id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  getMandate(mandateId: string, options?: AxiosRequestConfig): AxiosPromise<GetMandateResponse>;

  /**
   * Get Mandate Authorization by mandate id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  getMandateAuth(options?: AxiosRequestConfig): AxiosPromise<GetMandateAuthResponse>;

  /**
   * Get link to launch FV Link UI in mandate authorization mode
   * @param {GetMandateAuthLinkRequest} getMandateAuthLinkRequest request body for mandate authorization link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  getMandateAuthLink(
    getMandateAuthLinkRequest: GetMandateAuthLinkRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<GetMandateAuthLinkResponse>;

  /**
   * Get Payment details by payment_id
   * @param {string} paymentId payment id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  getPayment(paymentId: string, options?: AxiosRequestConfig): AxiosPromise<PaymentResponse>;

  /**
   * Get payment instructions by payment_instruction_id
   * @param {string} paymentInstructionId The id of a payment instruction
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  getPaymentInstruction(
    paymentInstructionId: string,
    options?: AxiosRequestConfig,
  ): AxiosPromise<GetPaymentInstructionsResponse>;

  /**
   * Get a payment user
   * @param {string} paymentUserId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  getPaymentUser(paymentUserId: string, options?: AxiosRequestConfig): AxiosPromise<PaymentUser>;

  /**
   * Get a list of institutions
   * @param {string} [country] (Deprecated) The country the institution belongs to
   * @param {Array<string>} [countries] The countries the institution belongs to
   * @param {string} [productsSupported] The products that this institution supports
   * @param {'BANK' | 'WALLET' | 'TEST'} [institutionType] The type of institution
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  listInstitutions(
    country?: string,
    countries?: Array<string>,
    productsSupported?: string,
    institutionType?: 'BANK' | 'WALLET' | 'TEST',
    options?: AxiosRequestConfig,
  ): AxiosPromise<Array<Institution>>;

  /**
   * Get payment account by user id
   * @param {string} paymentUserId The payment user id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  listPaymentAccounts(paymentUserId: string, options?: AxiosRequestConfig): AxiosPromise<ListPaymentAccountsResponse>;

  /**
   * Refresh an access token
   * @param {RefreshRequest} refreshRequest The refresh token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  refreshToken(refreshRequest: RefreshRequest, options?: AxiosRequestConfig): AxiosPromise<AccessTokenResponse>;

  /**
   * Update InstitutionID and SenderType for Mandate
   * @param {SetMandateInstitutionRequest} updateRequest request body for updating mandate institutionId and senderType
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  setMandateInstitution(
    updateRequest: SetMandateInstitutionRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<SetMandateInstitutionResponse>;

  /**
   * Submit authorization checklist items
   * @param {SubmitAuthChecklistRequest} submitAuthChecklistRequest request body for submitting auth checklist
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApiInterface
   */
  submitAuthChecklist(
    submitAuthChecklistRequest: SubmitAuthChecklistRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<SubmitAuthChecklistResponse>;
}

/**
 * CustomerApi - object-oriented interface
 * @export
 * @class CustomerApi
 * @extends {BaseAPI}
 */
export class CustomerApi extends BaseAPI implements CustomerApiInterface {
  /**
   * Allows a customer to authorize a specific mandate
   * @param {string} mandateId The mandate_id that is being authorized
   * @param {AuthorizeMandateRequest} authorizeMandateRequest request body for authorizing a mandate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public authorizeMandate(
    mandateId: string,
    authorizeMandateRequest: AuthorizeMandateRequest,
    options?: AxiosRequestConfig,
  ) {
    return CustomerApiFp(this.configuration)
      .authorizeMandate(mandateId, authorizeMandateRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * CREATE Mandate
   * @param {CreateMandateRequest} createMandateRequest request body for creating mandate
   * @param {string} [idempotencyKey] A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public createMandate(
    createMandateRequest: CreateMandateRequest,
    idempotencyKey?: string,
    options?: AxiosRequestConfig,
  ) {
    return CustomerApiFp(this.configuration)
      .createMandate(createMandateRequest, idempotencyKey, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create new Payment
   * @param {CreatePaymentRequest} createPaymentRequest request body for creating payment
   * @param {string} [idempotencyKey] A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public createPayment(
    createPaymentRequest: CreatePaymentRequest,
    idempotencyKey?: string,
    options?: AxiosRequestConfig,
  ) {
    return CustomerApiFp(this.configuration)
      .createPayment(createPaymentRequest, idempotencyKey, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * create payment account
   * @param {CreatePaymentAccountRequest} createPaymentAccountRequest request body for creating payment account
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public createPaymentAccount(createPaymentAccountRequest: CreatePaymentAccountRequest, options?: AxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .createPaymentAccount(createPaymentAccountRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a new payment instruction to be used when linking to perform new payment
   * @param {CustomerPaymentInstruction} paymentInstruction Request body for starting a new Link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public createPaymentInstruction(paymentInstruction: CustomerPaymentInstruction, options?: AxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .createPaymentInstruction(paymentInstruction, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a payment user
   * @param {CreatePaymentUserRequest} createPaymentUserRequest request body for creating payment user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public createPaymentUser(createPaymentUserRequest: CreatePaymentUserRequest, options?: AxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .createPaymentUser(createPaymentUserRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * delete payment account
   * @param {string} paymentAccountId The payment account id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public deletePaymentAccount(paymentAccountId: string, options?: AxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .deletePaymentAccount(paymentAccountId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * generate a link token that can be used to create link
   * @param {LinkTokenRequest} linkTokenRequest token request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public generateLinkToken(linkTokenRequest: LinkTokenRequest, options?: AxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .generateLinkToken(linkTokenRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a specific institution by institutionId
   * @param {string} institutionId The institution id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public getInstitution(institutionId: string, options?: AxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .getInstitution(institutionId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get line items for display
   * @param {'MANDATE' | 'MANUAL'} paymentType The payment type
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public getLineItemsForDisplay(paymentType: 'MANDATE' | 'MANUAL', options?: AxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .getLineItemsForDisplay(paymentType, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a specific loginIdentity
   * @param {string} loginIdentityId The login identity id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public getLoginIdentityById(loginIdentityId: string, options?: AxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .getLoginIdentityById(loginIdentityId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a history of events for a specific loginIdentity
   * @param {string} loginIdentityId The login identity id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public getLoginIdentityHistory(loginIdentityId: string, options?: AxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .getLoginIdentityHistory(loginIdentityId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get Mandate details by mandate_id
   * @param {string} mandateId mandate id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public getMandate(mandateId: string, options?: AxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .getMandate(mandateId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get Mandate Authorization by mandate id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public getMandateAuth(options?: AxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .getMandateAuth(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get link to launch FV Link UI in mandate authorization mode
   * @param {GetMandateAuthLinkRequest} getMandateAuthLinkRequest request body for mandate authorization link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public getMandateAuthLink(getMandateAuthLinkRequest: GetMandateAuthLinkRequest, options?: AxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .getMandateAuthLink(getMandateAuthLinkRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get Payment details by payment_id
   * @param {string} paymentId payment id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public getPayment(paymentId: string, options?: AxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .getPayment(paymentId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get payment instructions by payment_instruction_id
   * @param {string} paymentInstructionId The id of a payment instruction
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public getPaymentInstruction(paymentInstructionId: string, options?: AxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .getPaymentInstruction(paymentInstructionId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a payment user
   * @param {string} paymentUserId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public getPaymentUser(paymentUserId: string, options?: AxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .getPaymentUser(paymentUserId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of institutions
   * @param {string} [country] (Deprecated) The country the institution belongs to
   * @param {Array<string>} [countries] The countries the institution belongs to
   * @param {string} [productsSupported] The products that this institution supports
   * @param {'BANK' | 'WALLET' | 'TEST'} [institutionType] The type of institution
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public listInstitutions(
    country?: string,
    countries?: Array<string>,
    productsSupported?: string,
    institutionType?: 'BANK' | 'WALLET' | 'TEST',
    options?: AxiosRequestConfig,
  ) {
    return CustomerApiFp(this.configuration)
      .listInstitutions(country, countries, productsSupported, institutionType, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get payment account by user id
   * @param {string} paymentUserId The payment user id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public listPaymentAccounts(paymentUserId: string, options?: AxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .listPaymentAccounts(paymentUserId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Refresh an access token
   * @param {RefreshRequest} refreshRequest The refresh token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public refreshToken(refreshRequest: RefreshRequest, options?: AxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .refreshToken(refreshRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update InstitutionID and SenderType for Mandate
   * @param {SetMandateInstitutionRequest} updateRequest request body for updating mandate institutionId and senderType
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public setMandateInstitution(updateRequest: SetMandateInstitutionRequest, options?: AxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .setMandateInstitution(updateRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Submit authorization checklist items
   * @param {SubmitAuthChecklistRequest} submitAuthChecklistRequest request body for submitting auth checklist
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomerApi
   */
  public submitAuthChecklist(submitAuthChecklistRequest: SubmitAuthChecklistRequest, options?: AxiosRequestConfig) {
    return CustomerApiFp(this.configuration)
      .submitAuthChecklist(submitAuthChecklistRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Cancel a payment link
     * @param {string} paymentLinkId The payment link id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelPaymentLink: async (paymentLinkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'paymentLinkId' is not null or undefined
      assertParamExists('cancelPaymentLink', 'paymentLinkId', paymentLinkId);
      const localVarPath = `/payment_links/{paymentLinkId}/cancel`.replace(
        `{${'paymentLinkId'}}`,
        encodeURIComponent(String(paymentLinkId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Cancel Payout by payout_id
     * @param {string} payoutId payout id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelPayout: async (payoutId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'payoutId' is not null or undefined
      assertParamExists('cancelPayout', 'payoutId', payoutId);
      const localVarPath = `/payouts/{payoutId}/cancel`.replace(
        `{${'payoutId'}}`,
        encodeURIComponent(String(payoutId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Submit manual payment confirmation
     * @param {ManualPaymentConfirmationRequest} manualPaymentIdentifiers Request body containing information to identify manual payment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmManualPayment: async (
      manualPaymentIdentifiers: ManualPaymentConfirmationRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'manualPaymentIdentifiers' is not null or undefined
      assertParamExists('confirmManualPayment', 'manualPaymentIdentifiers', manualPaymentIdentifiers);
      const localVarPath = `/payments/manual_payment`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        manualPaymentIdentifiers,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Confirm a payment against a payment Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmPayment: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/payment_links/confirm`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create token for fps flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFpsToken: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/payment_links/fps/token`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create mandate for an existing sender account
     * @param {string} idempotencyKey A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {CreateMandateWithSenderAccountRequest} createMandateRequest request body for creating mandate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMandateForExistingSender: async (
      idempotencyKey: string,
      createMandateRequest: CreateMandateWithSenderAccountRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'idempotencyKey' is not null or undefined
      assertParamExists('createMandateForExistingSender', 'idempotencyKey', idempotencyKey);
      // verify required parameter 'createMandateRequest' is not null or undefined
      assertParamExists('createMandateForExistingSender', 'createMandateRequest', createMandateRequest);
      const localVarPath = `/mandates/sender_account`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      if (idempotencyKey !== undefined && idempotencyKey !== null) {
        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(createMandateRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create payment link
     * @param {CreatePaymentLinkRequest} createPaymentLinkRequest Parameters required to create a payment link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentLink: async (
      createPaymentLinkRequest: CreatePaymentLinkRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createPaymentLinkRequest' is not null or undefined
      assertParamExists('createPaymentLink', 'createPaymentLinkRequest', createPaymentLinkRequest);
      const localVarPath = `/payment_links`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createPaymentLinkRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Initiate Card Payment for a Payment Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentLinkCardPayment: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/payment_links/card`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * CREATE Mandate for payment link
     * @param {CreatePaymentLinkMandateRequest} createPaymentLinkMandateRequest request body for creating mandate for payment-link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentLinkMandate: async (
      createPaymentLinkMandateRequest: CreatePaymentLinkMandateRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createPaymentLinkMandateRequest' is not null or undefined
      assertParamExists('createPaymentLinkMandate', 'createPaymentLinkMandateRequest', createPaymentLinkMandateRequest);
      const localVarPath = `/payment_links/mandates`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createPaymentLinkMandateRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a scheduled payout
     * @param {string} idempotencyKey A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {CreateScheduledPayoutRequest} createScheduledPayoutRequest Request body containing information to create scheduled payout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createScheduledPayout: async (
      idempotencyKey: string,
      createScheduledPayoutRequest: CreateScheduledPayoutRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'idempotencyKey' is not null or undefined
      assertParamExists('createScheduledPayout', 'idempotencyKey', idempotencyKey);
      // verify required parameter 'createScheduledPayoutRequest' is not null or undefined
      assertParamExists('createScheduledPayout', 'createScheduledPayoutRequest', createScheduledPayoutRequest);
      const localVarPath = `/payouts/scheduled`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      if (idempotencyKey !== undefined && idempotencyKey !== null) {
        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createScheduledPayoutRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the FPS QR code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFpsQrCode: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/payment_links/fps/qr_code`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a customer-specific list of institutions for Finverse Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInstitutionsForCustomer: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/institutions/customer`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get payment link
     * @param {string} paymentLinkId The payment link id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentLink: async (paymentLinkId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'paymentLinkId' is not null or undefined
      assertParamExists('getPaymentLink', 'paymentLinkId', paymentLinkId);
      const localVarPath = `/payment_links/{paymentLinkId}`.replace(
        `{${'paymentLinkId'}}`,
        encodeURIComponent(String(paymentLinkId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get payment method in payment link flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentMethodPaymentLink: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/payment_link/fvlink/payment_method`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get payout by payout_id
     * @param {string} payoutId payout id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPayoutById: async (payoutId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'payoutId' is not null or undefined
      assertParamExists('getPayoutById', 'payoutId', payoutId);
      const localVarPath = `/payouts/{payoutId}`.replace(`{${'payoutId'}}`, encodeURIComponent(String(payoutId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get sender payment user in payment link flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSenderPaymentUser: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/payment_link/fvlink/payment_user/sender`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List mandates
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<'AUTHORIZATION_REQUIRED' | 'AUTHORIZING' | 'PROCESSING' | 'SUBMITTED' | 'SUCCEEDED' | 'FAILED' | 'REVOKED'>} [statuses] The mandate statuses to filter for, comma separated
     * @param {'INDIVIDUAL' | 'BUSINESS'} [senderType] The sender type of the mandate
     * @param {string} [userId] The user_id the mandate was setup for
     * @param {string} [institutionId] The institution the mandate was executed against
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMandates: async (
      dateFrom?: string,
      dateTo?: string,
      statuses?: Array<
        'AUTHORIZATION_REQUIRED' | 'AUTHORIZING' | 'PROCESSING' | 'SUBMITTED' | 'SUCCEEDED' | 'FAILED' | 'REVOKED'
      >,
      senderType?: 'INDIVIDUAL' | 'BUSINESS',
      userId?: string,
      institutionId?: string,
      offset?: number,
      limit?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/mandates`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      if (dateFrom !== undefined) {
        localVarQueryParameter['date_from'] =
          (dateFrom as any) instanceof Date ? (dateFrom as any).toISOString().substr(0, 10) : dateFrom;
      }

      if (dateTo !== undefined) {
        localVarQueryParameter['date_to'] =
          (dateTo as any) instanceof Date ? (dateTo as any).toISOString().substr(0, 10) : dateTo;
      }

      if (statuses) {
        localVarQueryParameter['statuses'] = statuses.join(COLLECTION_FORMATS.csv);
      }

      if (senderType !== undefined) {
        localVarQueryParameter['sender_type'] = senderType;
      }

      if (userId !== undefined) {
        localVarQueryParameter['user_id'] = userId;
      }

      if (institutionId !== undefined) {
        localVarQueryParameter['institution_id'] = institutionId;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List Payments
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<'AUTHORIZATION_REQUIRED' | 'AUTHORIZING' | 'PROCESSING' | 'SUBMITTED' | 'EXECUTED' | 'FAILED' | 'REVOKED'>} [statuses] The payment statuses to filter for, comma separated
     * @param {'INDIVIDUAL' | 'BUSINESS'} [senderType] The sender type of the mandate
     * @param {string} [userId] The user_id the mandate was setup for
     * @param {string} [institutionId] The institution the mandate was executed against
     * @param {'MANDATE' | 'SINGLE'} [paymentType] The type of payment
     * @param {string} [mandateId] The mandate the payment belongs to
     * @param {string} [currency] The currency the payment is made in
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPayments: async (
      dateFrom?: string,
      dateTo?: string,
      statuses?: Array<
        'AUTHORIZATION_REQUIRED' | 'AUTHORIZING' | 'PROCESSING' | 'SUBMITTED' | 'EXECUTED' | 'FAILED' | 'REVOKED'
      >,
      senderType?: 'INDIVIDUAL' | 'BUSINESS',
      userId?: string,
      institutionId?: string,
      paymentType?: 'MANDATE' | 'SINGLE',
      mandateId?: string,
      currency?: string,
      offset?: number,
      limit?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/payments`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      if (dateFrom !== undefined) {
        localVarQueryParameter['date_from'] =
          (dateFrom as any) instanceof Date ? (dateFrom as any).toISOString().substr(0, 10) : dateFrom;
      }

      if (dateTo !== undefined) {
        localVarQueryParameter['date_to'] =
          (dateTo as any) instanceof Date ? (dateTo as any).toISOString().substr(0, 10) : dateTo;
      }

      if (statuses) {
        localVarQueryParameter['statuses'] = statuses.join(COLLECTION_FORMATS.csv);
      }

      if (senderType !== undefined) {
        localVarQueryParameter['sender_type'] = senderType;
      }

      if (userId !== undefined) {
        localVarQueryParameter['user_id'] = userId;
      }

      if (institutionId !== undefined) {
        localVarQueryParameter['institution_id'] = institutionId;
      }

      if (paymentType !== undefined) {
        localVarQueryParameter['payment_type'] = paymentType;
      }

      if (mandateId !== undefined) {
        localVarQueryParameter['mandate_id'] = mandateId;
      }

      if (currency !== undefined) {
        localVarQueryParameter['currency'] = currency;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Set autopay consent for payment user
     * @param {SetAutopayConsentRequest} setAutopayConsentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setAutopayConsent: async (
      setAutopayConsentRequest: SetAutopayConsentRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'setAutopayConsentRequest' is not null or undefined
      assertParamExists('setAutopayConsent', 'setAutopayConsentRequest', setAutopayConsentRequest);
      const localVarPath = `/payment_link/fvlink/payment_user/autopay`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        setAutopayConsentRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration);
  return {
    /**
     * Cancel a payment link
     * @param {string} paymentLinkId The payment link id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cancelPaymentLink(
      paymentLinkId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentLinkResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.cancelPaymentLink(paymentLinkId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Cancel Payout by payout_id
     * @param {string} payoutId payout id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cancelPayout(
      payoutId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayoutSnapshotResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.cancelPayout(payoutId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Submit manual payment confirmation
     * @param {ManualPaymentConfirmationRequest} manualPaymentIdentifiers Request body containing information to identify manual payment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async confirmManualPayment(
      manualPaymentIdentifiers: ManualPaymentConfirmationRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManualPaymentConfirmationResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.confirmManualPayment(manualPaymentIdentifiers, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Confirm a payment against a payment Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async confirmPayment(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfirmPaymentResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.confirmPayment(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Create token for fps flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createFpsToken(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateFpsTokenResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createFpsToken(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Create mandate for an existing sender account
     * @param {string} idempotencyKey A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {CreateMandateWithSenderAccountRequest} createMandateRequest request body for creating mandate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createMandateForExistingSender(
      idempotencyKey: string,
      createMandateRequest: CreateMandateWithSenderAccountRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMandateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createMandateForExistingSender(
        idempotencyKey,
        createMandateRequest,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Create payment link
     * @param {CreatePaymentLinkRequest} createPaymentLinkRequest Parameters required to create a payment link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPaymentLink(
      createPaymentLinkRequest: CreatePaymentLinkRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentLinkResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createPaymentLink(createPaymentLinkRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Initiate Card Payment for a Payment Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPaymentLinkCardPayment(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePaymentLinkCardPaymentResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createPaymentLinkCardPayment(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * CREATE Mandate for payment link
     * @param {CreatePaymentLinkMandateRequest} createPaymentLinkMandateRequest request body for creating mandate for payment-link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPaymentLinkMandate(
      createPaymentLinkMandateRequest: CreatePaymentLinkMandateRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePaymentLinkMandateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createPaymentLinkMandate(
        createPaymentLinkMandateRequest,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Create a scheduled payout
     * @param {string} idempotencyKey A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {CreateScheduledPayoutRequest} createScheduledPayoutRequest Request body containing information to create scheduled payout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createScheduledPayout(
      idempotencyKey: string,
      createScheduledPayoutRequest: CreateScheduledPayoutRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayoutSnapshotResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createScheduledPayout(
        idempotencyKey,
        createScheduledPayoutRequest,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get the FPS QR code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFpsQrCode(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FpsQrCodeResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFpsQrCode(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get a customer-specific list of institutions for Finverse Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getInstitutionsForCustomer(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Institution>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getInstitutionsForCustomer(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get payment link
     * @param {string} paymentLinkId The payment link id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPaymentLink(
      paymentLinkId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentLinkResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentLink(paymentLinkId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get payment method in payment link flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPaymentMethodPaymentLink(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentMethodFvLinkResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentMethodPaymentLink(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get payout by payout_id
     * @param {string} payoutId payout id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPayoutById(
      payoutId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayoutSnapshotResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPayoutById(payoutId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get sender payment user in payment link flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSenderPaymentUser(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPaymentUserResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSenderPaymentUser(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * List mandates
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<'AUTHORIZATION_REQUIRED' | 'AUTHORIZING' | 'PROCESSING' | 'SUBMITTED' | 'SUCCEEDED' | 'FAILED' | 'REVOKED'>} [statuses] The mandate statuses to filter for, comma separated
     * @param {'INDIVIDUAL' | 'BUSINESS'} [senderType] The sender type of the mandate
     * @param {string} [userId] The user_id the mandate was setup for
     * @param {string} [institutionId] The institution the mandate was executed against
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listMandates(
      dateFrom?: string,
      dateTo?: string,
      statuses?: Array<
        'AUTHORIZATION_REQUIRED' | 'AUTHORIZING' | 'PROCESSING' | 'SUBMITTED' | 'SUCCEEDED' | 'FAILED' | 'REVOKED'
      >,
      senderType?: 'INDIVIDUAL' | 'BUSINESS',
      userId?: string,
      institutionId?: string,
      offset?: number,
      limit?: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMandatesResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listMandates(
        dateFrom,
        dateTo,
        statuses,
        senderType,
        userId,
        institutionId,
        offset,
        limit,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * List Payments
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<'AUTHORIZATION_REQUIRED' | 'AUTHORIZING' | 'PROCESSING' | 'SUBMITTED' | 'EXECUTED' | 'FAILED' | 'REVOKED'>} [statuses] The payment statuses to filter for, comma separated
     * @param {'INDIVIDUAL' | 'BUSINESS'} [senderType] The sender type of the mandate
     * @param {string} [userId] The user_id the mandate was setup for
     * @param {string} [institutionId] The institution the mandate was executed against
     * @param {'MANDATE' | 'SINGLE'} [paymentType] The type of payment
     * @param {string} [mandateId] The mandate the payment belongs to
     * @param {string} [currency] The currency the payment is made in
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listPayments(
      dateFrom?: string,
      dateTo?: string,
      statuses?: Array<
        'AUTHORIZATION_REQUIRED' | 'AUTHORIZING' | 'PROCESSING' | 'SUBMITTED' | 'EXECUTED' | 'FAILED' | 'REVOKED'
      >,
      senderType?: 'INDIVIDUAL' | 'BUSINESS',
      userId?: string,
      institutionId?: string,
      paymentType?: 'MANDATE' | 'SINGLE',
      mandateId?: string,
      currency?: string,
      offset?: number,
      limit?: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPaymentsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listPayments(
        dateFrom,
        dateTo,
        statuses,
        senderType,
        userId,
        institutionId,
        paymentType,
        mandateId,
        currency,
        offset,
        limit,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Set autopay consent for payment user
     * @param {SetAutopayConsentRequest} setAutopayConsentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setAutopayConsent(
      setAutopayConsentRequest: SetAutopayConsentRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setAutopayConsent(setAutopayConsentRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = DefaultApiFp(configuration);
  return {
    /**
     * Cancel a payment link
     * @param {string} paymentLinkId The payment link id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelPaymentLink(paymentLinkId: string, options?: any): AxiosPromise<PaymentLinkResponse> {
      return localVarFp.cancelPaymentLink(paymentLinkId, options).then((request) => request(axios, basePath));
    },
    /**
     * Cancel Payout by payout_id
     * @param {string} payoutId payout id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelPayout(payoutId: string, options?: any): AxiosPromise<PayoutSnapshotResponse> {
      return localVarFp.cancelPayout(payoutId, options).then((request) => request(axios, basePath));
    },
    /**
     * Submit manual payment confirmation
     * @param {ManualPaymentConfirmationRequest} manualPaymentIdentifiers Request body containing information to identify manual payment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmManualPayment(
      manualPaymentIdentifiers: ManualPaymentConfirmationRequest,
      options?: any,
    ): AxiosPromise<ManualPaymentConfirmationResponse> {
      return localVarFp
        .confirmManualPayment(manualPaymentIdentifiers, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Confirm a payment against a payment Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmPayment(options?: any): AxiosPromise<ConfirmPaymentResponse> {
      return localVarFp.confirmPayment(options).then((request) => request(axios, basePath));
    },
    /**
     * Create token for fps flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFpsToken(options?: any): AxiosPromise<CreateFpsTokenResponse> {
      return localVarFp.createFpsToken(options).then((request) => request(axios, basePath));
    },
    /**
     * Create mandate for an existing sender account
     * @param {string} idempotencyKey A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {CreateMandateWithSenderAccountRequest} createMandateRequest request body for creating mandate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMandateForExistingSender(
      idempotencyKey: string,
      createMandateRequest: CreateMandateWithSenderAccountRequest,
      options?: any,
    ): AxiosPromise<CreateMandateResponse> {
      return localVarFp
        .createMandateForExistingSender(idempotencyKey, createMandateRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create payment link
     * @param {CreatePaymentLinkRequest} createPaymentLinkRequest Parameters required to create a payment link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentLink(
      createPaymentLinkRequest: CreatePaymentLinkRequest,
      options?: any,
    ): AxiosPromise<PaymentLinkResponse> {
      return localVarFp
        .createPaymentLink(createPaymentLinkRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Initiate Card Payment for a Payment Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentLinkCardPayment(options?: any): AxiosPromise<CreatePaymentLinkCardPaymentResponse> {
      return localVarFp.createPaymentLinkCardPayment(options).then((request) => request(axios, basePath));
    },
    /**
     * CREATE Mandate for payment link
     * @param {CreatePaymentLinkMandateRequest} createPaymentLinkMandateRequest request body for creating mandate for payment-link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPaymentLinkMandate(
      createPaymentLinkMandateRequest: CreatePaymentLinkMandateRequest,
      options?: any,
    ): AxiosPromise<CreatePaymentLinkMandateResponse> {
      return localVarFp
        .createPaymentLinkMandate(createPaymentLinkMandateRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a scheduled payout
     * @param {string} idempotencyKey A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
     * @param {CreateScheduledPayoutRequest} createScheduledPayoutRequest Request body containing information to create scheduled payout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createScheduledPayout(
      idempotencyKey: string,
      createScheduledPayoutRequest: CreateScheduledPayoutRequest,
      options?: any,
    ): AxiosPromise<PayoutSnapshotResponse> {
      return localVarFp
        .createScheduledPayout(idempotencyKey, createScheduledPayoutRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get the FPS QR code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFpsQrCode(options?: any): AxiosPromise<FpsQrCodeResponse> {
      return localVarFp.getFpsQrCode(options).then((request) => request(axios, basePath));
    },
    /**
     * Get a customer-specific list of institutions for Finverse Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInstitutionsForCustomer(options?: any): AxiosPromise<Array<Institution>> {
      return localVarFp.getInstitutionsForCustomer(options).then((request) => request(axios, basePath));
    },
    /**
     * Get payment link
     * @param {string} paymentLinkId The payment link id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentLink(paymentLinkId: string, options?: any): AxiosPromise<PaymentLinkResponse> {
      return localVarFp.getPaymentLink(paymentLinkId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get payment method in payment link flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentMethodPaymentLink(options?: any): AxiosPromise<PaymentMethodFvLinkResponse> {
      return localVarFp.getPaymentMethodPaymentLink(options).then((request) => request(axios, basePath));
    },
    /**
     * Get payout by payout_id
     * @param {string} payoutId payout id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPayoutById(payoutId: string, options?: any): AxiosPromise<PayoutSnapshotResponse> {
      return localVarFp.getPayoutById(payoutId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get sender payment user in payment link flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSenderPaymentUser(options?: any): AxiosPromise<GetPaymentUserResponse> {
      return localVarFp.getSenderPaymentUser(options).then((request) => request(axios, basePath));
    },
    /**
     * List mandates
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<'AUTHORIZATION_REQUIRED' | 'AUTHORIZING' | 'PROCESSING' | 'SUBMITTED' | 'SUCCEEDED' | 'FAILED' | 'REVOKED'>} [statuses] The mandate statuses to filter for, comma separated
     * @param {'INDIVIDUAL' | 'BUSINESS'} [senderType] The sender type of the mandate
     * @param {string} [userId] The user_id the mandate was setup for
     * @param {string} [institutionId] The institution the mandate was executed against
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMandates(
      dateFrom?: string,
      dateTo?: string,
      statuses?: Array<
        'AUTHORIZATION_REQUIRED' | 'AUTHORIZING' | 'PROCESSING' | 'SUBMITTED' | 'SUCCEEDED' | 'FAILED' | 'REVOKED'
      >,
      senderType?: 'INDIVIDUAL' | 'BUSINESS',
      userId?: string,
      institutionId?: string,
      offset?: number,
      limit?: number,
      options?: any,
    ): AxiosPromise<ListMandatesResponse> {
      return localVarFp
        .listMandates(dateFrom, dateTo, statuses, senderType, userId, institutionId, offset, limit, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * List Payments
     * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
     * @param {string} [dateTo] ISO format (YYYY-MM-DD)
     * @param {Array<'AUTHORIZATION_REQUIRED' | 'AUTHORIZING' | 'PROCESSING' | 'SUBMITTED' | 'EXECUTED' | 'FAILED' | 'REVOKED'>} [statuses] The payment statuses to filter for, comma separated
     * @param {'INDIVIDUAL' | 'BUSINESS'} [senderType] The sender type of the mandate
     * @param {string} [userId] The user_id the mandate was setup for
     * @param {string} [institutionId] The institution the mandate was executed against
     * @param {'MANDATE' | 'SINGLE'} [paymentType] The type of payment
     * @param {string} [mandateId] The mandate the payment belongs to
     * @param {string} [currency] The currency the payment is made in
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPayments(
      dateFrom?: string,
      dateTo?: string,
      statuses?: Array<
        'AUTHORIZATION_REQUIRED' | 'AUTHORIZING' | 'PROCESSING' | 'SUBMITTED' | 'EXECUTED' | 'FAILED' | 'REVOKED'
      >,
      senderType?: 'INDIVIDUAL' | 'BUSINESS',
      userId?: string,
      institutionId?: string,
      paymentType?: 'MANDATE' | 'SINGLE',
      mandateId?: string,
      currency?: string,
      offset?: number,
      limit?: number,
      options?: any,
    ): AxiosPromise<ListPaymentsResponse> {
      return localVarFp
        .listPayments(
          dateFrom,
          dateTo,
          statuses,
          senderType,
          userId,
          institutionId,
          paymentType,
          mandateId,
          currency,
          offset,
          limit,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Set autopay consent for payment user
     * @param {SetAutopayConsentRequest} setAutopayConsentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setAutopayConsent(setAutopayConsentRequest: SetAutopayConsentRequest, options?: any): AxiosPromise<void> {
      return localVarFp
        .setAutopayConsent(setAutopayConsentRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * DefaultApi - interface
 * @export
 * @interface DefaultApi
 */
export interface DefaultApiInterface {
  /**
   * Cancel a payment link
   * @param {string} paymentLinkId The payment link id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  cancelPaymentLink(paymentLinkId: string, options?: AxiosRequestConfig): AxiosPromise<PaymentLinkResponse>;

  /**
   * Cancel Payout by payout_id
   * @param {string} payoutId payout id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  cancelPayout(payoutId: string, options?: AxiosRequestConfig): AxiosPromise<PayoutSnapshotResponse>;

  /**
   * Submit manual payment confirmation
   * @param {ManualPaymentConfirmationRequest} manualPaymentIdentifiers Request body containing information to identify manual payment
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  confirmManualPayment(
    manualPaymentIdentifiers: ManualPaymentConfirmationRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<ManualPaymentConfirmationResponse>;

  /**
   * Confirm a payment against a payment Link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  confirmPayment(options?: AxiosRequestConfig): AxiosPromise<ConfirmPaymentResponse>;

  /**
   * Create token for fps flow
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  createFpsToken(options?: AxiosRequestConfig): AxiosPromise<CreateFpsTokenResponse>;

  /**
   * Create mandate for an existing sender account
   * @param {string} idempotencyKey A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
   * @param {CreateMandateWithSenderAccountRequest} createMandateRequest request body for creating mandate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  createMandateForExistingSender(
    idempotencyKey: string,
    createMandateRequest: CreateMandateWithSenderAccountRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<CreateMandateResponse>;

  /**
   * Create payment link
   * @param {CreatePaymentLinkRequest} createPaymentLinkRequest Parameters required to create a payment link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  createPaymentLink(
    createPaymentLinkRequest: CreatePaymentLinkRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<PaymentLinkResponse>;

  /**
   * Initiate Card Payment for a Payment Link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  createPaymentLinkCardPayment(options?: AxiosRequestConfig): AxiosPromise<CreatePaymentLinkCardPaymentResponse>;

  /**
   * CREATE Mandate for payment link
   * @param {CreatePaymentLinkMandateRequest} createPaymentLinkMandateRequest request body for creating mandate for payment-link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  createPaymentLinkMandate(
    createPaymentLinkMandateRequest: CreatePaymentLinkMandateRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<CreatePaymentLinkMandateResponse>;

  /**
   * Create a scheduled payout
   * @param {string} idempotencyKey A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
   * @param {CreateScheduledPayoutRequest} createScheduledPayoutRequest Request body containing information to create scheduled payout
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  createScheduledPayout(
    idempotencyKey: string,
    createScheduledPayoutRequest: CreateScheduledPayoutRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<PayoutSnapshotResponse>;

  /**
   * Get the FPS QR code
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getFpsQrCode(options?: AxiosRequestConfig): AxiosPromise<FpsQrCodeResponse>;

  /**
   * Get a customer-specific list of institutions for Finverse Link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getInstitutionsForCustomer(options?: AxiosRequestConfig): AxiosPromise<Array<Institution>>;

  /**
   * Get payment link
   * @param {string} paymentLinkId The payment link id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getPaymentLink(paymentLinkId: string, options?: AxiosRequestConfig): AxiosPromise<PaymentLinkResponse>;

  /**
   * Get payment method in payment link flow
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getPaymentMethodPaymentLink(options?: AxiosRequestConfig): AxiosPromise<PaymentMethodFvLinkResponse>;

  /**
   * Get payout by payout_id
   * @param {string} payoutId payout id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getPayoutById(payoutId: string, options?: AxiosRequestConfig): AxiosPromise<PayoutSnapshotResponse>;

  /**
   * Get sender payment user in payment link flow
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getSenderPaymentUser(options?: AxiosRequestConfig): AxiosPromise<GetPaymentUserResponse>;

  /**
   * List mandates
   * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
   * @param {string} [dateTo] ISO format (YYYY-MM-DD)
   * @param {Array<'AUTHORIZATION_REQUIRED' | 'AUTHORIZING' | 'PROCESSING' | 'SUBMITTED' | 'SUCCEEDED' | 'FAILED' | 'REVOKED'>} [statuses] The mandate statuses to filter for, comma separated
   * @param {'INDIVIDUAL' | 'BUSINESS'} [senderType] The sender type of the mandate
   * @param {string} [userId] The user_id the mandate was setup for
   * @param {string} [institutionId] The institution the mandate was executed against
   * @param {number} [offset] default is 0
   * @param {number} [limit] default is 500, max is 1000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  listMandates(
    dateFrom?: string,
    dateTo?: string,
    statuses?: Array<
      'AUTHORIZATION_REQUIRED' | 'AUTHORIZING' | 'PROCESSING' | 'SUBMITTED' | 'SUCCEEDED' | 'FAILED' | 'REVOKED'
    >,
    senderType?: 'INDIVIDUAL' | 'BUSINESS',
    userId?: string,
    institutionId?: string,
    offset?: number,
    limit?: number,
    options?: AxiosRequestConfig,
  ): AxiosPromise<ListMandatesResponse>;

  /**
   * List Payments
   * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
   * @param {string} [dateTo] ISO format (YYYY-MM-DD)
   * @param {Array<'AUTHORIZATION_REQUIRED' | 'AUTHORIZING' | 'PROCESSING' | 'SUBMITTED' | 'EXECUTED' | 'FAILED' | 'REVOKED'>} [statuses] The payment statuses to filter for, comma separated
   * @param {'INDIVIDUAL' | 'BUSINESS'} [senderType] The sender type of the mandate
   * @param {string} [userId] The user_id the mandate was setup for
   * @param {string} [institutionId] The institution the mandate was executed against
   * @param {'MANDATE' | 'SINGLE'} [paymentType] The type of payment
   * @param {string} [mandateId] The mandate the payment belongs to
   * @param {string} [currency] The currency the payment is made in
   * @param {number} [offset] default is 0
   * @param {number} [limit] default is 500, max is 1000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  listPayments(
    dateFrom?: string,
    dateTo?: string,
    statuses?: Array<
      'AUTHORIZATION_REQUIRED' | 'AUTHORIZING' | 'PROCESSING' | 'SUBMITTED' | 'EXECUTED' | 'FAILED' | 'REVOKED'
    >,
    senderType?: 'INDIVIDUAL' | 'BUSINESS',
    userId?: string,
    institutionId?: string,
    paymentType?: 'MANDATE' | 'SINGLE',
    mandateId?: string,
    currency?: string,
    offset?: number,
    limit?: number,
    options?: AxiosRequestConfig,
  ): AxiosPromise<ListPaymentsResponse>;

  /**
   * Set autopay consent for payment user
   * @param {SetAutopayConsentRequest} setAutopayConsentRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  setAutopayConsent(
    setAutopayConsentRequest: SetAutopayConsentRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<void>;
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI implements DefaultApiInterface {
  /**
   * Cancel a payment link
   * @param {string} paymentLinkId The payment link id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public cancelPaymentLink(paymentLinkId: string, options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .cancelPaymentLink(paymentLinkId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Cancel Payout by payout_id
   * @param {string} payoutId payout id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public cancelPayout(payoutId: string, options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .cancelPayout(payoutId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Submit manual payment confirmation
   * @param {ManualPaymentConfirmationRequest} manualPaymentIdentifiers Request body containing information to identify manual payment
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public confirmManualPayment(
    manualPaymentIdentifiers: ManualPaymentConfirmationRequest,
    options?: AxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .confirmManualPayment(manualPaymentIdentifiers, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Confirm a payment against a payment Link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public confirmPayment(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .confirmPayment(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create token for fps flow
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createFpsToken(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .createFpsToken(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create mandate for an existing sender account
   * @param {string} idempotencyKey A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
   * @param {CreateMandateWithSenderAccountRequest} createMandateRequest request body for creating mandate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createMandateForExistingSender(
    idempotencyKey: string,
    createMandateRequest: CreateMandateWithSenderAccountRequest,
    options?: AxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .createMandateForExistingSender(idempotencyKey, createMandateRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create payment link
   * @param {CreatePaymentLinkRequest} createPaymentLinkRequest Parameters required to create a payment link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createPaymentLink(createPaymentLinkRequest: CreatePaymentLinkRequest, options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .createPaymentLink(createPaymentLinkRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Initiate Card Payment for a Payment Link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createPaymentLinkCardPayment(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .createPaymentLinkCardPayment(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * CREATE Mandate for payment link
   * @param {CreatePaymentLinkMandateRequest} createPaymentLinkMandateRequest request body for creating mandate for payment-link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createPaymentLinkMandate(
    createPaymentLinkMandateRequest: CreatePaymentLinkMandateRequest,
    options?: AxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .createPaymentLinkMandate(createPaymentLinkMandateRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a scheduled payout
   * @param {string} idempotencyKey A random key provided by the customer, per unique payment. The purpose for the Idempotency key is to allow safe retrying without the operation being performed multiple times.
   * @param {CreateScheduledPayoutRequest} createScheduledPayoutRequest Request body containing information to create scheduled payout
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createScheduledPayout(
    idempotencyKey: string,
    createScheduledPayoutRequest: CreateScheduledPayoutRequest,
    options?: AxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .createScheduledPayout(idempotencyKey, createScheduledPayoutRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get the FPS QR code
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getFpsQrCode(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getFpsQrCode(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a customer-specific list of institutions for Finverse Link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getInstitutionsForCustomer(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getInstitutionsForCustomer(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get payment link
   * @param {string} paymentLinkId The payment link id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPaymentLink(paymentLinkId: string, options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getPaymentLink(paymentLinkId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get payment method in payment link flow
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPaymentMethodPaymentLink(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getPaymentMethodPaymentLink(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get payout by payout_id
   * @param {string} payoutId payout id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPayoutById(payoutId: string, options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getPayoutById(payoutId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get sender payment user in payment link flow
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getSenderPaymentUser(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getSenderPaymentUser(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List mandates
   * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
   * @param {string} [dateTo] ISO format (YYYY-MM-DD)
   * @param {Array<'AUTHORIZATION_REQUIRED' | 'AUTHORIZING' | 'PROCESSING' | 'SUBMITTED' | 'SUCCEEDED' | 'FAILED' | 'REVOKED'>} [statuses] The mandate statuses to filter for, comma separated
   * @param {'INDIVIDUAL' | 'BUSINESS'} [senderType] The sender type of the mandate
   * @param {string} [userId] The user_id the mandate was setup for
   * @param {string} [institutionId] The institution the mandate was executed against
   * @param {number} [offset] default is 0
   * @param {number} [limit] default is 500, max is 1000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public listMandates(
    dateFrom?: string,
    dateTo?: string,
    statuses?: Array<
      'AUTHORIZATION_REQUIRED' | 'AUTHORIZING' | 'PROCESSING' | 'SUBMITTED' | 'SUCCEEDED' | 'FAILED' | 'REVOKED'
    >,
    senderType?: 'INDIVIDUAL' | 'BUSINESS',
    userId?: string,
    institutionId?: string,
    offset?: number,
    limit?: number,
    options?: AxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .listMandates(dateFrom, dateTo, statuses, senderType, userId, institutionId, offset, limit, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List Payments
   * @param {string} [dateFrom] ISO format (YYYY-MM-DD)
   * @param {string} [dateTo] ISO format (YYYY-MM-DD)
   * @param {Array<'AUTHORIZATION_REQUIRED' | 'AUTHORIZING' | 'PROCESSING' | 'SUBMITTED' | 'EXECUTED' | 'FAILED' | 'REVOKED'>} [statuses] The payment statuses to filter for, comma separated
   * @param {'INDIVIDUAL' | 'BUSINESS'} [senderType] The sender type of the mandate
   * @param {string} [userId] The user_id the mandate was setup for
   * @param {string} [institutionId] The institution the mandate was executed against
   * @param {'MANDATE' | 'SINGLE'} [paymentType] The type of payment
   * @param {string} [mandateId] The mandate the payment belongs to
   * @param {string} [currency] The currency the payment is made in
   * @param {number} [offset] default is 0
   * @param {number} [limit] default is 500, max is 1000
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public listPayments(
    dateFrom?: string,
    dateTo?: string,
    statuses?: Array<
      'AUTHORIZATION_REQUIRED' | 'AUTHORIZING' | 'PROCESSING' | 'SUBMITTED' | 'EXECUTED' | 'FAILED' | 'REVOKED'
    >,
    senderType?: 'INDIVIDUAL' | 'BUSINESS',
    userId?: string,
    institutionId?: string,
    paymentType?: 'MANDATE' | 'SINGLE',
    mandateId?: string,
    currency?: string,
    offset?: number,
    limit?: number,
    options?: AxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .listPayments(
        dateFrom,
        dateTo,
        statuses,
        senderType,
        userId,
        institutionId,
        paymentType,
        mandateId,
        currency,
        offset,
        limit,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Set autopay consent for payment user
   * @param {SetAutopayConsentRequest} setAutopayConsentRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public setAutopayConsent(setAutopayConsentRequest: SetAutopayConsentRequest, options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .setAutopayConsent(setAutopayConsentRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * LinkApi - axios parameter creator
 * @export
 */
export const LinkApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create a new link and submit credentials
     * @param {ApiLinkRequest} apiLinkRequest Request body for creating a new link and submitting credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLink: async (apiLinkRequest: ApiLinkRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'apiLinkRequest' is not null or undefined
      assertParamExists('createLink', 'apiLinkRequest', apiLinkRequest);
      const localVarPath = `/link`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(apiLinkRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates a new link
     * @param {LinkRequest} linkRequest Request body for starting a new Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLinkWoauth: async (linkRequest: LinkRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'linkRequest' is not null or undefined
      assertParamExists('createLinkWoauth', 'linkRequest', linkRequest);
      const localVarPath = `/link/woauth`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', ['link'], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(linkRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Post the user action value
     * @param {string} loginIdentityId The login identity id
     * @param {ActionRequest} actionRequest Request body for post link action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkAction: async (
      loginIdentityId: string,
      actionRequest: ActionRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'loginIdentityId' is not null or undefined
      assertParamExists('linkAction', 'loginIdentityId', loginIdentityId);
      // verify required parameter 'actionRequest' is not null or undefined
      assertParamExists('linkAction', 'actionRequest', actionRequest);
      const localVarPath = `/link/action/{loginIdentityId}`.replace(
        `{${'loginIdentityId'}}`,
        encodeURIComponent(String(loginIdentityId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(actionRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Check the status of a given loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkStatus: async (loginIdentityId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'loginIdentityId' is not null or undefined
      assertParamExists('linkStatus', 'loginIdentityId', loginIdentityId);
      const localVarPath = `/link/status/{loginIdentityId}`.replace(
        `{${'loginIdentityId'}}`,
        encodeURIComponent(String(loginIdentityId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Check the status of a given login identity via FVLink
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkStatusNonSensitive: async (loginIdentityId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'loginIdentityId' is not null or undefined
      assertParamExists('linkStatusNonSensitive', 'loginIdentityId', loginIdentityId);
      const localVarPath = `/link/fvlink/status/{loginIdentityId}`.replace(
        `{${'loginIdentityId'}}`,
        encodeURIComponent(String(loginIdentityId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of institutions
     * @param {string} [country] (Deprecated) The country the institution belongs to
     * @param {Array<string>} [countries] The countries the institution belongs to
     * @param {string} [productsSupported] The products that this institution supports
     * @param {'BANK' | 'WALLET' | 'TEST'} [institutionType] The type of institution
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listInstitutions: async (
      country?: string,
      countries?: Array<string>,
      productsSupported?: string,
      institutionType?: 'BANK' | 'WALLET' | 'TEST',
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/institutions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', ['institution'], configuration);

      if (country !== undefined) {
        localVarQueryParameter['country'] = country;
      }

      if (countries) {
        localVarQueryParameter['countries'] = countries.join(COLLECTION_FORMATS.csv);
      }

      if (productsSupported !== undefined) {
        localVarQueryParameter['products_supported'] = productsSupported;
      }

      if (institutionType !== undefined) {
        localVarQueryParameter['institution_type'] = institutionType;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update an existing link
     * @param {RelinkRequest} relinkRequest Request body for updating Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    relink: async (relinkRequest: RelinkRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'relinkRequest' is not null or undefined
      assertParamExists('relink', 'relinkRequest', relinkRequest);
      const localVarPath = `/link/relink`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(relinkRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a new link using an existing LIID
     * @param {string} loginIdentityId The login identity id
     * @param {ApiRelinkRequest} apiRelinkRequest Request body for relinking and submitting credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    relinkV2: async (
      loginIdentityId: string,
      apiRelinkRequest: ApiRelinkRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'loginIdentityId' is not null or undefined
      assertParamExists('relinkV2', 'loginIdentityId', loginIdentityId);
      // verify required parameter 'apiRelinkRequest' is not null or undefined
      assertParamExists('relinkV2', 'apiRelinkRequest', apiRelinkRequest);
      const localVarPath = `/link/relink/{loginIdentityId}`.replace(
        `{${'loginIdentityId'}}`,
        encodeURIComponent(String(loginIdentityId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(apiRelinkRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Exchange authorization code for token
     * @param {string} grantType
     * @param {string} code
     * @param {string} clientId
     * @param {string} redirectUri
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    token: async (
      grantType: string,
      code: string,
      clientId: string,
      redirectUri: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'grantType' is not null or undefined
      assertParamExists('token', 'grantType', grantType);
      // verify required parameter 'code' is not null or undefined
      assertParamExists('token', 'code', code);
      // verify required parameter 'clientId' is not null or undefined
      assertParamExists('token', 'clientId', clientId);
      // verify required parameter 'redirectUri' is not null or undefined
      assertParamExists('token', 'redirectUri', redirectUri);
      const localVarPath = `/auth/token`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new URLSearchParams();

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      if (grantType !== undefined) {
        localVarFormParams.set('grant_type', grantType as any);
      }

      if (code !== undefined) {
        localVarFormParams.set('code', code as any);
      }

      if (clientId !== undefined) {
        localVarFormParams.set('client_id', clientId as any);
      }

      if (redirectUri !== undefined) {
        localVarFormParams.set('redirect_uri', redirectUri as any);
      }

      localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = localVarFormParams.toString();

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LinkApi - functional programming interface
 * @export
 */
export const LinkApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = LinkApiAxiosParamCreator(configuration);
  return {
    /**
     * Create a new link and submit credentials
     * @param {ApiLinkRequest} apiLinkRequest Request body for creating a new link and submitting credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createLink(
      apiLinkRequest: ApiLinkRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLoginIdentityByIdResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createLink(apiLinkRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Creates a new link
     * @param {LinkRequest} linkRequest Request body for starting a new Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createLinkWoauth(
      linkRequest: LinkRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createLinkWoauth(linkRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Post the user action value
     * @param {string} loginIdentityId The login identity id
     * @param {ActionRequest} actionRequest Request body for post link action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async linkAction(
      loginIdentityId: string,
      actionRequest: ActionRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLoginIdentityByIdResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.linkAction(loginIdentityId, actionRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Check the status of a given loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async linkStatus(
      loginIdentityId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkStatusResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.linkStatus(loginIdentityId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Check the status of a given login identity via FVLink
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async linkStatusNonSensitive(
      loginIdentityId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonSensitiveLinkStatusResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.linkStatusNonSensitive(loginIdentityId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get a list of institutions
     * @param {string} [country] (Deprecated) The country the institution belongs to
     * @param {Array<string>} [countries] The countries the institution belongs to
     * @param {string} [productsSupported] The products that this institution supports
     * @param {'BANK' | 'WALLET' | 'TEST'} [institutionType] The type of institution
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listInstitutions(
      country?: string,
      countries?: Array<string>,
      productsSupported?: string,
      institutionType?: 'BANK' | 'WALLET' | 'TEST',
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Institution>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listInstitutions(
        country,
        countries,
        productsSupported,
        institutionType,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Update an existing link
     * @param {RelinkRequest} relinkRequest Request body for updating Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async relink(
      relinkRequest: RelinkRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.relink(relinkRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Create a new link using an existing LIID
     * @param {string} loginIdentityId The login identity id
     * @param {ApiRelinkRequest} apiRelinkRequest Request body for relinking and submitting credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async relinkV2(
      loginIdentityId: string,
      apiRelinkRequest: ApiRelinkRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLoginIdentityByIdResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.relinkV2(loginIdentityId, apiRelinkRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Exchange authorization code for token
     * @param {string} grantType
     * @param {string} code
     * @param {string} clientId
     * @param {string} redirectUri
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async token(
      grantType: string,
      code: string,
      clientId: string,
      redirectUri: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessTokenResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.token(grantType, code, clientId, redirectUri, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * LinkApi - factory interface
 * @export
 */
export const LinkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = LinkApiFp(configuration);
  return {
    /**
     * Create a new link and submit credentials
     * @param {ApiLinkRequest} apiLinkRequest Request body for creating a new link and submitting credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLink(apiLinkRequest: ApiLinkRequest, options?: any): AxiosPromise<GetLoginIdentityByIdResponse> {
      return localVarFp.createLink(apiLinkRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Creates a new link
     * @param {LinkRequest} linkRequest Request body for starting a new Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLinkWoauth(linkRequest: LinkRequest, options?: any): AxiosPromise<LinkResponse> {
      return localVarFp.createLinkWoauth(linkRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Post the user action value
     * @param {string} loginIdentityId The login identity id
     * @param {ActionRequest} actionRequest Request body for post link action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkAction(
      loginIdentityId: string,
      actionRequest: ActionRequest,
      options?: any,
    ): AxiosPromise<GetLoginIdentityByIdResponse> {
      return localVarFp.linkAction(loginIdentityId, actionRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Check the status of a given loginIdentity
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkStatus(loginIdentityId: string, options?: any): AxiosPromise<LinkStatusResponse> {
      return localVarFp.linkStatus(loginIdentityId, options).then((request) => request(axios, basePath));
    },
    /**
     * Check the status of a given login identity via FVLink
     * @param {string} loginIdentityId The login identity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    linkStatusNonSensitive(loginIdentityId: string, options?: any): AxiosPromise<NonSensitiveLinkStatusResponse> {
      return localVarFp.linkStatusNonSensitive(loginIdentityId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get a list of institutions
     * @param {string} [country] (Deprecated) The country the institution belongs to
     * @param {Array<string>} [countries] The countries the institution belongs to
     * @param {string} [productsSupported] The products that this institution supports
     * @param {'BANK' | 'WALLET' | 'TEST'} [institutionType] The type of institution
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listInstitutions(
      country?: string,
      countries?: Array<string>,
      productsSupported?: string,
      institutionType?: 'BANK' | 'WALLET' | 'TEST',
      options?: any,
    ): AxiosPromise<Array<Institution>> {
      return localVarFp
        .listInstitutions(country, countries, productsSupported, institutionType, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update an existing link
     * @param {RelinkRequest} relinkRequest Request body for updating Link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    relink(relinkRequest: RelinkRequest, options?: any): AxiosPromise<LinkResponse> {
      return localVarFp.relink(relinkRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Create a new link using an existing LIID
     * @param {string} loginIdentityId The login identity id
     * @param {ApiRelinkRequest} apiRelinkRequest Request body for relinking and submitting credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    relinkV2(
      loginIdentityId: string,
      apiRelinkRequest: ApiRelinkRequest,
      options?: any,
    ): AxiosPromise<GetLoginIdentityByIdResponse> {
      return localVarFp
        .relinkV2(loginIdentityId, apiRelinkRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Exchange authorization code for token
     * @param {string} grantType
     * @param {string} code
     * @param {string} clientId
     * @param {string} redirectUri
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    token(
      grantType: string,
      code: string,
      clientId: string,
      redirectUri: string,
      options?: any,
    ): AxiosPromise<AccessTokenResponse> {
      return localVarFp
        .token(grantType, code, clientId, redirectUri, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * LinkApi - interface
 * @export
 * @interface LinkApi
 */
export interface LinkApiInterface {
  /**
   * Create a new link and submit credentials
   * @param {ApiLinkRequest} apiLinkRequest Request body for creating a new link and submitting credentials
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApiInterface
   */
  createLink(apiLinkRequest: ApiLinkRequest, options?: AxiosRequestConfig): AxiosPromise<GetLoginIdentityByIdResponse>;

  /**
   * Creates a new link
   * @param {LinkRequest} linkRequest Request body for starting a new Link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApiInterface
   */
  createLinkWoauth(linkRequest: LinkRequest, options?: AxiosRequestConfig): AxiosPromise<LinkResponse>;

  /**
   * Post the user action value
   * @param {string} loginIdentityId The login identity id
   * @param {ActionRequest} actionRequest Request body for post link action
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApiInterface
   */
  linkAction(
    loginIdentityId: string,
    actionRequest: ActionRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<GetLoginIdentityByIdResponse>;

  /**
   * Check the status of a given loginIdentity
   * @param {string} loginIdentityId The login identity id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApiInterface
   */
  linkStatus(loginIdentityId: string, options?: AxiosRequestConfig): AxiosPromise<LinkStatusResponse>;

  /**
   * Check the status of a given login identity via FVLink
   * @param {string} loginIdentityId The login identity id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApiInterface
   */
  linkStatusNonSensitive(
    loginIdentityId: string,
    options?: AxiosRequestConfig,
  ): AxiosPromise<NonSensitiveLinkStatusResponse>;

  /**
   * Get a list of institutions
   * @param {string} [country] (Deprecated) The country the institution belongs to
   * @param {Array<string>} [countries] The countries the institution belongs to
   * @param {string} [productsSupported] The products that this institution supports
   * @param {'BANK' | 'WALLET' | 'TEST'} [institutionType] The type of institution
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApiInterface
   */
  listInstitutions(
    country?: string,
    countries?: Array<string>,
    productsSupported?: string,
    institutionType?: 'BANK' | 'WALLET' | 'TEST',
    options?: AxiosRequestConfig,
  ): AxiosPromise<Array<Institution>>;

  /**
   * Update an existing link
   * @param {RelinkRequest} relinkRequest Request body for updating Link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApiInterface
   */
  relink(relinkRequest: RelinkRequest, options?: AxiosRequestConfig): AxiosPromise<LinkResponse>;

  /**
   * Create a new link using an existing LIID
   * @param {string} loginIdentityId The login identity id
   * @param {ApiRelinkRequest} apiRelinkRequest Request body for relinking and submitting credentials
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApiInterface
   */
  relinkV2(
    loginIdentityId: string,
    apiRelinkRequest: ApiRelinkRequest,
    options?: AxiosRequestConfig,
  ): AxiosPromise<GetLoginIdentityByIdResponse>;

  /**
   * Exchange authorization code for token
   * @param {string} grantType
   * @param {string} code
   * @param {string} clientId
   * @param {string} redirectUri
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApiInterface
   */
  token(
    grantType: string,
    code: string,
    clientId: string,
    redirectUri: string,
    options?: AxiosRequestConfig,
  ): AxiosPromise<AccessTokenResponse>;
}

/**
 * LinkApi - object-oriented interface
 * @export
 * @class LinkApi
 * @extends {BaseAPI}
 */
export class LinkApi extends BaseAPI implements LinkApiInterface {
  /**
   * Create a new link and submit credentials
   * @param {ApiLinkRequest} apiLinkRequest Request body for creating a new link and submitting credentials
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApi
   */
  public createLink(apiLinkRequest: ApiLinkRequest, options?: AxiosRequestConfig) {
    return LinkApiFp(this.configuration)
      .createLink(apiLinkRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates a new link
   * @param {LinkRequest} linkRequest Request body for starting a new Link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApi
   */
  public createLinkWoauth(linkRequest: LinkRequest, options?: AxiosRequestConfig) {
    return LinkApiFp(this.configuration)
      .createLinkWoauth(linkRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Post the user action value
   * @param {string} loginIdentityId The login identity id
   * @param {ActionRequest} actionRequest Request body for post link action
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApi
   */
  public linkAction(loginIdentityId: string, actionRequest: ActionRequest, options?: AxiosRequestConfig) {
    return LinkApiFp(this.configuration)
      .linkAction(loginIdentityId, actionRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Check the status of a given loginIdentity
   * @param {string} loginIdentityId The login identity id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApi
   */
  public linkStatus(loginIdentityId: string, options?: AxiosRequestConfig) {
    return LinkApiFp(this.configuration)
      .linkStatus(loginIdentityId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Check the status of a given login identity via FVLink
   * @param {string} loginIdentityId The login identity id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApi
   */
  public linkStatusNonSensitive(loginIdentityId: string, options?: AxiosRequestConfig) {
    return LinkApiFp(this.configuration)
      .linkStatusNonSensitive(loginIdentityId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of institutions
   * @param {string} [country] (Deprecated) The country the institution belongs to
   * @param {Array<string>} [countries] The countries the institution belongs to
   * @param {string} [productsSupported] The products that this institution supports
   * @param {'BANK' | 'WALLET' | 'TEST'} [institutionType] The type of institution
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApi
   */
  public listInstitutions(
    country?: string,
    countries?: Array<string>,
    productsSupported?: string,
    institutionType?: 'BANK' | 'WALLET' | 'TEST',
    options?: AxiosRequestConfig,
  ) {
    return LinkApiFp(this.configuration)
      .listInstitutions(country, countries, productsSupported, institutionType, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update an existing link
   * @param {RelinkRequest} relinkRequest Request body for updating Link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApi
   */
  public relink(relinkRequest: RelinkRequest, options?: AxiosRequestConfig) {
    return LinkApiFp(this.configuration)
      .relink(relinkRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a new link using an existing LIID
   * @param {string} loginIdentityId The login identity id
   * @param {ApiRelinkRequest} apiRelinkRequest Request body for relinking and submitting credentials
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApi
   */
  public relinkV2(loginIdentityId: string, apiRelinkRequest: ApiRelinkRequest, options?: AxiosRequestConfig) {
    return LinkApiFp(this.configuration)
      .relinkV2(loginIdentityId, apiRelinkRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Exchange authorization code for token
   * @param {string} grantType
   * @param {string} code
   * @param {string} clientId
   * @param {string} redirectUri
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LinkApi
   */
  public token(grantType: string, code: string, clientId: string, redirectUri: string, options?: AxiosRequestConfig) {
    return LinkApiFp(this.configuration)
      .token(grantType, code, clientId, redirectUri, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * LoginIdentityApi - axios parameter creator
 * @export
 */
export const LoginIdentityApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Delete a specific loginIdentity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLoginIdentity: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/login_identity`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * generate a link token that can be used to create link
     * @param {LinkTokenRequest} linkTokenRequest token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateLinkToken: async (
      linkTokenRequest: LinkTokenRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'linkTokenRequest' is not null or undefined
      assertParamExists('generateLinkToken', 'linkTokenRequest', linkTokenRequest);
      const localVarPath = `/link/token`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(linkTokenRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a specific account\'s information
     * @param {string} accountId The account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccount: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('getAccount', 'accountId', accountId);
      const localVarPath = `/accounts/{accountId}`.replace(`{${'accountId'}}`, encodeURIComponent(String(accountId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', ['account'], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the account number for a specific account
     * @param {string} accountId The account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccountNumber: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('getAccountNumber', 'accountId', accountId);
      const localVarPath = `/account_numbers/{accountId}`.replace(
        `{${'accountId'}}`,
        encodeURIComponent(String(accountId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the balance history for a specific account
     * @param {string} accountId The account id
     * @param {'INSTITUTION' | 'COMPUTED'} [source] The source will determine what type of balance history will be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBalanceHistory: async (
      accountId: string,
      source?: 'INSTITUTION' | 'COMPUTED',
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('getBalanceHistory', 'accountId', accountId);
      const localVarPath = `/balance_history/{accountId}`.replace(
        `{${'accountId'}}`,
        encodeURIComponent(String(accountId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      if (source !== undefined) {
        localVarQueryParameter['source'] = source;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Download composite statement
     * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCompositeStatement: async (redirect?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/composite_statement`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      if (redirect !== undefined) {
        localVarQueryParameter['redirect'] = redirect;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * \\[BETA] Get a list of identity data for a given login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentity: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/identity`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get income figures for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIncomeEstimateByLoginIdentityId: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/income`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a specific loginIdentity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoginIdentity: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/login_identity`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Download statement
     * @param {string} statementId The statement id
     * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatement: async (
      statementId: string,
      redirect?: boolean,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'statementId' is not null or undefined
      assertParamExists('getStatement', 'statementId', statementId);
      const localVarPath = `/statements/{statementId}`.replace(
        `{${'statementId'}}`,
        encodeURIComponent(String(statementId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      if (redirect !== undefined) {
        localVarQueryParameter['redirect'] = redirect;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get list of available statements
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatements: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/statements`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of accounts for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAccounts: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/accounts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', ['account'], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of card details for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCardDetails: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/card_details`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of transactions for a particular account. The transactions are returned in sorted order, with the most recent one appearing first.
     * @param {string} accountId The account id (ULID, example - 01EP4A1MZDHKETZFRPF0K62S6S)
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {boolean} [enrichments] when true, response will be enriched transactions; otherwise it will be raw transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTransactionsByAccountId: async (
      accountId: string,
      offset?: number,
      limit?: number,
      enrichments?: boolean,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('listTransactionsByAccountId', 'accountId', accountId);
      const localVarPath = `/transactions/{accountId}`.replace(
        `{${'accountId'}}`,
        encodeURIComponent(String(accountId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', ['transaction'], configuration);

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (enrichments !== undefined) {
        localVarQueryParameter['enrichments'] = enrichments;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of transactions for a login identity. The transactions are returned in sorted order, with the most recent one appearing first.
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {boolean} [enrichments] when true, response will be enriched transactions; otherwise it will be raw transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTransactionsByLoginIdentityId: async (
      offset?: number,
      limit?: number,
      enrichments?: boolean,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/transactions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', ['transaction'], configuration);

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (enrichments !== undefined) {
        localVarQueryParameter['enrichments'] = enrichments;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a refresh job for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshLoginIdentity: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/login_identity/refresh`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', [], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LoginIdentityApi - functional programming interface
 * @export
 */
export const LoginIdentityApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = LoginIdentityApiAxiosParamCreator(configuration);
  return {
    /**
     * Delete a specific loginIdentity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteLoginIdentity(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteLoginIdentityResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLoginIdentity(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * generate a link token that can be used to create link
     * @param {LinkTokenRequest} linkTokenRequest token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async generateLinkToken(
      linkTokenRequest: LinkTokenRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkTokenResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.generateLinkToken(linkTokenRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get a specific account\'s information
     * @param {string} accountId The account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAccount(
      accountId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAccountResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(accountId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get the account number for a specific account
     * @param {string} accountId The account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAccountNumber(
      accountId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAccountNumberResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountNumber(accountId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get the balance history for a specific account
     * @param {string} accountId The account id
     * @param {'INSTITUTION' | 'COMPUTED'} [source] The source will determine what type of balance history will be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBalanceHistory(
      accountId: string,
      source?: 'INSTITUTION' | 'COMPUTED',
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBalanceHistoryResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBalanceHistory(accountId, source, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Download composite statement
     * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCompositeStatement(
      redirect?: boolean,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompositeStatementLink>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCompositeStatement(redirect, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * \\[BETA] Get a list of identity data for a given login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getIdentity(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetIdentityResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentity(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get income figures for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getIncomeEstimateByLoginIdentityId(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IncomeResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getIncomeEstimateByLoginIdentityId(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get a specific loginIdentity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLoginIdentity(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLoginIdentityByIdResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLoginIdentity(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Download statement
     * @param {string} statementId The statement id
     * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStatement(
      statementId: string,
      redirect?: boolean,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStatementLinkResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStatement(statementId, redirect, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get list of available statements
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStatements(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStatementsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStatements(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get a list of accounts for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listAccounts(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAccountsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listAccounts(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get a list of card details for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listCardDetails(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCardsDetailsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listCardDetails(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get a list of transactions for a particular account. The transactions are returned in sorted order, with the most recent one appearing first.
     * @param {string} accountId The account id (ULID, example - 01EP4A1MZDHKETZFRPF0K62S6S)
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {boolean} [enrichments] when true, response will be enriched transactions; otherwise it will be raw transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listTransactionsByAccountId(
      accountId: string,
      offset?: number,
      limit?: number,
      enrichments?: boolean,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListTransactionsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listTransactionsByAccountId(
        accountId,
        offset,
        limit,
        enrichments,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Get a list of transactions for a login identity. The transactions are returned in sorted order, with the most recent one appearing first.
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {boolean} [enrichments] when true, response will be enriched transactions; otherwise it will be raw transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listTransactionsByLoginIdentityId(
      offset?: number,
      limit?: number,
      enrichments?: boolean,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListTransactionsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listTransactionsByLoginIdentityId(
        offset,
        limit,
        enrichments,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Create a refresh job for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async refreshLoginIdentity(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.refreshLoginIdentity(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * LoginIdentityApi - factory interface
 * @export
 */
export const LoginIdentityApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = LoginIdentityApiFp(configuration);
  return {
    /**
     * Delete a specific loginIdentity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLoginIdentity(options?: any): AxiosPromise<DeleteLoginIdentityResponse> {
      return localVarFp.deleteLoginIdentity(options).then((request) => request(axios, basePath));
    },
    /**
     * generate a link token that can be used to create link
     * @param {LinkTokenRequest} linkTokenRequest token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateLinkToken(linkTokenRequest: LinkTokenRequest, options?: any): AxiosPromise<LinkTokenResponse> {
      return localVarFp.generateLinkToken(linkTokenRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Get a specific account\'s information
     * @param {string} accountId The account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccount(accountId: string, options?: any): AxiosPromise<GetAccountResponse> {
      return localVarFp.getAccount(accountId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get the account number for a specific account
     * @param {string} accountId The account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccountNumber(accountId: string, options?: any): AxiosPromise<GetAccountNumberResponse> {
      return localVarFp.getAccountNumber(accountId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get the balance history for a specific account
     * @param {string} accountId The account id
     * @param {'INSTITUTION' | 'COMPUTED'} [source] The source will determine what type of balance history will be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBalanceHistory(
      accountId: string,
      source?: 'INSTITUTION' | 'COMPUTED',
      options?: any,
    ): AxiosPromise<GetBalanceHistoryResponse> {
      return localVarFp.getBalanceHistory(accountId, source, options).then((request) => request(axios, basePath));
    },
    /**
     * Download composite statement
     * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCompositeStatement(redirect?: boolean, options?: any): AxiosPromise<CompositeStatementLink> {
      return localVarFp.getCompositeStatement(redirect, options).then((request) => request(axios, basePath));
    },
    /**
     * \\[BETA] Get a list of identity data for a given login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentity(options?: any): AxiosPromise<GetIdentityResponse> {
      return localVarFp.getIdentity(options).then((request) => request(axios, basePath));
    },
    /**
     * Get income figures for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIncomeEstimateByLoginIdentityId(options?: any): AxiosPromise<IncomeResponse> {
      return localVarFp.getIncomeEstimateByLoginIdentityId(options).then((request) => request(axios, basePath));
    },
    /**
     * Get a specific loginIdentity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoginIdentity(options?: any): AxiosPromise<GetLoginIdentityByIdResponse> {
      return localVarFp.getLoginIdentity(options).then((request) => request(axios, basePath));
    },
    /**
     * Download statement
     * @param {string} statementId The statement id
     * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatement(statementId: string, redirect?: boolean, options?: any): AxiosPromise<GetStatementLinkResponse> {
      return localVarFp.getStatement(statementId, redirect, options).then((request) => request(axios, basePath));
    },
    /**
     * Get list of available statements
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatements(options?: any): AxiosPromise<GetStatementsResponse> {
      return localVarFp.getStatements(options).then((request) => request(axios, basePath));
    },
    /**
     * Get a list of accounts for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAccounts(options?: any): AxiosPromise<ListAccountsResponse> {
      return localVarFp.listAccounts(options).then((request) => request(axios, basePath));
    },
    /**
     * Get a list of card details for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCardDetails(options?: any): AxiosPromise<ListCardsDetailsResponse> {
      return localVarFp.listCardDetails(options).then((request) => request(axios, basePath));
    },
    /**
     * Get a list of transactions for a particular account. The transactions are returned in sorted order, with the most recent one appearing first.
     * @param {string} accountId The account id (ULID, example - 01EP4A1MZDHKETZFRPF0K62S6S)
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {boolean} [enrichments] when true, response will be enriched transactions; otherwise it will be raw transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTransactionsByAccountId(
      accountId: string,
      offset?: number,
      limit?: number,
      enrichments?: boolean,
      options?: any,
    ): AxiosPromise<ListTransactionsResponse> {
      return localVarFp
        .listTransactionsByAccountId(accountId, offset, limit, enrichments, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a list of transactions for a login identity. The transactions are returned in sorted order, with the most recent one appearing first.
     * @param {number} [offset] default is 0
     * @param {number} [limit] default is 500, max is 1000
     * @param {boolean} [enrichments] when true, response will be enriched transactions; otherwise it will be raw transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTransactionsByLoginIdentityId(
      offset?: number,
      limit?: number,
      enrichments?: boolean,
      options?: any,
    ): AxiosPromise<ListTransactionsResponse> {
      return localVarFp
        .listTransactionsByLoginIdentityId(offset, limit, enrichments, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a refresh job for a login identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshLoginIdentity(options?: any): AxiosPromise<void> {
      return localVarFp.refreshLoginIdentity(options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * LoginIdentityApi - interface
 * @export
 * @interface LoginIdentityApi
 */
export interface LoginIdentityApiInterface {
  /**
   * Delete a specific loginIdentity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  deleteLoginIdentity(options?: AxiosRequestConfig): AxiosPromise<DeleteLoginIdentityResponse>;

  /**
   * generate a link token that can be used to create link
   * @param {LinkTokenRequest} linkTokenRequest token request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  generateLinkToken(linkTokenRequest: LinkTokenRequest, options?: AxiosRequestConfig): AxiosPromise<LinkTokenResponse>;

  /**
   * Get a specific account\'s information
   * @param {string} accountId The account id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  getAccount(accountId: string, options?: AxiosRequestConfig): AxiosPromise<GetAccountResponse>;

  /**
   * Get the account number for a specific account
   * @param {string} accountId The account id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  getAccountNumber(accountId: string, options?: AxiosRequestConfig): AxiosPromise<GetAccountNumberResponse>;

  /**
   * Get the balance history for a specific account
   * @param {string} accountId The account id
   * @param {'INSTITUTION' | 'COMPUTED'} [source] The source will determine what type of balance history will be returned
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  getBalanceHistory(
    accountId: string,
    source?: 'INSTITUTION' | 'COMPUTED',
    options?: AxiosRequestConfig,
  ): AxiosPromise<GetBalanceHistoryResponse>;

  /**
   * Download composite statement
   * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  getCompositeStatement(redirect?: boolean, options?: AxiosRequestConfig): AxiosPromise<CompositeStatementLink>;

  /**
   * \\[BETA] Get a list of identity data for a given login identity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  getIdentity(options?: AxiosRequestConfig): AxiosPromise<GetIdentityResponse>;

  /**
   * Get income figures for a login identity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  getIncomeEstimateByLoginIdentityId(options?: AxiosRequestConfig): AxiosPromise<IncomeResponse>;

  /**
   * Get a specific loginIdentity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  getLoginIdentity(options?: AxiosRequestConfig): AxiosPromise<GetLoginIdentityByIdResponse>;

  /**
   * Download statement
   * @param {string} statementId The statement id
   * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  getStatement(
    statementId: string,
    redirect?: boolean,
    options?: AxiosRequestConfig,
  ): AxiosPromise<GetStatementLinkResponse>;

  /**
   * Get list of available statements
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  getStatements(options?: AxiosRequestConfig): AxiosPromise<GetStatementsResponse>;

  /**
   * Get a list of accounts for a login identity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  listAccounts(options?: AxiosRequestConfig): AxiosPromise<ListAccountsResponse>;

  /**
   * Get a list of card details for a login identity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  listCardDetails(options?: AxiosRequestConfig): AxiosPromise<ListCardsDetailsResponse>;

  /**
   * Get a list of transactions for a particular account. The transactions are returned in sorted order, with the most recent one appearing first.
   * @param {string} accountId The account id (ULID, example - 01EP4A1MZDHKETZFRPF0K62S6S)
   * @param {number} [offset] default is 0
   * @param {number} [limit] default is 500, max is 1000
   * @param {boolean} [enrichments] when true, response will be enriched transactions; otherwise it will be raw transactions
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  listTransactionsByAccountId(
    accountId: string,
    offset?: number,
    limit?: number,
    enrichments?: boolean,
    options?: AxiosRequestConfig,
  ): AxiosPromise<ListTransactionsResponse>;

  /**
   * Get a list of transactions for a login identity. The transactions are returned in sorted order, with the most recent one appearing first.
   * @param {number} [offset] default is 0
   * @param {number} [limit] default is 500, max is 1000
   * @param {boolean} [enrichments] when true, response will be enriched transactions; otherwise it will be raw transactions
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  listTransactionsByLoginIdentityId(
    offset?: number,
    limit?: number,
    enrichments?: boolean,
    options?: AxiosRequestConfig,
  ): AxiosPromise<ListTransactionsResponse>;

  /**
   * Create a refresh job for a login identity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApiInterface
   */
  refreshLoginIdentity(options?: AxiosRequestConfig): AxiosPromise<void>;
}

/**
 * LoginIdentityApi - object-oriented interface
 * @export
 * @class LoginIdentityApi
 * @extends {BaseAPI}
 */
export class LoginIdentityApi extends BaseAPI implements LoginIdentityApiInterface {
  /**
   * Delete a specific loginIdentity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public deleteLoginIdentity(options?: AxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .deleteLoginIdentity(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * generate a link token that can be used to create link
   * @param {LinkTokenRequest} linkTokenRequest token request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public generateLinkToken(linkTokenRequest: LinkTokenRequest, options?: AxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .generateLinkToken(linkTokenRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a specific account\'s information
   * @param {string} accountId The account id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public getAccount(accountId: string, options?: AxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .getAccount(accountId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get the account number for a specific account
   * @param {string} accountId The account id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public getAccountNumber(accountId: string, options?: AxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .getAccountNumber(accountId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get the balance history for a specific account
   * @param {string} accountId The account id
   * @param {'INSTITUTION' | 'COMPUTED'} [source] The source will determine what type of balance history will be returned
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public getBalanceHistory(accountId: string, source?: 'INSTITUTION' | 'COMPUTED', options?: AxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .getBalanceHistory(accountId, source, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Download composite statement
   * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public getCompositeStatement(redirect?: boolean, options?: AxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .getCompositeStatement(redirect, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * \\[BETA] Get a list of identity data for a given login identity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public getIdentity(options?: AxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .getIdentity(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get income figures for a login identity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public getIncomeEstimateByLoginIdentityId(options?: AxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .getIncomeEstimateByLoginIdentityId(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a specific loginIdentity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public getLoginIdentity(options?: AxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .getLoginIdentity(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Download statement
   * @param {string} statementId The statement id
   * @param {boolean} [redirect] when true, response will be http redirect; otherwise it will be json response with the download link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public getStatement(statementId: string, redirect?: boolean, options?: AxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .getStatement(statementId, redirect, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get list of available statements
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public getStatements(options?: AxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .getStatements(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of accounts for a login identity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public listAccounts(options?: AxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .listAccounts(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of card details for a login identity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public listCardDetails(options?: AxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .listCardDetails(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of transactions for a particular account. The transactions are returned in sorted order, with the most recent one appearing first.
   * @param {string} accountId The account id (ULID, example - 01EP4A1MZDHKETZFRPF0K62S6S)
   * @param {number} [offset] default is 0
   * @param {number} [limit] default is 500, max is 1000
   * @param {boolean} [enrichments] when true, response will be enriched transactions; otherwise it will be raw transactions
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public listTransactionsByAccountId(
    accountId: string,
    offset?: number,
    limit?: number,
    enrichments?: boolean,
    options?: AxiosRequestConfig,
  ) {
    return LoginIdentityApiFp(this.configuration)
      .listTransactionsByAccountId(accountId, offset, limit, enrichments, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of transactions for a login identity. The transactions are returned in sorted order, with the most recent one appearing first.
   * @param {number} [offset] default is 0
   * @param {number} [limit] default is 500, max is 1000
   * @param {boolean} [enrichments] when true, response will be enriched transactions; otherwise it will be raw transactions
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public listTransactionsByLoginIdentityId(
    offset?: number,
    limit?: number,
    enrichments?: boolean,
    options?: AxiosRequestConfig,
  ) {
    return LoginIdentityApiFp(this.configuration)
      .listTransactionsByLoginIdentityId(offset, limit, enrichments, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a refresh job for a login identity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginIdentityApi
   */
  public refreshLoginIdentity(options?: AxiosRequestConfig) {
    return LoginIdentityApiFp(this.configuration)
      .refreshLoginIdentity(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PublicApi - axios parameter creator
 * @export
 */
export const PublicApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Callback url to get the oauth authorization token
     * @param {string} state The state of the client when oauth was initialized
     * @param {string} [code] The authorization code generated by the Oauth provider
     * @param {string} [error] error
     * @param {string} [errorDescription] error description
     * @param {string} [errorDetails] error details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authCallback: async (
      state: string,
      code?: string,
      error?: string,
      errorDescription?: string,
      errorDetails?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'state' is not null or undefined
      assertParamExists('authCallback', 'state', state);
      const localVarPath = `/auth/callback`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', ['test'], configuration);

      if (state !== undefined) {
        localVarQueryParameter['state'] = state;
      }

      if (code !== undefined) {
        localVarQueryParameter['code'] = code;
      }

      if (error !== undefined) {
        localVarQueryParameter['error'] = error;
      }

      if (errorDescription !== undefined) {
        localVarQueryParameter['error_description'] = errorDescription;
      }

      if (errorDetails !== undefined) {
        localVarQueryParameter['error_details'] = errorDetails;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * generate an access_token
     * @param {TokenRequest} [tokenRequest] token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateCustomerAccessToken: async (
      tokenRequest?: TokenRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/auth/customer/token`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', ['test'], configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(tokenRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * get jwks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCredSubmitJwks: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/jwks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', ['test'], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * get payment jwks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentsJwks: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/payments/jwks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Oauth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'Oauth2', ['test'], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PublicApi - functional programming interface
 * @export
 */
export const PublicApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PublicApiAxiosParamCreator(configuration);
  return {
    /**
     * Callback url to get the oauth authorization token
     * @param {string} state The state of the client when oauth was initialized
     * @param {string} [code] The authorization code generated by the Oauth provider
     * @param {string} [error] error
     * @param {string} [errorDescription] error description
     * @param {string} [errorDetails] error details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authCallback(
      state: string,
      code?: string,
      error?: string,
      errorDescription?: string,
      errorDetails?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RedirectUriResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.authCallback(
        state,
        code,
        error,
        errorDescription,
        errorDetails,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * generate an access_token
     * @param {TokenRequest} [tokenRequest] token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async generateCustomerAccessToken(
      tokenRequest?: TokenRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.generateCustomerAccessToken(tokenRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * get jwks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCredSubmitJwks(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCredSubmitJwks(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * get payment jwks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPaymentsJwks(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetJWKSResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentsJwks(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * PublicApi - factory interface
 * @export
 */
export const PublicApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = PublicApiFp(configuration);
  return {
    /**
     * Callback url to get the oauth authorization token
     * @param {string} state The state of the client when oauth was initialized
     * @param {string} [code] The authorization code generated by the Oauth provider
     * @param {string} [error] error
     * @param {string} [errorDescription] error description
     * @param {string} [errorDetails] error details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authCallback(
      state: string,
      code?: string,
      error?: string,
      errorDescription?: string,
      errorDetails?: string,
      options?: any,
    ): AxiosPromise<RedirectUriResponse> {
      return localVarFp
        .authCallback(state, code, error, errorDescription, errorDetails, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * generate an access_token
     * @param {TokenRequest} [tokenRequest] token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateCustomerAccessToken(tokenRequest?: TokenRequest, options?: any): AxiosPromise<TokenResponse> {
      return localVarFp.generateCustomerAccessToken(tokenRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * get jwks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCredSubmitJwks(options?: any): AxiosPromise<void> {
      return localVarFp.getCredSubmitJwks(options).then((request) => request(axios, basePath));
    },
    /**
     * get payment jwks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentsJwks(options?: any): AxiosPromise<GetJWKSResponse> {
      return localVarFp.getPaymentsJwks(options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * PublicApi - interface
 * @export
 * @interface PublicApi
 */
export interface PublicApiInterface {
  /**
   * Callback url to get the oauth authorization token
   * @param {string} state The state of the client when oauth was initialized
   * @param {string} [code] The authorization code generated by the Oauth provider
   * @param {string} [error] error
   * @param {string} [errorDescription] error description
   * @param {string} [errorDetails] error details
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PublicApiInterface
   */
  authCallback(
    state: string,
    code?: string,
    error?: string,
    errorDescription?: string,
    errorDetails?: string,
    options?: AxiosRequestConfig,
  ): AxiosPromise<RedirectUriResponse>;

  /**
   * generate an access_token
   * @param {TokenRequest} [tokenRequest] token request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PublicApiInterface
   */
  generateCustomerAccessToken(tokenRequest?: TokenRequest, options?: AxiosRequestConfig): AxiosPromise<TokenResponse>;

  /**
   * get jwks
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PublicApiInterface
   */
  getCredSubmitJwks(options?: AxiosRequestConfig): AxiosPromise<void>;

  /**
   * get payment jwks
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PublicApiInterface
   */
  getPaymentsJwks(options?: AxiosRequestConfig): AxiosPromise<GetJWKSResponse>;
}

/**
 * PublicApi - object-oriented interface
 * @export
 * @class PublicApi
 * @extends {BaseAPI}
 */
export class PublicApi extends BaseAPI implements PublicApiInterface {
  /**
   * Callback url to get the oauth authorization token
   * @param {string} state The state of the client when oauth was initialized
   * @param {string} [code] The authorization code generated by the Oauth provider
   * @param {string} [error] error
   * @param {string} [errorDescription] error description
   * @param {string} [errorDetails] error details
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PublicApi
   */
  public authCallback(
    state: string,
    code?: string,
    error?: string,
    errorDescription?: string,
    errorDetails?: string,
    options?: AxiosRequestConfig,
  ) {
    return PublicApiFp(this.configuration)
      .authCallback(state, code, error, errorDescription, errorDetails, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * generate an access_token
   * @param {TokenRequest} [tokenRequest] token request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PublicApi
   */
  public generateCustomerAccessToken(tokenRequest?: TokenRequest, options?: AxiosRequestConfig) {
    return PublicApiFp(this.configuration)
      .generateCustomerAccessToken(tokenRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * get jwks
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PublicApi
   */
  public getCredSubmitJwks(options?: AxiosRequestConfig) {
    return PublicApiFp(this.configuration)
      .getCredSubmitJwks(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * get payment jwks
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PublicApi
   */
  public getPaymentsJwks(options?: AxiosRequestConfig) {
    return PublicApiFp(this.configuration)
      .getPaymentsJwks(options)
      .then((request) => request(this.axios, this.basePath));
  }
}
